<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>转载 - 标签 - 致力于把技术要点写清楚</title>
        <link>https://bugxch.github.io/tags/%E8%BD%AC%E8%BD%BD/</link>
        <description>转载 - 标签 - 致力于把技术要点写清楚</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>bugxch@126.com (bugxch)</managingEditor>
            <webMaster>bugxch@126.com (bugxch)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sat, 15 Aug 2020 21:25:46 &#43;0800</lastBuildDate><atom:link href="https://bugxch.github.io/tags/%E8%BD%AC%E8%BD%BD/" rel="self" type="application/rss+xml" /><item>
    <title>C&#43;&#43;中的sort函数详解</title>
    <link>https://bugxch.github.io/sort_intro/</link>
    <pubDate>Sat, 15 Aug 2020 21:25:46 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://bugxch.github.io/sort_intro/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://pic.imgdb.cn/item/6002ed073ffa7d37b305c866.jpg" referrerpolicy="no-referrer">
            </div><p>公司认证的leetcode题目中经常会用到sort函数，不是很熟悉，今天系统学习总结下。</p>
<h2 id="总述">总述</h2>
<p>下面是C++的stl中的排序的所有函数，这个系列的博客会逐一介绍，这次的博客先关注最常用的<code>sort</code>函数。</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>sort (first, last)</td>
<td>对容器或普通数组中 [first, last) 范围内的元素进行排序，默认进行升序排序。</td>
</tr>
<tr>
<td>stable_sort (first, last)</td>
<td>和 sort() 函数功能相似，不同之处在于，对于 [first, last) 范围内值相同的元素，该函数不会改变它们的相对位置。</td>
</tr>
<tr>
<td>partial_sort (first, middle, last)</td>
<td>从 [first,last) 范围内，筛选出 muddle-first 个最小的元素并排序存放在 [first，middle) 区间中。</td>
</tr>
<tr>
<td>partial_sort_copy (first, last, result_first, result_last)</td>
<td>从 [first, last) 范围内筛选出 result_last-result_first 个元素排序并存储到 [result_first, result_last) 指定的范围中。</td>
</tr>
<tr>
<td>is_sorted (first, last)</td>
<td>检测 [first, last) 范围内是否已经排好序，默认检测是否按升序排序。</td>
</tr>
<tr>
<td>is_sorted_until (first, last)</td>
<td>和 is_sorted() 函数功能类似，唯一的区别在于，如果 [first, last) 范围的元素没有排好序，则该函数会返回一个指向首个不遵循排序规则的元素的迭代器。</td>
</tr>
<tr>
<td>void nth_element (first, nth, last)</td>
<td>找到 [first, last) 范围内按照排序规则（默认按照升序排序）应该位于第 nth 个位置处的元素，并将其放置到此位置。同时使该位置左侧的所有元素都比其存放的元素小，该位置右侧的所有元素都比其存放的元素大。</td>
</tr>
</tbody>
</table>
<h2 id="sort函数">sort函数</h2>
<h3 id="使用范围">使用范围</h3>
<p>C++ STL 标准库中的 sort() 函数，本质就是一个模板函数。正如表 1 中描述的，该函数专门用来对容器或普通数组中指定范围内的元素进行排序，排序规则默认以元素值的大小做升序排序，除此之外我们也可以选择标准库提供的其它排序规则（比如<code>std::greater&lt;T&gt;</code>降序排序规则），甚至还可以自定义排序规则。</p>
<p>需要注意的是，sort() 函数受到底层实现方式的限制，它仅适用于普通数组和部分类型的容器。换句话说，只有普通数组和具备以下条件的容器，才能使用 sort() 函数：</p>
<ol>
<li>容器支持的迭代器类型必须为随机访问迭代器。这意味着，sort() 只对 array、vector、deque 这 3 个容器提供支持；</li>
<li>如果对容器中指定区域的元素做默认升序排序，则元素类型必须支持<code>&lt;</code>小于运算符；同样，如果选用标准库提供的其它排序规则，元素类型也必须支持该规则底层实现所用的比较运算符；</li>
<li>sort() 函数在实现排序时，需要交换容器中元素的存储位置。这种情况下，如果容器中存储的是自定义的类对象，则该类的内部必须提供移动构造函数和移动赋值运算符。</li>
</ol>
<h3 id="局限">局限</h3>
<p><code>sort</code>函数不保证排序的<a href="https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%A8%B3%E5%AE%9A%E6%80%A7" target="_blank" rel="noopener noreffer">稳定性</a>，即如果被排序的序列中有多个相同值的元素，并不能保证排序之后他们的相对位置保持不变。</p>
<h3 id="使用方法">使用方法</h3>
<p>值得一提的是，sort() 函数位于<code>&lt;algorithm&gt;</code>头文件中，因此在使用该函数前，程序中应包含如下语句：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">#include &lt;algorithm&gt;
</code></pre></td></tr></table>
</div>
</div><p>sort() 函数有 2 种用法，其语法格式分别为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//对 [first, last) 区域内的元素做默认的升序排序
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">sort</span> <span class="p">(</span><span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">RandomAccessIterator</span> <span class="n">last</span><span class="p">);</span>
<span class="c1">//按照指定的 comp 排序规则，对 [first, last) 区域内的元素进行排序
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">sort</span> <span class="p">(</span><span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">RandomAccessIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">Compare</span> <span class="n">comp</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>其中，first 和 last 都为随机访问迭代器，它们的组合 [first, last) 用来指定要排序的目标区域；另外在第 2 种格式中，comp 可以是 C++ STL 标准库提供的排序规则（比如 std::greater<T>），也可以是自定义的排序规则。比如，如果需要做<strong>降序</strong>排序，那么可以使用<code>std::less&lt;T&gt;</code>，也可以自己写一个降序的函数。具体的用法如下所示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;     // std::cout</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;    // std::sort</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;       // std::vector</span><span class="cp">
</span><span class="cp"></span><span class="c1">//以普通函数的方式实现自定义排序规则
</span><span class="c1"></span><span class="kt">bool</span> <span class="nf">mycomp</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//以函数对象的方式实现自定义排序规则
</span><span class="c1"></span><span class="k">class</span> <span class="nc">mycomp2</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myvector</span><span class="p">{</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">71</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">33</span> <span class="p">};</span>
    <span class="c1">//调用第一种语法格式，对 32、71、12、45 进行排序
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">//(12 32 45 71) 26 80 53 33
</span><span class="c1"></span>    <span class="c1">//调用第二种语法格式，利用STL标准库提供的其它比较规则（比如 greater&lt;T&gt;）进行排序
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span> <span class="c1">//(71 45 32 12) 26 80 53 33
</span><span class="c1"></span>
    <span class="c1">//调用第二种语法格式，通过自定义比较规则进行排序
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myvector</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">mycomp2</span><span class="p">());</span> <span class="c1">// 80 71 53 45 33 32 26 12
</span><span class="c1"></span>    <span class="n">sort</span><span class="p">(</span><span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">myvector</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">mycomp</span><span class="p">);</span> <span class="c1">// 80 71 53 45 12 26 32 33
</span><span class="c1"></span>    <span class="c1">//输出 myvector 容器中的元素
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">myvector</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="再探自定义比较函数">再探自定义比较函数</h2>
<h3 id="一元谓词和二元谓词">一元谓词和二元谓词</h3>
<p>sort的自定义比较函数在C++中成为<strong>谓词</strong>，在泛型编程中作为参数使用。按照接受参数的个数不同，谓词分为一元谓词和二元谓词两种。</p>
<ul>
<li>
<p>一元谓词，比如<code>for_each</code>中使用，因为该算法是顺序遍历容器中的每个元素，对每个元素进行操作，所以是一元谓词，如下面的代码片段</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">str</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&#34;i&#34;</span><span class="p">,</span> <span class="s">&#34;love&#34;</span><span class="p">,</span> <span class="s">&#34;leetcode&#34;</span><span class="p">,</span> <span class="s">&#34;i&#34;</span><span class="p">,</span> <span class="s">&#34;love&#34;</span><span class="p">,</span> <span class="s">&#34;coding&#34;</span> <span class="p">};</span>
<span class="kt">void</span> <span class="nf">printEle</span><span class="p">(</span><span class="n">string</span> <span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">for_each</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">str</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">printEle</span><span class="p">)</span> <span class="c1">// printEle是一元谓词
</span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>二元谓词，sort算法是对容器的两个元素进行比较，所以接受两个参数，比如上面的<code>mycomp</code>函数。</p>
</li>
</ul>
<h3 id="可调用对象">可调用对象</h3>
<p>谓词就是一个可调用对象(callable object)，在C++中可调用对象包括4种类型：函数、函数指针、重载函数调用符的类（可以像函数一样使用的类）以及<strong>lambda表达式</strong>。其实在上面的代码片段中，已经在sort算法中使用过函数以及重载函数调用符的类。此处重点介绍一下lambda表达式。lambda表达式的介绍很多，此处直接贴出来参考资料3中的总结表格</p>
<p></p>
<p>从表格中可以看出捕获的类型，分为不捕获局部变量、按值捕获、按引用捕获，混合捕获这几种。参考<a href="https://zh.cppreference.com/w/cpp/algorithm/sort" target="_blank" rel="noopener noreffer">std::sort参考手册</a>中的代码，<code>sort</code>的用法如下所示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span> 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span> 
 
    <span class="c1">// 用默认的 operator&lt; 排序
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
    <span class="p">}</span>   
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
 
    <span class="c1">// 用标准库比较函数对象排序
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
    <span class="p">}</span>   
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
 
    <span class="c1">// 用自定义函数对象排序
</span><span class="c1"></span>    <span class="k">struct</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span>   
            <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">;</span>
        <span class="p">}</span>   
    <span class="p">}</span> <span class="n">customLess</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">customLess</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
    <span class="p">}</span>   
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
 
    <span class="c1">// 用 lambda 表达式排序
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">;</span>   
    <span class="p">});</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
    <span class="p">}</span> 
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">0 1 2 3 4 5 6 7 8 9 
9 8 7 6 5 4 3 2 1 0 
0 1 2 3 4 5 6 7 8 9 
9 8 7 6 5 4 3 2 1 0
</code></pre></td></tr></table>
</div>
</div><p>表示了3种谓词，标准库、函数对象和lambda表达式。这里的二元谓词，告诉了<code>sort</code>，当比较<strong>其中两个元素</strong>的时候该如何处理两个元素的位置。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">struct</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span>   
            <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">;</span>
        <span class="p">}</span>   
    <span class="p">}</span> <span class="n">customLess</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>当上面的函数返回为<code>true</code>时候，那么将<code>a</code>排在<code>b</code>的前面，上面的代码种当<code>a &lt; b</code>时结果为<code>true</code>，所以小的元素排在前面，下面通过做题来示例它的用法。</p>
<h3 id="具体题目">具体题目</h3>
<p>参考<a href="https://leetcode-cn.com/problems/rank-teams-by-votes/" target="_blank" rel="noopener noreffer">1366. 通过投票对团队排名 - 力扣（LeetCode）</a>，具体的代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">Solution</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	<span class="n">string</span> <span class="nf">rankTeams</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">votes</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ranks</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">vote</span> <span class="p">:</span> <span class="n">votes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">ranks</span><span class="p">[</span><span class="n">vote</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="n">votes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">());</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">vote</span> <span class="p">:</span> <span class="n">votes</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vote</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">ranks</span><span class="p">[</span><span class="n">vote</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">i</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">using</span> <span class="n">PCV</span> <span class="o">=</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">;</span>
		<span class="n">vector</span><span class="o">&lt;</span><span class="n">PCV</span><span class="o">&gt;</span> <span class="n">ranking</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">ranks</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">ranks</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">iter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ranking</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span> <span class="p">});</span>
		<span class="p">}</span>
		
        <span class="c1">// lambda表达式
</span><span class="c1"></span>		<span class="n">sort</span><span class="p">(</span><span class="n">ranking</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ranking</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="n">PCV</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">PCV</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">.</span><span class="n">second</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                    <span class="p">}</span>
                    <span class="n">i</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
            <span class="p">});</span>
		<span class="n">string</span> <span class="n">res</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ranking</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">+=</span> <span class="n">ranking</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>以题目中的示例1分析题意</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">第一名得票</th>
<th style="text-align:center">第二名得票</th>
<th style="text-align:center">第三名得票</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">5</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<p>有5个人投票，如果给ABC的3人，从第一名到第三名依次唱票，</p>
<ul>
<li>如果第一名决出胜者，那么该选手获得第一名，剩下的选手角逐第二名；</li>
<li>如果第二名决出胜者，那么该选手获得第一名，剩下的选手就是第三名。</li>
</ul>
<p>如果参选人数超过3人，那么依此类推，直到所有名次所有人都占用为止。这里有一种特殊情况，如果有若干人获得相同的名次，那么以人名的字母排序。比如，如果A和B都得了第一名，那么排序A在前，B在后。注意上面的26行~36行的代码。它表示从第一名到最后一名排序，</p>
<ul>
<li>如果两个选手的在第<code>i</code>个名次上票数相同，那么在第<code>i</code>个名次上不做任何操作（我们认为他们的名次是不分先后的），继续下一个名次<code>i++</code>的比较（第33行）；</li>
<li>如果两个选手在第<code>i</code>个名次上票数不同，那么以票数多者优先排序，退出循环，后面的名次不需要再比较了（第31行）；</li>
<li>如果在两个选手在所有的名次上票数均相同，那么最后按照人名排序（第35行）</li>
</ul>
<p>这里的代码告诉了<code>sort</code>函数该如何对当前所有选手中的两个选手的名次进行排序，它会将其中的两两进行比较给出答案（如何两两比较，我们不用关心），<strong>从微观层面告诉<code>sort</code>函数的两个元素的操作方法</strong>，它就能将所有的选手按照这个方法排好序，这个就是lambda表达式的意义。</p>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="http://c.biancheng.net/view/7457.html" target="_blank" rel="noopener noreffer">C++ sort()排序函数用法详解</a>，c语言中文网的介绍</li>
<li><a href="https://www.geeksforgeeks.org/sort-c-stl/" target="_blank" rel="noopener noreffer">std::sort() in C++ STL - GeeksforGeeks</a>，国外的网站介绍</li>
<li><a href="https://book.douban.com/subject/25708312/" target="_blank" rel="noopener noreffer">C++ Primer 中文版</a>中的10.3节</li>
</ol>]]></description>
</item><item>
    <title>[转载]用于深入思考的小工具</title>
    <link>https://bugxch.github.io/think/</link>
    <pubDate>Sun, 19 Jul 2020 21:18:11 &#43;0800</pubDate>
    <author>Terence Xie</author>
    <guid>https://bugxch.github.io/think/</guid>
    <description><![CDATA[<p>为了能够进一步探讨创造力，深度思考，学习，以及AI当中的一些话题，我发现我不得不先写一篇post来引入关于思考的一些工具和运作方式，作为后续posts探讨的基石。这篇文章会基于我在medium上的post进行展开。</p>
<p>为了掌握一项技能，或者深入一个领域，我们首先要从它们的定义开始入手，即知道，它们是什么，意味着什么。同样的，为了具备创造力，我们首先得弄清楚它最基本的含义是什么。</p>
<p>所谓创造，其最基本的一个含义就是能够做出、发展出一些之前没有的东西，重点在于“之前没有”。这里很tricky的一个地方在于，只要是世人看不到的、接触不到的，即可认为是“没有”，而不必是哲学意义上的本来所固有之类的抽象属性。而为了创造出“世人看不到”的东西，你仅仅需要去看到那些其他人看不到的东西就可以了。</p>
<p>这种“看到他人看不到的东西”的技能，叫做“深入思考”。你的思想越有穿透性，你的洞察力越深入，你就越能看到表象之下他人注意不到的事情。并且，这是一个细密并且会随着你认知能力的成长而成长的动态过程：</p>
<p>为了能够进一步探讨创造力，深度思考，学习，以及AI当中的一些话题，我发现我不得不先写一篇post来引入关于思考的一些工具和运作方式，作为后续posts探讨的基石。这篇文章会基于我在medium上的post进行展开。</p>
<p>为了掌握一项技能，或者深入一个领域，我们首先要从它们的定义开始入手，即知道，它们是什么，意味着什么。同样的，为了具备创造力，我们首先得弄清楚它最基本的含义是什么。</p>
<p>所谓创造，其最基本的一个含义就是能够做出、发展出一些之前没有的东西，重点在于“之前没有”。这里很tricky的一个地方在于，只要是世人看不到的、接触不到的，即可认为是“没有”，而不必是哲学意义上的本来所固有之类的抽象属性。而为了创造出“世人看不到”的东西，你仅仅需要去看到那些其他人看不到的东西就可以了。</p>
<p>这种“看到他人看不到的东西”的技能，叫做“深入思考”。你的思想越有穿透性，你的洞察力越深入，你就越能看到表象之下他人注意不到的事情。并且，这是一个细密并且会随着你认知能力的成长而成长的动态过程：</p>
<ul>
<li>你的穿透性越强，你深入的层次就会越深入；</li>
<li>你的视野越开阔，你所深入的方向就会越丰富；</li>
<li>你对你要解决的问题理解得越透彻，你就越能把握深入的程度，知道深入到哪个层次就必须停止，否则就是偏离你的问题。</li>
</ul>
<p>每个人生而具备的能力是不同的，但我们不应该仅仅满足于继承于“天赋”的技能恒定值。正如人类区别于动物的地方在于，我们不会去接受大自然给我们的固有设定选项。我们会通过思考去发明工具，通过工具去开创出我们想要的世界。同样地，我们绝不应该也满足于自然给我们的“天赋”这一默认选项，我们会有意识地，通过练习、通过一些工具去塑造和提高我们想要的技能。</p>
<p>掌握一项技能从来都不是件容易的事情。其第一步，必须要能够排除一些心理成见，让自己能够专注于训练本身。关于“深入思考”，很多人会拒绝去寻找、去接受提高他们思考能力的工具。他们会把这件事看得非常情绪化，非常personal。他们给出的反应是：提高思考的能力？我难道不会思考？你是说我无法掌握我自己的大脑？你是在侮辱我吗？(One direct ruthless answer from psychology to all these questions is yes, except the last one.)我对这些反应的一个看法是，人们非常容易在那些half-mature的技能或事情上得出偏见性的矛盾结论。</p>
<ul>
<li>如果你想去一个很远的地方，比如某个跨过太平洋的国家，你会很容易地接受这样一个事实：你不能够仅仅通过步行去完成这趟旅行。你会很乐意地运用一些工具，比如汽车或飞机去帮助你到达你的目的地。</li>
<li>如果你想去搜索一些信息，你会很容易地接受你不能够仅仅通过自己的双手和眼睛去到处寻找材料。你会很乐意地运用一些工具，比如Google去帮助你寻找你想要的。</li>
</ul>
<p>那你为什么不能接受你需要运用工具才能好地提高你的思考技能的事实呢？人们通常会对那些他们穷尽所有能力都毫无办法的事情表现得客观一些，而对那些他们可以但却不够成熟的事情表现得很情绪化。（这也是为什么你比他人强一点点会引来嫉妒，强大很多会引来羡慕和祝福。）</p>
<p>请抛掉这些无畏的偏见和情绪，让我们集中于提高思考深度的问题上。</p>
<p>在我看来，问题列表(question list)，实践和写作是用于提高思考深度的最小巧并且最有效的工具组合。它们足够轻便，任何人都可以轻而易举地得到它们。但这样的易得性，丝毫没有降低它们在帮助你进入一个新的领域，解决一些复杂性难题时的有效性。恰恰相反，它们的小巧易得性，能够像Unix工具或者瑞士军刀一样，不仅能够为你提供各种行之有效的组合方案，而且还能将其复杂度和可操作性控制在你能接受的范围之内。</p>
<h2 id="问题列表">问题列表</h2>
<p>每一个领域都有独特的思维方式、思考角度和核心思想。在一个领域里的摸爬滚打，能让你学到的最有价值的东西不是这个领域的知识，而是这个领域独有的思维方式和它背后所展现的核心思想。另一方面，所谓进入一个领域，或者说在一个领域里开始入门，指的是你能够真正以这个领域所独有的角度去思考问题，能够用它背后所蕴含的思想去指导你的行事方式，进而让你具备这个领域所特有的做事风格。</p>
<p>然而，要开始这样一段入门进而不断精深的旅程，你不能够像跑步一样，仅仅对自己说一声“往前”，然后就可以不断前进。大脑不会那样乖乖听话，因为那不是大脑的运作方式。如同钓鱼需要鱼饵，为了能够让大脑开启它的引擎，你也必须提供它的诱饵：“问题”。</p>
<p>人的思维不会自动地往下深入，它只会根据你能提供给它的问题进行运转。你向什么方向抛出问题，它就向什么地方思考；你的问题越精细，它的思考就会越缜密；你抛给大脑的问题越频繁，它所训练的时间就会越长久。大师和新手之间的差距，在于处理一个问题时，他们头脑中的问题列表不同。大师头脑中的问题列表，不仅详实丰富，并且主次分明。他知道首先应该问出什么样的问题，去把握一件事的主题框架；然后，应该在哪些地方问出一些基本的构架性问题，以掌控住局势；最后，应该在哪些地方抛出更为细致的问题，以便能够进一步精细、优化自己所最关心的核心主题。你必须不断地扩充和删减你的问题列表，让它足够充分而又没有冗余，集中在“关节”性的部分，而不会被表象稀释它们的有效性。</p>
<p>如何开始你的成长之旅，让你可以不断扩充你的问题列表？特别是开始阶段，如何从0变为1？我想，一份能够跨越领域的通识性的“元问题”列表或许能够给予你帮助。</p>
<p>进入一个新的领域，你所需要开始的第一个问题系列便是：</p>
<ol>
<li>这个领域为什么会存在？它的意义是什么，能够为世界提供什么价值？</li>
<li>这个领域关心哪些问题？为什么这些问题值得这个领域关心？</li>
<li>你对上述问题的解答全面吗？如果是，你如何能够证明你的解答是完整的？如果不是，你怎样才能搜集到这个领域更多的信息？</li>
</ol>
<p>这些问题所展现的不仅是你如何进入新领域的途径，更是在向你说明，你的大脑如何在阅读上述材料时逐步落地，真正开始深入肤浅的表象，去进一步探索深刻的主题。很多人会嘲笑一些领域的“简单”和“枯燥”，对其从业者所表现出来的对该领域的“诗意”一般的向往表示费解和轻蔑，比如设计、电影、写作、数学和编程。</p>
<p>面对设计作品，我们往往很难体会到设计者背后的良苦用心。为什么我们会不懂设计？因为我们缺乏最起码的入门。但只要我们通过上面的元问题列表检测一下自己，立刻就会推演出自己应该努力的方向，进入深度的沉思状态。</p>
<ol>
<li>为什么设计会存在？它真的仅仅是简单的装饰的堆砌吗？如果是，那为什么有些人会把奢侈品穿成淘宝货，而另外一些人能够把淘宝货穿出奢侈品的格调？如果不是，到底是什么能够让它能够直指你的内心，让你的所有行事方式都跟随设计者的意图移动？（嗯？感觉惊讶吗？嗯，你开始深入思考了）</li>
<li>这个领域关心哪些问题？关心各种细小元素：长、短、明、暗？为什么这些问题值得这个领域关心？仅仅是因为它能影响你的审美吗？它会不会影响你的其它部分呢？你的情绪？判断力？甚至是你的价值取向？</li>
<li>你对上述问题的解答全面吗？所谓设计，仅仅考虑的是它的“美”吗？是否有可能我们完全弄错了它所关心的主题呢？会不会有可能它对“美”的理解完全不同于对装饰的关注呢？</li>
</ol>
<p>没有问题的引导，你甚至不会知道自己的“不知”，轻易地陷入习焉不察、不以为意的恶习。要知道其中的精髓和内在含义，就不得不细加推敲和反复琢磨。这些“推敲”与“琢磨”都是建立在你的“问题列表”之上的。很多新人面对师傅的指导，常常容易听到一句这样的话，“你得多看看，你再多想想”。在我看来，这是非常粗糙的指导。我应该看什么呢？想什么呢？对于稍有经验的人，没有进行深思熟虑是态度问题。可是，对于初学者来说，他还没有构建出相应的问题列表，还不知道应该问什么问题，应该反复推敲一些什么问题。这也就是俗称的没入门。此时给出一份该领域的问题列表，对于新手的成长将会是极其有帮助的。但即便是无人指导（每一个新领域的开拓者都会遇到这样的情况），跨界的元问题列表，也能为你提供一个很好的探索的起点。</p>
<p>所谓问之弥深，钻之弥坚，你思维的引擎会随着所问的问题而不断地提升其转速，而的你思考也会随着问题的引领而不断地加深。没有问题做诱饵，你的思考将无法深入，你的思维也无法缜密。“反复推敲”“心思缜密”“行事谨慎”，没有一份问题列表作依托，就会成为你的一厢情愿。</p>
<p>另一方面，问题列表本身即会构成一个领域的框架。所谓框架，即是一个领域所依托的骨架。如若能够将其骨架上的问题和所思所问一一解决和考量，这个领域的其它部分，便能够得以健康成长。而这些思维的框架无一不是由问题列表所构成，比如波特五力模型，CFA的企业财务健康分析，又或者是创业人士对自己将要构建的世界的分析。在如今创业大潮的时代背景下，列举一份我搜集整理的Google的问题列表，为大家作为参考，翻译如下：</p>
<h2 id="google问题列表">Google问题列表</h2>
<p>思考一下你理想中的工作是什么样的，不是你当前的设想，而是你五年后的图景你想到什么地方去？</p>
<ol>
<li>你想做什么事？</li>
<li>你想赚取多少薪水？</li>
<li>写下你理想中的工作的介绍 (job description)：想想如果你在网上看到它，它应该是什么样的？</li>
</ol>
<p>现在，再想象你穿越到5年后并且你已经得到了这份工作：</p>
<ol>
<li>这时，你的简历上五年前到现在的履历应该是什么样的？</li>
<li>从五年前到你现在得到这个职位，你应该会经历怎样的历程？</li>
</ol>
<p>请继续保持思考你理想中的工作，根据它去评估一下你自己的优势和劣势：你还需要提高哪些方面才能到达哪里？</p>
<p>顺便提一句，如果你的结论是你现在已经得到了你理想中的工作，那么，这说明你的思考还不够大胆。重新做一遍上述的步骤，并且要保证你理想中的工作是基于你当前实力的延展，而不是毫无根据的幻想。</p>
<p>如果你按照以上步骤行事，它应该会有效果。如果你不遵循它们，那么你很可能会为YogiBerra的一段话提供一段新的实例证明：“你要小心了，如果你都不知道你的理想乡在哪里，那么你很可能不会到达那里。”</p>
<p>提出问题和解释问题的技能同给出问题答案的技能同样重要。</p>
<p>现在，如果你对未来有你自己的一些看法，并且有了一些主意，那么你可以问问自己一些更加残酷的问题：</p>
<ol>
<li>一家非常小巧并且资本充裕的竞争公司，会如何去撼动你公司的核心业务？</li>
<li>它会怎样利用数字平台的优势去挖掘你的弱点，或者撬走为你公司带来盈利最多的客户呢？</li>
<li>你公司当前所做的哪些事情正在摧毁自己的业务呢？</li>
<li>同质竞争和收益受损是你公司扼杀潜在创新所经常给出的理由吗？</li>
<li>公司的领导层经常使用自己的产品吗？他们热爱它吗？</li>
<li>他们愿意把自己的产品作为礼物送给自己的另一半吗？（显然这在很多情况下会有点不切实际，但它依旧是一个很好的思想实验。）</li>
<li>你的客户热爱你的产品吗？</li>
<li>还是说，你的客户是被一些其它因素绑定在了你的产品上，但这些因素在未来很可能会消失？</li>
<li>想象一下如果你的客户完全不会被这些因素所绑定，那会发生什么？</li>
<li>上一问题的一个有趣的推论是，如果你强迫你的产品团队将产品做得来让客户可以轻易抛弃你的产品而转向你的竞争者，你的产品团队会有什么样的反应？他们依然能够将产品做得来非常出色，以至于客户想要继续使用你的产品，即便是他们不必如此？</li>
</ol>
<p>关于产品的问题列表：</p>
<ol>
<li>它们有多少部分是建立在独特的技术洞见之上？</li>
<li>有多少产品人是在高管阵营里面？</li>
<li>公司是否狠狠地奖励和提拔了那些在创造出色产品中做出最大贡献的人？</li>
<li>你的决策过程是导向最好的决策？还是导向最容易接受的决策？</li>
<li>你的员工有多大的自由度？</li>
<li>如果你的公司里有一名非常有创造力的员工，这名员工能够有足够的自由度去施展和实现他的想法而不用担心他自己的职位高低吗？</li>
<li>你在新想法的决策是依据产品的优良程度，还是盈利程度？</li>
<li>在你的公司里，谁的表现会更好呢？是那些掌握了大量信息的人，还是传播了大量信息的人？</li>
<li>那些掌握大量信息的人会阻止信息在人们之间互相传播吗？</li>
</ol>
<p>上面都是一些非常残酷的问题，并且他们都没有显而易见的答案。但可以肯定的是，如果这些问题不被提出，那么肯定不会有相应的解决方案。</p>
<p>另外，鉴于我自己的技术背景，这里再提供一份我整理的技术人员的问题列表供大家参考，它们来自于《技术人创业攻略》这本书。</p>
<h3 id="许世伟">许世伟</h3>
<ol>
<li>先了解整个背景，看别人一般怎么做</li>
<li>有哪些新兴的idea，这些idea是不是靠谱，如果我来做，会倾向于哪个方向</li>
<li>新技术的思考方式是什么</li>
<li>它要解决的问题是什么</li>
<li>它和自己要解决的问题有多大的相关性</li>
<li>你对这个技术的“了解”，是只限于多了解了一个名词？</li>
<li>你清楚了这个技术背后的具体原理吗？</li>
</ol>
<p>产品的思考</p>
<ol>
<li>你了解这个产品的业务吗</li>
<li>了解它的运作方式吗</li>
<li>这个产品和商业的关系是什么呢</li>
<li>用户为什么需要我们</li>
<li>我们到底在颠覆什么</li>
<li>到底要做什么，应该如何做</li>
<li>工种认知和服务认知</li>
</ol>
<p>为什么要做这个服务
把服务做好，要做哪些功能
某个功能为什么会受到用户群的欢迎</p>
<h3 id="刘睿敏">刘睿敏</h3>
<p>你想用钱去换技术：</p>
<ol>
<li>技术是别人吃饭的东西，为什么会给你？你如果不自己造一个饭碗，别人为什么会把他的给你呢？</li>
<li>什么叫自主可控？自己做的，从无到有的东西叫自主可控。不是自己做的，就不可控</li>
<li>产业链上最核心的技术有哪些？你是否掌握了这些核心技术？</li>
<li>你是否在持续跟踪这些核心技术？在应用真正开始盛行之前，你做好了理论上的准备吗？</li>
<li>你是否只能谈一些如何应用、基于实践和操作层面的东西？</li>
<li>你能深入细谈核心的技术要点和设计思路吗？</li>
<li>你是否理解你修改的开源产品背后的设计思路？</li>
<li>你是否有循序渐进地、逐层深入地了技术的核心？</li>
<li>上层的工具开发，你是否有做相应的工作？中层的解析执行，你是否知道它们遵循的路径是什么？底层的优化，你是否知道该如何设计，你的优化又如何与其它模块配合？</li>
<li>你的角色是否仅仅是一个使用者？</li>
<li>你是否甚至连这个领域的理论都不清楚，还混淆了其中的各种概念</li>
</ol>
<hr>
<p>这篇文章转载自下面的公众号，大家可以关注公众号GeekArtT</p>]]></description>
</item></channel>
</rss>
