<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - Dive Into Think</title>
        <link>https://bugxch.github.io/posts/</link>
        <description>所有文章 | Dive Into Think</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>bugxch@126.com (bugxch)</managingEditor>
            <webMaster>bugxch@126.com (bugxch)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 22 Jan 2021 08:07:14 &#43;0800</lastBuildDate><atom:link href="https://bugxch.github.io/posts/" rel="self" type="application/rss+xml" /><item>
    <title>[转载]表驱动法代码实践</title>
    <link>https://bugxch.github.io/c_driven_table/</link>
    <pubDate>Fri, 22 Jan 2021 08:07:14 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://bugxch.github.io/c_driven_table/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://pic.imgdb.cn/item/600a17e53ffa7d37b3da9d49.jpg" referrerpolicy="no-referrer">
            </div><p>这是一篇转载，点击查看<a href="https://www.cnblogs.com/clover-toeic/p/3730362.html" target="_blank" rel="noopener noreffer">原文链接</a>。</p>
<div class="details admonition quote open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-quote-right fa-fw"></i>引用<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">数据压倒一切。如果选择了正确的数据结构并把一切组织的井井有条，正确的算法就不言自明。编程的核心是数据结构，而不是算法. &ndash; Rob Pike</div>
        </div>
    </div>
<div class="details admonition tip">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw"></i>说明<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">本文基于这样的认识：数据是易变的，逻辑是稳定的。本文例举的编程实现多为代码片段，但不影响描述的完整性。本文例举的编程虽然基于C语言，但其编程思想也适用于其他语言。此外，本文不涉及语言相关的运行效率讨论。</div>
        </div>
    </div>
<h2 id="概念提出">概念提出</h2>
<p>所谓表驱动法(Table-Driven Approach)简而言之就是用查表的方法获取数据。此处的“表”通常为数组，但可视为数据库的一种体现。根据字典中的部首检字表查找读音未知的汉字就是典型的表驱动法，即以每个字的字形为依据，计算出一个索引值，并映射到对应的页数。相比一页一页地顺序翻字典查字，部首检字法效率极高。</p>
<p>具体到编程方面，在数据不多时可用逻辑判断语句(if…else或switch…case)来获取值；但随着数据的增多，逻辑语句会越来越长，此时表驱动法的优势就开始显现。例如，用36进制(A表示10，B表示11，…)表示更大的数字，逻辑判断语句如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">if</span><span class="p">(</span><span class="n">ucNum</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ucNumChar</span> <span class="o">=</span> <span class="n">ConvertToChar</span><span class="p">(</span><span class="n">ucNum</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">ucNum</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ucNumChar</span> <span class="o">=</span> <span class="sc">&#39;A&#39;</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">ucNum</span> <span class="o">==</span> <span class="mi">11</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ucNumChar</span> <span class="o">=</span> <span class="sc">&#39;B&#39;</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">ucNum</span> <span class="o">==</span> <span class="mi">12</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ucNumChar</span> <span class="o">=</span> <span class="sc">&#39;C&#39;</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//... ...
</span><span class="c1"></span><span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">ucNum</span> <span class="o">==</span> <span class="mi">35</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ucNumChar</span> <span class="o">=</span> <span class="sc">&#39;Z&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当然也可以用switch…case结构，但实现都很冗长。而用表驱动法(将numChar存入数组)则非常直观和简洁。如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">CHAR</span> <span class="n">aNumChars</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;0&#39;</span><span class="p">,</span> <span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="cm">/*3~9*/</span><span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="sc">&#39;B&#39;</span><span class="p">,</span> <span class="sc">&#39;C&#39;</span><span class="p">,</span> <span class="cm">/*D~Y*/</span><span class="sc">&#39;Z&#39;</span><span class="p">};</span>
<span class="n">CHAR</span> <span class="n">ucNumChar</span> <span class="o">=</span> <span class="n">aNumChars</span><span class="p">[</span><span class="n">ucNum</span> <span class="o">%</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">aNumChars</span><span class="p">)];</span>
</code></pre></td></tr></table>
</div>
</div><p>像这样直接将变量当作下数组下标来读取数值的方法就是直接查表法。注意，如果熟悉字符串操作，则上述写法可以更简洁：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">CHAR</span> <span class="n">ucNumChar</span> <span class="o">=</span> <span class="s">&#34;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#34;</span><span class="p">[</span><span class="n">ucNum</span><span class="p">];</span>
</code></pre></td></tr></table>
</div>
</div><p>使用表驱动法时需要关注两个问题：一是如何查表，从表中读取正确的数据；二是表里存放什么，如数值或函数指针。前者参见1.1节“查表方式”内容，后者参见1.2节“实战示例”内容。</p>
<h3 id="查表方式">查表方式</h3>
<p>常用的查表方式有直接查找、索引查找和分段查找等。</p>
<h4 id="直接查找">直接查找</h4>
<p>即直接通过数组下标获取到数据。如果熟悉哈希表的话，可以很容易看出这种查表方式就是哈希表的直接访问法。如获取星期名称，逻辑判断语句如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">if</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">ucDay</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pszDayName</span> <span class="o">=</span> <span class="s">&#34;Sunday&#34;</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">ucDay</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pszDayName</span> <span class="o">=</span> <span class="s">&#34;Monday&#34;</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//... ...
</span><span class="c1"></span><span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="mi">6</span> <span class="o">==</span> <span class="n">ucDay</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pszDayName</span> <span class="o">=</span> <span class="s">&#34;Saturday&#34;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>而实现同样的功能，可将这些数据存储到一个表里：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">CHAR</span> <span class="o">*</span><span class="n">paNumChars</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;Sunday&#34;</span><span class="p">,</span> <span class="s">&#34;Monday&#34;</span><span class="p">,</span> <span class="s">&#34;Tuesday&#34;</span><span class="p">,</span> <span class="s">&#34;Wednesday&#34;</span><span class="p">,</span> <span class="s">&#34;Thursday&#34;</span><span class="p">,</span> <span class="s">&#34;Friday&#34;</span><span class="p">,</span>  <span class="s">&#34;Saturday&#34;</span><span class="p">};</span>
<span class="n">CHAR</span> <span class="o">*</span><span class="n">pszDayName</span> <span class="o">=</span> <span class="n">paNumChars</span><span class="p">[</span><span class="n">ucDay</span><span class="p">];</span>
</code></pre></td></tr></table>
</div>
</div><p>类似哈希表特性，表驱动法适用于无需有序遍历数据，且数据量大小可提前预测的情况。对于过于复杂和庞大的判断，可将数据存为文件，需要时加载文件初始化数组，从而在不修改程序的情况下调整里面的数值。</p>
<p>有时，访问之前需要先进行一次键值转换。如表驱动法表示端口忙闲时，需将槽位端口号映射为全局编号。所生成的端口数目大小的数组，其下标对应全局端口编号，元素值表示相应端口的忙闲状态。</p>
<h4 id="索引查找">索引查找</h4>
<p>有时通过一次键值转换，依然无法把数据(如英文单词等)转为键值。此时可将转换的对应关系写到一个索引表里，即索引访问。</p>
<p>如现有100件商品，4位编号，范围从0000到9999。此时只需要申请一个长度为100的数组，且对应2位键值。但将4位的编号转换为2位的键值，可能过于复杂或没有规律，最合适的方法是建立一个保存该转换关系的索引表。采用索引访问既节省内存，又方便维护。比如索引A表示通过名称访问，索引B表示通过编号访问。</p>
<h4 id="分段查找">分段查找</h4>
<p>通过确定数据所处的范围确定分类(下标)。有的数据可分成若干区间，即具有阶梯性，如分数等级。此时可将每个区间的上限(或下限)存到一个表中，将对应的值存到另一表中，通过第一个表确定所处的区段，再由区段下标在第二个表里读取相应数值。注意要留意端点，可用二分法查找，另外可考虑通过索引方法来代替。如根据分数查绩效等级：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#define MAX_GRADE_LEVEL   (INT8U)5
</span><span class="cp"></span><span class="n">DOUBLE</span> <span class="n">aRangeLimit</span><span class="p">[</span><span class="n">MAX_GRADE_LEVEL</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">50.0</span><span class="p">,</span> <span class="mf">60.0</span><span class="p">,</span> <span class="mf">70.0</span><span class="p">,</span> <span class="mf">80.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">};</span>
<span class="n">CHAR</span> <span class="o">*</span><span class="n">paGrades</span><span class="p">[</span><span class="n">MAX_GRADE_LEVEL</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;Fail&#34;</span><span class="p">,</span> <span class="s">&#34;Pass&#34;</span><span class="p">,</span> <span class="s">&#34;Credit&#34;</span><span class="p">,</span> <span class="s">&#34;Distinction&#34;</span><span class="p">,</span> <span class="s">&#34;High Distinction&#34;</span><span class="p">};</span>

<span class="k">static</span> <span class="n">CHAR</span><span class="o">*</span> <span class="nf">EvaluateGrade</span><span class="p">(</span><span class="n">DOUBLE</span> <span class="n">dScore</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">INT8U</span> <span class="n">ucLevel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(;</span> <span class="n">ucLevel</span> <span class="o">&lt;</span> <span class="n">MAX_GRADE_LEVEL</span><span class="p">;</span> <span class="n">ucLevel</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">dScore</span> <span class="o">&lt;</span> <span class="n">aRangeLimit</span><span class="p">[</span><span class="n">ucLevel</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">paGrades</span><span class="p">[</span><span class="n">ucLevel</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">paGrades</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述两张表(数组)也可合并为一张表(结构体数组)，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">DOUBLE</span>  <span class="n">aRangeLimit</span><span class="p">;</span>
    <span class="n">CHAR</span>    <span class="o">*</span><span class="n">pszGrade</span><span class="p">;</span>
<span class="p">}</span><span class="n">T_GRADE_MAP</span><span class="p">;</span>

<span class="n">T_GRADE_MAP</span> <span class="n">gGradeMap</span><span class="p">[</span><span class="n">MAX_GRADE_LEVEL</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="mf">50.0</span><span class="p">,</span>              <span class="s">&#34;Fail&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="mf">60.0</span><span class="p">,</span>              <span class="s">&#34;Pass&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="mf">70.0</span><span class="p">,</span>              <span class="s">&#34;Credit&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="mf">80.0</span><span class="p">,</span>              <span class="s">&#34;Distinction&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="mf">100.0</span><span class="p">,</span>             <span class="s">&#34;High Distinction&#34;</span><span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">CHAR</span><span class="o">*</span> <span class="nf">EvaluateGrade</span><span class="p">(</span><span class="n">DOUBLE</span> <span class="n">dScore</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">INT8U</span> <span class="n">ucLevel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(;</span> <span class="n">ucLevel</span> <span class="o">&lt;</span> <span class="n">MAX_GRADE_LEVEL</span><span class="p">;</span> <span class="n">ucLevel</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">dScore</span> <span class="o">&lt;</span> <span class="n">gGradeMap</span><span class="p">[</span><span class="n">ucLevel</span><span class="p">].</span><span class="n">aRangeLimit</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">gGradeMap</span><span class="p">[</span><span class="n">ucLevel</span><span class="p">].</span><span class="n">pszGrade</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">gGradeMap</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pszGrade</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>该表结构已具备的数据库的雏形，并可扩展支持更为复杂的数据。其查表方式通常为索引查找，偶尔也为分段查找；当索引具有规律性(如连续整数)时，退化为直接查找。</p>
<p>使用分段查找法时应注意边界，将每一分段范围的上界值都考虑在内。找出所有不在最高一级范围内的值，然后把剩下的值全部归入最高一级中。有时需要人为地为最高一级范围添加一个上界。同时应小心不要错误地用“&lt;”来代替“&lt;=”。要保证循环在找出属于最高一级范围内的值后恰当地结束，同时也要保证恰当处理范围边界。</p>
<h3 id="实战示例">实战示例</h3>
<p>本节多数示例取自实际项目。表形式为一维数组、二维数组和结构体数组；表内容有数据、字符串和函数指针。基于表驱动的思想，表形式和表内容可衍生出丰富的组合。</p>
<h4 id="字符统计">字符统计</h4>
<p>问题：统计用户输入的一串数字中每个数字出现的次数。普通解法主体代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">INT32U</span> <span class="n">aDigitCharNum</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="cm">/* 输入字符串中各数字字符出现的次数 */</span>
<span class="n">INT32U</span> <span class="n">dwStrLen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">szDigits</span><span class="p">);</span>

<span class="n">INT32U</span> <span class="n">dwStrIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(;</span> <span class="n">dwStrIdx</span> <span class="o">&lt;</span> <span class="n">dwStrLen</span><span class="p">;</span> <span class="n">dwStrIdx</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">szDigits</span><span class="p">[</span><span class="n">dwStrIdx</span><span class="p">])</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="sc">&#39;1&#39;</span><span class="o">:</span>
            <span class="n">aDigitCharNum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">&#39;2&#39;</span><span class="o">:</span>
            <span class="n">aDigitCharNum</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="c1">//... ...
</span><span class="c1"></span>        <span class="k">case</span> <span class="sc">&#39;9&#39;</span><span class="o">:</span>
            <span class="n">aDigitCharNum</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这种解法的缺点显而易见，既不美观也不灵活。其问题关键在于未将数字字符与数组aDigitCharNum下标直接关联起来。以下示出更简洁的实现方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">for</span><span class="p">(;</span> <span class="n">dwStrIdx</span> <span class="o">&lt;</span> <span class="n">dwStrLen</span><span class="p">;</span> <span class="n">dwStrIdx</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">aDigitCharNum</span><span class="p">[</span><span class="n">szDigits</span><span class="p">[</span><span class="n">dwStrIdx</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述实现考虑到0也为数字字符。该解法也可扩展至统计所有ASCII可见字符。</p>
<h4 id="月天校验">月天校验</h4>
<p>问题：对给定年份和月份的天数进行校验(需区分平年和闰年)。普通解法主体代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">switch</span><span class="p">(</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Month</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
    <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
    <span class="k">case</span> <span class="mi">5</span><span class="o">:</span>
    <span class="k">case</span> <span class="mi">7</span><span class="o">:</span>
    <span class="k">case</span> <span class="mi">8</span><span class="o">:</span>
    <span class="k">case</span> <span class="mi">10</span><span class="o">:</span>
    <span class="k">case</span> <span class="mi">12</span><span class="o">:</span>
        <span class="k">if</span><span class="p">(</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="o">&gt;</span><span class="mi">31</span> <span class="o">||</span> <span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">CtcOamLog</span><span class="p">(</span><span class="n">FUNCTION_Pon</span><span class="p">,</span><span class="s">&#34;Don&#39;t support this Day: %d(1~31)!!!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="p">);</span>
            <span class="n">retcode</span> <span class="o">=</span> <span class="n">S_ERROR</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
        <span class="k">if</span><span class="p">(((</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Year</span><span class="o">%</span><span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Year</span><span class="o">%</span><span class="mi">100</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Year</span><span class="o">%</span><span class="mi">400</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="o">&gt;</span><span class="mi">29</span> <span class="o">||</span> <span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">CtcOamLog</span><span class="p">(</span><span class="n">FUNCTION_Pon</span><span class="p">,</span><span class="s">&#34;Don&#39;t support this Day: %d(1~29)!!!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="p">);</span>
                <span class="n">retcode</span> <span class="o">=</span> <span class="n">S_ERROR</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="o">&gt;</span><span class="mi">28</span> <span class="o">||</span> <span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">CtcOamLog</span><span class="p">(</span><span class="n">FUNCTION_Pon</span><span class="p">,</span><span class="s">&#34;Don&#39;t support this Day: %d(1~28)!!!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="p">);</span>
                <span class="n">retcode</span> <span class="o">=</span> <span class="n">S_ERROR</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">4</span><span class="o">:</span>
    <span class="k">case</span> <span class="mi">6</span><span class="o">:</span>
    <span class="k">case</span> <span class="mi">9</span><span class="o">:</span>
    <span class="k">case</span> <span class="mi">11</span><span class="o">:</span>
        <span class="k">if</span><span class="p">(</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="o">&gt;</span><span class="mi">30</span> <span class="o">||</span> <span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">CtcOamLog</span><span class="p">(</span><span class="n">FUNCTION_Pon</span><span class="p">,</span><span class="s">&#34;Don&#39;t support this Day: %d(1~30)!!!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="p">);</span>
            <span class="n">retcode</span> <span class="o">=</span> <span class="n">S_ERROR</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="n">CtcOamLog</span><span class="p">(</span><span class="n">FUNCTION_Pon</span><span class="p">,</span><span class="s">&#34;Don&#39;t support this Month: %d(1~12)!!!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">OnuTime</span><span class="p">.</span><span class="n">Month</span><span class="p">);</span>
        <span class="n">retcode</span> <span class="o">=</span> <span class="n">S_ERROR</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>以下示出更简洁的实现方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#define MONTH_OF_YEAR 12    </span><span class="cm">/* 一年中的月份数 */</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 闰年：能被4整除且不能被100整除，或能被400整除 */</span>
<span class="cp">#define IS_LEAP_YEAR(year) ((((year) % 4 == 0) &amp;&amp; ((year) % 100 != 0)) || ((year) % 400 == 0))
</span><span class="cp"></span>
<span class="cm">/* 平年中的各月天数，下标对应月份 */</span>
<span class="n">INT8U</span> <span class="n">aDayOfCommonMonth</span><span class="p">[</span><span class="n">MONTH_OF_YEAR</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">31</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">};</span>

<span class="n">INT8U</span> <span class="n">ucMaxDay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">if</span><span class="p">((</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Month</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">IS_LEAP_YEAR</span><span class="p">(</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Year</span><span class="p">)))</span>
    <span class="n">ucMaxDay</span> <span class="o">=</span> <span class="n">aDayOfCommonMonth</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">else</span>
    <span class="n">ucMaxDay</span> <span class="o">=</span> <span class="n">aDayOfCommonMonth</span><span class="p">[</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Month</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>

<span class="k">if</span><span class="p">((</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span> <span class="o">&gt;</span> <span class="n">ucMaxDay</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">CtcOamLog</span><span class="p">(</span><span class="n">FUNCTION_Pon</span><span class="p">,</span><span class="s">&#34;Month %d doesn&#39;t have this Day: %d(1~%d)!!!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
              <span class="n">OnuTime</span><span class="p">.</span><span class="n">Month</span><span class="p">,</span> <span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="p">,</span> <span class="n">ucMaxDay</span><span class="p">);</span>
    <span class="n">retcode</span> <span class="o">=</span> <span class="n">S_ERROR</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="名称构造">名称构造</h4>
<p>问题：根据WAN接口承载的业务类型(Bitmap)构造业务类型名称字符串。普通解法主体代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">Sub_SetServerType</span><span class="p">(</span><span class="n">INT8U</span> <span class="o">*</span><span class="n">ServerType</span><span class="p">,</span> <span class="n">INT16U</span> <span class="n">wan_servertype</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">wan_servertype</span> <span class="o">&amp;</span> <span class="mh">0x0001</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x0001</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">strcat</span><span class="p">(</span><span class="n">ServerType</span><span class="p">,</span> <span class="s">&#34;_INTERNET&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">wan_servertype</span> <span class="o">&amp;</span> <span class="mh">0x0002</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x0002</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">strcat</span><span class="p">(</span><span class="n">ServerType</span><span class="p">,</span> <span class="s">&#34;_TR069&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">wan_servertype</span> <span class="o">&amp;</span> <span class="mh">0x0004</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x0004</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">strcat</span><span class="p">(</span><span class="n">ServerType</span><span class="p">,</span> <span class="s">&#34;_VOIP&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">wan_servertype</span> <span class="o">&amp;</span> <span class="mh">0x0008</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x0008</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">strcat</span><span class="p">(</span><span class="n">ServerType</span><span class="p">,</span> <span class="s">&#34;_OTHER&#34;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>以下示出C语言中更简洁的实现方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#define  GET_BIT(var, bit)   (((var) &gt;&gt; (bit)) &amp; 0x1)    </span><span class="cm">/* 获取var变量第bit位，编号从右至左 */</span><span class="cp">
</span><span class="cp"></span><span class="k">const</span> <span class="n">CHAR</span><span class="o">*</span> <span class="n">paSvrNames</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;_INTERNET&#34;</span><span class="p">,</span> <span class="s">&#34;_TR069&#34;</span><span class="p">,</span> <span class="s">&#34;_VOIP&#34;</span><span class="p">,</span> <span class="s">&#34;_OTHER&#34;</span><span class="p">};</span>
<span class="k">const</span> <span class="n">INT8U</span> <span class="n">ucSvrNameNum</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">paSvrNames</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">paSvrNames</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="n">VOID</span> <span class="nf">SetServerType</span><span class="p">(</span><span class="n">CHAR</span> <span class="o">*</span><span class="n">pszSvrType</span><span class="p">,</span> <span class="n">INT16U</span> <span class="n">wSvrType</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">INT8U</span> <span class="n">ucIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(;</span> <span class="n">ucIdx</span> <span class="o">&lt;</span> <span class="n">ucSvrNameNum</span><span class="p">;</span> <span class="n">ucIdx</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">GET_BIT</span><span class="p">(</span><span class="n">wSvrType</span><span class="p">,</span> <span class="n">ucIdx</span><span class="p">))</span>
            <span class="n">strcat</span><span class="p">(</span><span class="n">pszSvrType</span><span class="p">,</span> <span class="n">paSvrNames</span><span class="p">[</span><span class="n">ucIdx</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>新的实现将数据和逻辑分离，维护起来非常方便。只要逻辑(规则)不变，则唯一可能的改动就是数据(paSvrNames)。</p>
<h4 id="值名解析">值名解析</h4>
<p>问题：根据枚举变量取值输出其对应的字符串，如PORT_FE(1)输出“Fe”。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//值名映射表结构体定义，用于数值解析器
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
   <span class="n">INT32U</span> <span class="n">dwElem</span><span class="p">;</span>    <span class="c1">//待解析数值，通常为枚举变量
</span><span class="c1"></span>   <span class="n">CHAR</span><span class="o">*</span>  <span class="n">pszName</span><span class="p">;</span>   <span class="c1">//指向数值所对应解析名字符串的指针
</span><span class="c1"></span><span class="p">}</span><span class="n">T_NAME_PARSER</span><span class="p">;</span>

<span class="cm">/******************************************************************************
</span><span class="cm">* 函数名称:  NameParser
</span><span class="cm">* 功能说明:  数值解析器，将给定数值转换为对应的具名字符串
</span><span class="cm">* 输入参数:  VOID *pvMap       :值名映射表数组，含T_NAME_PARSER结构体类型元素
</span><span class="cm">                               VOID指针允许用户在保持成员数目和类型不变的前提下，
</span><span class="cm">                               定制更有意义的结构体名和/或成员名。
</span><span class="cm">            INT32U dwEntryNum :值名映射表数组条目数
</span><span class="cm">            INT32U dwElem     :待解析数值，通常为枚举变量
</span><span class="cm">            INT8U* pszDefName :缺省具名字符串指针，可为空
</span><span class="cm">* 输出参数:  NA
</span><span class="cm">* 返回值  :  INT8U *: 数值所对应的具名字符串
</span><span class="cm">            当无法解析给定数值时，若pszDefName为空，则返回数值对应的16进制格式
</span><span class="cm">            字符串；否则返回pszDefName。
</span><span class="cm">******************************************************************************/</span>
<span class="n">INT8U</span> <span class="o">*</span><span class="nf">NameParser</span><span class="p">(</span><span class="n">VOID</span> <span class="o">*</span><span class="n">pvMap</span><span class="p">,</span> <span class="n">INT32U</span> <span class="n">dwEntryNum</span><span class="p">,</span> <span class="n">INT32U</span> <span class="n">dwElem</span><span class="p">,</span> <span class="n">INT8U</span><span class="o">*</span> <span class="n">pszDefName</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">CHECK_SINGLE_POINTER</span><span class="p">(</span><span class="n">pvMap</span><span class="p">,</span> <span class="s">&#34;NullPoniter&#34;</span><span class="p">);</span>

   <span class="n">INT32U</span> <span class="n">dwEntryIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">for</span><span class="p">(</span><span class="n">dwEntryIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dwEntryIdx</span> <span class="o">&lt;</span> <span class="n">dwEntryNum</span><span class="p">;</span> <span class="n">dwEntryIdx</span><span class="o">++</span><span class="p">)</span>
   <span class="p">{</span>
       <span class="n">T_NAME_PARSER</span> <span class="o">*</span><span class="n">ptNameParser</span> <span class="o">=</span> <span class="p">(</span><span class="n">T_NAME_PARSER</span> <span class="o">*</span><span class="p">)</span><span class="n">pvMap</span><span class="p">;</span>
       <span class="k">if</span><span class="p">(</span><span class="n">dwElem</span> <span class="o">==</span> <span class="n">ptNameParser</span><span class="o">-&gt;</span><span class="n">dwElem</span><span class="p">)</span>
       <span class="p">{</span>
           <span class="k">return</span> <span class="n">ptNameParser</span><span class="o">-&gt;</span><span class="n">pszName</span><span class="p">;</span>
       <span class="p">}</span>
       <span class="c1">//ANSI标准禁止对void指针进行算法操作；GNU标准则指定void*算法操作与char*一致。
</span><span class="c1"></span>       <span class="c1">//若考虑移植性，可将pvMap类型改为INT8U*，或定义INT8U*局部变量指向pvMap。
</span><span class="c1"></span>       <span class="n">pvMap</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T_NAME_PARSER</span><span class="p">);</span>
   <span class="p">}</span>

   <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">pszDefName</span><span class="p">)</span>
   <span class="p">{</span>
       <span class="k">return</span> <span class="n">pszDefName</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">else</span>
   <span class="p">{</span>
       <span class="k">static</span> <span class="n">INT8U</span> <span class="n">szName</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="c1">//Max:&#34;0xFFFFFFFF&#34;
</span><span class="c1"></span>       <span class="n">sprintf</span><span class="p">(</span><span class="n">szName</span><span class="p">,</span> <span class="s">&#34;0x%X&#34;</span><span class="p">,</span> <span class="n">dwElem</span><span class="p">);</span>
       <span class="k">return</span> <span class="n">szName</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>以下给出NameParser的简单应用示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//UNI端口类型值名映射表结构体定义
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">INT32U</span> <span class="n">dwPortType</span><span class="p">;</span>
    <span class="n">INT8U</span><span class="o">*</span> <span class="n">pszPortName</span><span class="p">;</span>
<span class="p">}</span><span class="n">T_PORT_NAME</span><span class="p">;</span>
<span class="c1">//UNI端口类型解析器
</span><span class="c1"></span><span class="n">T_PORT_NAME</span> <span class="n">gUniNameMap</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="mi">1</span><span class="p">,</span>      <span class="s">&#34;Fe&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">3</span><span class="p">,</span>      <span class="s">&#34;Pots&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">99</span><span class="p">,</span>     <span class="s">&#34;Vuni&#34;</span><span class="p">}</span>
<span class="p">};</span>
<span class="k">const</span> <span class="n">INT32U</span> <span class="n">UNI_NAM_MAP_NUM</span> <span class="o">=</span> <span class="p">(</span><span class="n">INT32U</span><span class="p">)(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">gUniNameMap</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T_PORT_NAME</span><span class="p">));</span>
<span class="n">VOID</span> <span class="nf">NameParserTest</span><span class="p">(</span><span class="n">VOID</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">INT8U</span> <span class="n">ucTestIndex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;[%s]&lt;Test Case %u&gt; Result: %s!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">,</span> <span class="n">ucTestIndex</span><span class="o">++</span><span class="p">,</span>
           <span class="n">strcmp</span><span class="p">(</span><span class="s">&#34;Unknown&#34;</span><span class="p">,</span> <span class="n">NameParser</span><span class="p">(</span><span class="n">gUniNameMap</span><span class="p">,</span> <span class="n">UNI_NAM_MAP_NUM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;Unknown&#34;</span><span class="p">))</span> <span class="o">?</span> <span class="s">&#34;ERROR&#34;</span> <span class="o">:</span> <span class="s">&#34;OK&#34;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;[%s]&lt;Test Case %u&gt; Result: %s!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">,</span> <span class="n">ucTestIndex</span><span class="o">++</span><span class="p">,</span>
           <span class="n">strcmp</span><span class="p">(</span><span class="s">&#34;DefName&#34;</span><span class="p">,</span> <span class="n">NameParser</span><span class="p">(</span><span class="n">gUniNameMap</span><span class="p">,</span> <span class="n">UNI_NAM_MAP_NUM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;DefName&#34;</span><span class="p">))</span> <span class="o">?</span> <span class="s">&#34;ERROR&#34;</span> <span class="o">:</span> <span class="s">&#34;OK&#34;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;[%s]&lt;Test Case %u&gt; Result: %s!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">,</span> <span class="n">ucTestIndex</span><span class="o">++</span><span class="p">,</span>
           <span class="n">strcmp</span><span class="p">(</span><span class="s">&#34;Fe&#34;</span><span class="p">,</span> <span class="n">NameParser</span><span class="p">(</span><span class="n">gUniNameMap</span><span class="p">,</span> <span class="n">UNI_NAM_MAP_NUM</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#34;Unknown&#34;</span><span class="p">))</span> <span class="o">?</span> <span class="s">&#34;ERROR&#34;</span> <span class="o">:</span> <span class="s">&#34;OK&#34;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;[%s]&lt;Test Case %u&gt; Result: %s!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">,</span> <span class="n">ucTestIndex</span><span class="o">++</span><span class="p">,</span>
           <span class="n">strcmp</span><span class="p">(</span><span class="s">&#34;Pots&#34;</span><span class="p">,</span> <span class="n">NameParser</span><span class="p">(</span><span class="n">gUniNameMap</span><span class="p">,</span> <span class="n">UNI_NAM_MAP_NUM</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&#34;Unknown&#34;</span><span class="p">))</span> <span class="o">?</span> <span class="s">&#34;ERROR&#34;</span> <span class="o">:</span> <span class="s">&#34;OK&#34;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;[%s]&lt;Test Case %u&gt; Result: %s!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">,</span> <span class="n">ucTestIndex</span><span class="o">++</span><span class="p">,</span>
           <span class="n">strcmp</span><span class="p">(</span><span class="s">&#34;Vuni&#34;</span><span class="p">,</span> <span class="n">NameParser</span><span class="p">(</span><span class="n">gUniNameMap</span><span class="p">,</span> <span class="n">UNI_NAM_MAP_NUM</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">?</span> <span class="s">&#34;ERROR&#34;</span> <span class="o">:</span> <span class="s">&#34;OK&#34;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;[%s]&lt;Test Case %u&gt; Result: %s!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">,</span> <span class="n">ucTestIndex</span><span class="o">++</span><span class="p">,</span>
           <span class="n">strcmp</span><span class="p">(</span><span class="s">&#34;Unknown&#34;</span><span class="p">,</span> <span class="n">NameParser</span><span class="p">(</span><span class="n">gUniNameMap</span><span class="p">,</span> <span class="n">UNI_NAM_MAP_NUM</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="s">&#34;Unknown&#34;</span><span class="p">))</span> <span class="o">?</span> <span class="s">&#34;ERROR&#34;</span> <span class="o">:</span> <span class="s">&#34;OK&#34;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;[%s]&lt;Test Case %u&gt; Result: %s!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">,</span> <span class="n">ucTestIndex</span><span class="o">++</span><span class="p">,</span>
           <span class="n">strcmp</span><span class="p">(</span><span class="s">&#34;0xABCD&#34;</span><span class="p">,</span> <span class="n">NameParser</span><span class="p">(</span><span class="n">gUniNameMap</span><span class="p">,</span> <span class="n">UNI_NAM_MAP_NUM</span><span class="p">,</span> <span class="mh">0xABCD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">?</span> <span class="s">&#34;ERROR&#34;</span> <span class="o">:</span> <span class="s">&#34;OK&#34;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;[%s]&lt;Test Case %u&gt; Result: %s!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">,</span> <span class="n">ucTestIndex</span><span class="o">++</span><span class="p">,</span>
           <span class="n">strcmp</span><span class="p">(</span><span class="s">&#34;NullPoniter&#34;</span><span class="p">,</span> <span class="n">NameParser</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">UNI_NAM_MAP_NUM</span><span class="p">,</span> <span class="mh">0xABCD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">?</span> <span class="s">&#34;ERROR&#34;</span> <span class="o">:</span> <span class="s">&#34;OK&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>gUniNameMap</code>在实际项目中有十余个条目，若采用逻辑链实现将非常冗长。</p>
<h4 id="取值映射">取值映射</h4>
<p>问题：不同模块间同一参数枚举值取值可能有所差异，需要适配。此处不再给出普通的switch…case或if…else if…else结构，而直接示出以下表驱动实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">PORTSTATE</span> <span class="n">loopMEState</span><span class="p">;</span>
    <span class="n">PORTSTATE</span> <span class="n">loopMIBState</span><span class="p">;</span>
<span class="p">}</span><span class="n">LOOPMAPSTRUCT</span><span class="p">;</span>

<span class="k">static</span> <span class="n">LOOPMAPSTRUCT</span> <span class="n">s_CesLoop</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="n">NO_LOOP</span><span class="p">,</span>                  <span class="n">e_ds1_looptype_noloop</span><span class="p">},</span>
    <span class="p">{</span><span class="n">PAYLOAD_LOOP</span><span class="p">,</span>             <span class="n">e_ds1_looptype_PayloadLoop</span><span class="p">},</span>
    <span class="p">{</span><span class="n">LINE_LOOP</span><span class="p">,</span>                <span class="n">e_ds1_looptype_LineLoop</span><span class="p">},</span>
    <span class="p">{</span><span class="n">PON_LOOP</span><span class="p">,</span>                 <span class="n">e_ds1_looptype_OtherLoop</span><span class="p">},</span>
    <span class="p">{</span><span class="n">CES_LOOP</span><span class="p">,</span>                 <span class="n">e_ds1_looptype_InwardLoop</span><span class="p">}};</span>

<span class="n">PORTSTATE</span> <span class="nf">ConvertLoopMEStateToMIBState</span><span class="p">(</span><span class="n">PORTSTATE</span> <span class="n">vPortState</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">INT32U</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ii</span><span class="p">;</span>

    <span class="n">num</span> <span class="o">=</span> <span class="n">ARRAY_NUM</span><span class="p">(</span><span class="n">s_CesLoop</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">ii</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">vPortState</span> <span class="o">==</span> <span class="n">s_CesLoop</span><span class="p">[</span><span class="n">ii</span><span class="p">].</span><span class="n">loopMEState</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">s_CesLoop</span><span class="p">[</span><span class="n">ii</span><span class="p">].</span><span class="n">loopMIBState</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">e_ds1_looptype_noloop</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>相应地，从loopMIBState映射到loopMEState需要定义一个ConvertLoopMIBStateToMEState函数。更进一步，所有类似的一对一映射关系都必须如上的映射(转换)函数，相当繁琐。事实上，从抽象层面看，该映射关系非常简单。提取共性后定义带参数宏，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cm">/**********************************************************
</span><span class="cm">* 功能描述：进行二维数组映射表的一对一映射，用于参数适配
</span><span class="cm">* 参数说明：map        -- 二维数组映射表
</span><span class="cm">            elemSrc    -- 映射源，即待映射的元素值
</span><span class="cm">            elemDest   -- 映射源对应的映射结果
</span><span class="cm">            direction  -- 映射方向字节，表示从数组哪列映射至哪列。
</span><span class="cm">                          高4位对应映射源列，低4位对应映射结果列。
</span><span class="cm">            defaultVal -- 映射失败时置映射结果为缺省值
</span><span class="cm">* 示例：    ARRAY_MAPPER(gCesLoopMap, 3, ucLoop, 0x10, NO_LOOP);
</span><span class="cm">            则ucLoop = 2(LINE_LOOP)
</span><span class="cm">**********************************************************/</span>
<span class="cp">#define ARRAY_MAPPER(map, elemSrc, elemDest, direction, defaultVal) do{\
</span><span class="cp">    INT8U ucMapIdx = 0, ucMapNum = 0; \
</span><span class="cp">    ucMapNum = sizeof(map)/sizeof(map[0]); \
</span><span class="cp">    for(ucMapIdx = 0; ucMapIdx &lt; ucMapNum; ucMapIdx++) \
</span><span class="cp">    { \
</span><span class="cp">        if((elemSrc) == map[ucMapIdx][((direction)&amp;0xF0)&gt;&gt;4]) \
</span><span class="cp">        { \
</span><span class="cp">            elemDest = map[ucMapIdx][(direction)&amp;0x0F]; \
</span><span class="cp">            break; \
</span><span class="cp">        } \
</span><span class="cp">    } \
</span><span class="cp">    if(ucMapIdx == ucMapNum) \
</span><span class="cp">    { \
</span><span class="cp">        elemDest = (defaultVal); \
</span><span class="cp">    } \
</span><span class="cp">}while(0)
</span></code></pre></td></tr></table>
</div>
</div><p>参数取值转换时直接调用统一的映射器宏，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">static</span> <span class="n">INT8U</span> <span class="n">gCesLoopMap</span><span class="p">[][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
   <span class="p">{</span><span class="n">NO_LOOP</span><span class="p">,</span>                  <span class="n">e_ds1_looptype_noloop</span><span class="p">},</span>
   <span class="p">{</span><span class="n">PAYLOAD_LOOP</span><span class="p">,</span>             <span class="n">e_ds1_looptype_PayloadLoop</span><span class="p">},</span>
   <span class="p">{</span><span class="n">LINE_LOOP</span><span class="p">,</span>                <span class="n">e_ds1_looptype_LineLoop</span><span class="p">},</span>
   <span class="p">{</span><span class="n">PON_LOOP</span><span class="p">,</span>                 <span class="n">e_ds1_looptype_OtherLoop</span><span class="p">},</span>
   <span class="p">{</span><span class="n">CES_LOOP</span><span class="p">,</span>                 <span class="n">e_ds1_looptype_InwardLoop</span><span class="p">}};</span>

<span class="n">ARRAY_MAPPER</span><span class="p">(</span><span class="n">gCesLoopMap</span><span class="p">,</span> <span class="n">tPara</span><span class="p">.</span><span class="n">dwParaVal</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dwLoopConf</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="n">e_ds1_looptype_noloop</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>另举一例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#define  CES_DEFAULT_JITTERBUF        (INT32U)2000   </span><span class="cm">/* 默认jitterbuf为2000us，而1帧=125us */</span><span class="cp">
</span><span class="cp">#define  CES_JITTERBUF_STEP           (INT32U)125    </span><span class="cm">/* jitterbuf步长为125us，即1帧 */</span><span class="cp">
</span><span class="cp">#define  CES_DEFAULT_QUEUESIZE        (INT32U)5
</span><span class="cp">#define  CES_DEFAULT_MAX_QUEUESIZE    (INT32U)7
</span><span class="cp"></span>
<span class="cp">#define  ARRAY_NUM(array)             (sizeof(array) / sizeof((array)[0]))  </span><span class="cm">/* 数组元素个数 */</span><span class="cp">
</span><span class="cp"></span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
   <span class="n">INT32U</span>  <span class="n">dwJitterBuffer</span><span class="p">;</span>
   <span class="n">INT32U</span>  <span class="n">dwFramePerPkt</span><span class="p">;</span>
   <span class="n">INT32U</span>  <span class="n">dwQueueSize</span><span class="p">;</span>
<span class="p">}</span><span class="n">QUEUE_SIZE_MAP</span><span class="p">;</span>
<span class="cm">/* gCesQueueSizeMap也可以(JitterBuffer / FramePerPkt)值为索引，更加紧凑 */</span>
<span class="k">static</span> <span class="n">QUEUE_SIZE_MAP</span> <span class="n">gCesQueueSizeMap</span><span class="p">[]</span><span class="o">=</span> <span class="p">{</span>
      <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">},</span>  <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">},</span>  <span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">},</span>  <span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span>  <span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">},</span>  <span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span>  <span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span>  <span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span>  <span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span>  <span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span>  <span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span>  <span class="p">{</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span>  <span class="p">{</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span>  <span class="p">{</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span>  <span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">11</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">11</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">12</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">12</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">13</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">13</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">14</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">14</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">15</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">15</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">16</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">17</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">17</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">18</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">18</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">19</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">19</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">20</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">20</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">21</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">21</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">22</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">22</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">23</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">23</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">24</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">24</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">25</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">25</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">26</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">26</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">27</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">27</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">28</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">28</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">29</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">29</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">30</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">30</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">31</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">31</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">}};</span>
<span class="cm">/**********************************************************
</span><span class="cm">* 函数名称： CalcQueueSize
</span><span class="cm">* 功能描述： 根据JitterBuffer和FramePerPkt计算QueueSize
</span><span class="cm">* 注意事项： 配置的最大缓存深度
</span><span class="cm">*            = 2 * JitterBuffer / FramePerPkt
</span><span class="cm">*            = 2 * N Packet = 2 ^ QueueSize
</span><span class="cm">*            JitterBuffer为125us帧速率的倍数，
</span><span class="cm">*            FramePerPkt为每个分组的帧数，
</span><span class="cm">*            QueueSize向上取整，最大为7。
</span><span class="cm">**********************************************************/</span>
<span class="n">INT32U</span> <span class="nf">CalcQueueSize</span><span class="p">(</span><span class="n">INT32U</span> <span class="n">dwJitterBuffer</span><span class="p">,</span> <span class="n">INT32U</span> <span class="n">dwFramePerPkt</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">INT8U</span> <span class="n">ucIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ucNum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

   <span class="c1">//本函数暂时仅考虑E1
</span><span class="c1"></span>   <span class="n">ucNum</span> <span class="o">=</span> <span class="n">ARRAY_NUM</span><span class="p">(</span><span class="n">gCesQueueSizeMap</span><span class="p">);</span>
   <span class="k">for</span><span class="p">(</span><span class="n">ucIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ucIdx</span> <span class="o">&lt;</span> <span class="n">ucNum</span><span class="p">;</span> <span class="n">ucIdx</span><span class="o">++</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="k">if</span><span class="p">((</span><span class="n">dwJitterBuffer</span> <span class="o">==</span> <span class="n">gCesQueueSizeMap</span><span class="p">[</span><span class="n">ucIdx</span><span class="p">].</span><span class="n">dwJitterBuffer</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
         <span class="p">(</span><span class="n">dwFramePerPkt</span> <span class="o">==</span> <span class="n">gCesQueueSizeMap</span><span class="p">[</span><span class="n">ucIdx</span><span class="p">].</span><span class="n">dwFramePerPkt</span><span class="p">))</span>
      <span class="p">{</span>
           <span class="k">return</span> <span class="n">gCesQueueSizeMap</span><span class="p">[</span><span class="n">ucIdx</span><span class="p">].</span><span class="n">dwQueueSize</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>

   <span class="k">return</span> <span class="n">CES_DEFAULT_MAX_QUEUESIZE</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="版本控制">版本控制</h4>
<p>问题：控制OLT与ONU之间的版本协商。ONU本地设置三比特控制字，其中bit2(MSB)~bit0(LSB)分别对应0x21、0x30和0xAA版本号；且bitX为0表示上报对应版本号，bitX为1表示不上报对应版本号。其他版本号如0x20、0x13和0x1必须上报，即不受控制。最初的实现采用if…else if…else结构，代码非常冗长，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">ucLength</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">gOamCtrlCode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">,</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x30</span><span class="p">;</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x21</span><span class="p">;</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">8</span><span class="p">]),</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">12</span><span class="p">]),</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x13</span><span class="p">;</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">16</span><span class="p">]),</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">20</span><span class="p">]),</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">23</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xaa</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">gOamCtrlCode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">,</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x30</span><span class="p">;</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x21</span><span class="p">;</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">8</span><span class="p">]),</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">12</span><span class="p">]),</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x13</span><span class="p">;</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">16</span><span class="p">]),</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//此处省略gOamCtrlCode == 2~6的处理代码
</span><span class="c1"></span><span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">gOamCtrlCode</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">),</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x13</span><span class="p">;</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">8</span><span class="p">]),</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>以下示出C语言中更简洁的实现方式(基于二维数组)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cm">/**********************************************************************
</span><span class="cm">* 版本控制字数组定义
</span><span class="cm">* gOamCtrlCode:   Bitmap控制字。Bit-X为0时上报对应版本，Bit-X为1时屏蔽对应版本。
</span><span class="cm">* CTRL_VERS_NUM:  可控版本个数。
</span><span class="cm">* CTRL_CODE_NUM:  控制字个数。与CTRL_VERS_NUM有关。
</span><span class="cm">* gOamVerCtrlMap: 版本控制字数组。行对应控制字，列对应可控版本。
</span><span class="cm">                  元素值为0时不上报对应版本，元素值非0时上报该元素值。
</span><span class="cm">* Note: 该数组旨在实现“数据与控制隔离”。后续若要新增可控版本，只需修改
</span><span class="cm">                  -- CTRL_VERS_NUM
</span><span class="cm">                  -- gOamVerCtrlMap新增行(控制字)
</span><span class="cm">                  -- gOamVerCtrlMap新增列(可控版本)
</span><span class="cm">**********************************************************************/</span>
<span class="cp">#define CTRL_VERS_NUM    3
</span><span class="cp">#define CTRL_CODE_NUM    (1&lt;&lt;CTRL_VERS_NUM)
</span><span class="cp"></span><span class="n">u8_t</span> <span class="n">gOamVerCtrlMap</span><span class="p">[</span><span class="n">CTRL_CODE_NUM</span><span class="p">][</span><span class="n">CTRL_VERS_NUM</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
 <span class="cm">/* Ver21         Ver30        VerAA */</span>
    <span class="p">{</span><span class="mh">0x21</span><span class="p">,</span>         <span class="mh">0x30</span><span class="p">,</span>        <span class="mh">0xaa</span><span class="p">},</span>    <span class="cm">/*gOamCtrlCode = 0*/</span>
    <span class="p">{</span><span class="mh">0x21</span><span class="p">,</span>         <span class="mh">0x30</span><span class="p">,</span>          <span class="mi">0</span> <span class="p">},</span>    <span class="cm">/*gOamCtrlCode = 1*/</span>
    <span class="p">{</span><span class="mh">0x21</span><span class="p">,</span>           <span class="mi">0</span><span class="p">,</span>         <span class="mh">0xaa</span><span class="p">},</span>    <span class="cm">/*gOamCtrlCode = 2*/</span>
    <span class="p">{</span><span class="mh">0x21</span><span class="p">,</span>           <span class="mi">0</span><span class="p">,</span>           <span class="mi">0</span> <span class="p">},</span>    <span class="cm">/*gOamCtrlCode = 3*/</span>
    <span class="p">{</span>  <span class="mi">0</span><span class="p">,</span>          <span class="mh">0x30</span><span class="p">,</span>        <span class="mh">0xaa</span><span class="p">},</span>    <span class="cm">/*gOamCtrlCode = 4*/</span>
    <span class="p">{</span>  <span class="mi">0</span><span class="p">,</span>          <span class="mh">0x30</span><span class="p">,</span>          <span class="mi">0</span> <span class="p">},</span>    <span class="cm">/*gOamCtrlCode = 5*/</span>
    <span class="p">{</span>  <span class="mi">0</span><span class="p">,</span>            <span class="mi">0</span><span class="p">,</span>         <span class="mh">0xaa</span><span class="p">},</span>    <span class="cm">/*gOamCtrlCode = 6*/</span>
    <span class="p">{</span>  <span class="mi">0</span><span class="p">,</span>            <span class="mi">0</span><span class="p">,</span>           <span class="mi">0</span> <span class="p">}</span>     <span class="cm">/*gOamCtrlCode = 7*/</span>
<span class="p">};</span>
<span class="cp">#define INFO_TYPE_VERS_LEN    7  </span><span class="cm">/* InfoType + Length + OUI + ExtSupport + Version */</span><span class="cp">
</span><span class="cp"></span>
<span class="n">u8_t</span> <span class="n">verIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">u8_t</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">verIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">verIdx</span> <span class="o">&lt;</span> <span class="n">CTRL_VERS_NUM</span><span class="p">;</span> <span class="n">verIdx</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">gOamVerCtrlMap</span><span class="p">[</span><span class="n">gOamCtrlCode</span><span class="p">][</span><span class="n">verIdx</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
        <span class="n">index</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">gOamVerCtrlMap</span><span class="p">[</span><span class="n">gOamCtrlCode</span><span class="p">][</span><span class="n">verIdx</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">index</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
<span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">index</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x13</span><span class="p">;</span>
<span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">index</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>

<span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">ucLength</span> <span class="o">=</span> <span class="n">INFO_TYPE_VERS_LEN</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="消息处理">消息处理</h4>
<p>问题：终端输入不同的打印命令，调用相应的打印函数，以控制不同级别的打印。</p>
<p>这是一段消息(事件)驱动程序。本模块接收其他模块(如串口驱动)发送的消息，根据消息中的打印级别字符串和开关模式，调用不同函数进行处理。常见的实现方法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">logall</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">g_log_control</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">noanylog</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">g_log_control</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">logOam</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">g_log_control</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="n">FUNCTION_Oam</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">nologOam</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">g_log_control</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="n">FUNCTION_Oam</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//... ...
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">logExec</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">INT8U</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">CtcOamLog</span><span class="p">(</span><span class="n">FUNCTION_Oam</span><span class="p">,</span><span class="s">&#34;log %s %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">enable</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">enable</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="cm">/*log*/</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="s">&#34;all&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*字符串比较，不区分大小写*/</span>
            <span class="n">logall</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="s">&#34;oam&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">logOam</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="s">&#34;pon&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">logPon</span><span class="p">();</span>
        <span class="c1">//... ...
</span><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="s">&#34;version&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">logVersion</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">enable</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/*nolog*/</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="s">&#34;all&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">noanylog</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="s">&#34;oam&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">nologOam</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="s">&#34;pon&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">nologPon</span><span class="p">();</span>
        <span class="c1">//... ...
</span><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="s">&#34;version&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">nologVersion</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;bad log para</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>以下示出C语言中更简洁的实现方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">OAM_LOG_OFF</span> <span class="o">=</span> <span class="p">(</span><span class="n">INT8U</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">OAM_LOG_ON</span>  <span class="o">=</span> <span class="p">(</span><span class="n">INT8U</span><span class="p">)</span><span class="mi">1</span>
<span class="p">}</span><span class="n">E_OAM_LOG_MODE</span><span class="p">;</span>
<span class="k">typedef</span> <span class="nf">FUNC_STATUS</span> <span class="p">(</span><span class="o">*</span><span class="n">OamLogHandler</span><span class="p">)(</span><span class="n">VOID</span><span class="p">);</span>
<span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">CHAR</span>           <span class="o">*</span><span class="n">pszLogCls</span><span class="p">;</span>    <span class="cm">/* 打印级别 */</span>
    <span class="n">E_OAM_LOG_MODE</span> <span class="n">eLogMode</span><span class="p">;</span>      <span class="cm">/* 打印模式 */</span>
    <span class="n">OamLogHandler</span>  <span class="n">fnLogHandler</span><span class="p">;</span>  <span class="cm">/* 打印函数 */</span>
<span class="p">}</span><span class="n">T_OAM_LOG_MAP</span><span class="p">;</span>

<span class="n">T_OAM_LOG_MAP</span> <span class="n">gOamLogMap</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&#34;all&#34;</span><span class="p">,</span>         <span class="n">OAM_LOG_OFF</span><span class="p">,</span>       <span class="n">noanylog</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;oam&#34;</span><span class="p">,</span>         <span class="n">OAM_LOG_OFF</span><span class="p">,</span>       <span class="n">nologOam</span><span class="p">},</span>
    <span class="c1">//... ...
</span><span class="c1"></span>    <span class="p">{</span><span class="s">&#34;version&#34;</span><span class="p">,</span>     <span class="n">OAM_LOG_OFF</span><span class="p">,</span>       <span class="n">nologVersion</span><span class="p">},</span>

    <span class="p">{</span><span class="s">&#34;all&#34;</span><span class="p">,</span>         <span class="n">OAM_LOG_ON</span><span class="p">,</span>        <span class="n">logall</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;oam&#34;</span><span class="p">,</span>         <span class="n">OAM_LOG_ON</span><span class="p">,</span>        <span class="n">logOam</span><span class="p">},</span>
    <span class="c1">//... ...
</span><span class="c1"></span>    <span class="p">{</span><span class="s">&#34;version&#34;</span><span class="p">,</span>     <span class="n">OAM_LOG_ON</span><span class="p">,</span>        <span class="n">logVersion</span><span class="p">}</span>
<span class="p">};</span>
<span class="n">INT32U</span> <span class="n">gOamLogMapNum</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">gOamLogMap</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T_OAM_LOG_MAP</span><span class="p">);</span>

<span class="n">VOID</span> <span class="nf">logExec</span><span class="p">(</span><span class="n">CHAR</span> <span class="o">*</span><span class="n">pszName</span><span class="p">,</span> <span class="n">INT8U</span> <span class="n">ucSwitch</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">INT8U</span> <span class="n">ucIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(;</span> <span class="n">ucIdx</span> <span class="o">&lt;</span> <span class="n">gOamLogMapNum</span><span class="p">;</span> <span class="n">ucIdx</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">((</span><span class="n">ucSwitch</span> <span class="o">==</span> <span class="n">gOamLogMap</span><span class="p">[</span><span class="n">ucIdx</span><span class="p">].</span><span class="n">eLogMode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
           <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">pszName</span><span class="p">,</span> <span class="n">gOamLogMap</span><span class="p">[</span><span class="n">ucIdx</span><span class="p">].</span><span class="n">pszLogCls</span><span class="p">));</span>
        <span class="p">{</span>
            <span class="n">gOamLogMap</span><span class="p">[</span><span class="n">ucIdx</span><span class="p">].</span><span class="n">fnLogHandler</span><span class="p">();</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ucIdx</span> <span class="o">==</span> <span class="n">gOamLogMapNum</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Unknown LogClass(%s) or LogMode(%d)!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pszName</span><span class="p">,</span> <span class="n">ucSwitch</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这种表驱动消息处理实现的优点如下：</p>
<ul>
<li>增强可读性，消息如何处理从表中一目了然。</li>
<li>增强可扩展性。更容易修改，要增加新的消息，只要修改数据即可，不需要修改流程。</li>
<li>降低复杂度。通过把程序逻辑的复杂度转移到人类更容易处理的数据中来，从而达到控制复杂度的目标。</li>
<li>主干清晰，代码重用。
若各索引为顺序枚举值，则建立多维数组(每维对应一个索引)，根据下标直接定位到处理函数，效率会更高。</li>
</ul>
<p>注意，考虑到本节实例中logOam/logPon或nologOam/nologPon等函数本质上是基于打印级别的比特操作，因此可进一步简化。以下例举其相似实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cm">/* 日志控制类型定义 */</span>
<span class="k">typedef</span> <span class="k">enum</span>
<span class="p">{</span>
    <span class="n">LOG_NORM</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>        <span class="cm">/* 未分类日志，可用于通用日志 */</span>
    <span class="n">LOG_FRM</span><span class="p">,</span>             <span class="cm">/* Frame，OMCI帧日志 */</span>
    <span class="n">LOG_PON</span><span class="p">,</span>             <span class="cm">/* Pon，光链路相关日志 */</span>
    <span class="n">LOG_ETH</span><span class="p">,</span>             <span class="cm">/* Ethernet，Layer2以太网日志 */</span>
    <span class="n">LOG_NET</span><span class="p">,</span>             <span class="cm">/* Internet，Layer3网络日志 */</span>
    <span class="n">LOG_MULT</span><span class="p">,</span>            <span class="cm">/* Multicast，组播日志 */</span>
    <span class="n">LOG_QOS</span><span class="p">,</span>             <span class="cm">/* QOS，流量日志 */</span>
    <span class="n">LOG_CES</span><span class="p">,</span>             <span class="cm">/* Ces，TDM电路仿真日志 */</span>
    <span class="n">LOG_VOIP</span><span class="p">,</span>            <span class="cm">/* Voip，语音日志 */</span>
    <span class="n">LOG_ALM</span><span class="p">,</span>             <span class="cm">/* Alarm，告警日志 */</span>
    <span class="n">LOG_PERF</span><span class="p">,</span>            <span class="cm">/* Performance，性能统计日志 */</span>
    <span class="n">LOG_VER</span><span class="p">,</span>             <span class="cm">/* Version，软件升级日志 */</span>
    <span class="n">LOG_XDSL</span><span class="p">,</span>            <span class="cm">/* xDsl日志 */</span>
    <span class="n">LOG_DB</span><span class="p">,</span>              <span class="cm">/* 数据库操作日志 */</span>
    <span class="c1">//新日志类型在此处扩展，共支持32种日志类型
</span><span class="c1"></span>    <span class="n">LOG_ALL</span> <span class="o">=</span> <span class="n">UINT_MAX</span>   <span class="cm">/* 所有日志类型 */</span>
<span class="p">}</span><span class="n">E_LOG_TYPE</span><span class="p">;</span>

<span class="cm">/*****************************************************************************
</span><span class="cm"> * 变量名称：gOmciLogCtrl
</span><span class="cm"> * 作用描述：OMCI日志控制字，BitMap格式(比特编号从LSB至MSB依次为Bit0-&gt;BitN)。
</span><span class="cm"> *           Bit0~N分别对应E_LOG_TYPE各枚举值(除LOG_ALL外)。
</span><span class="cm"> *           BitX为0时关闭日志类型对应的日志功能，BitX为1时则予以打开。
</span><span class="cm"> * 变量范围：该变量为四字节整型静态全局变量，即支持32种日志类型。
</span><span class="cm"> * 访问说明：通过GetOmciLogCtrl/SetOmciLogCtrl/OmciLogCtrl函数访问/设置控制字。
</span><span class="cm"> *****************************************************************************/</span>
<span class="k">static</span> <span class="n">INT32U</span> <span class="n">gOmciLogCtrl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">//日志类型字符串数组，下标为各字符串所对应的日志类型枚举值。
</span><span class="c1"></span><span class="k">static</span> <span class="k">const</span> <span class="n">INT8U</span><span class="o">*</span> <span class="n">paLogTypeName</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#34;Norm&#34;</span><span class="p">,</span>        <span class="s">&#34;Frame&#34;</span><span class="p">,</span>   <span class="s">&#34;Pon&#34;</span><span class="p">,</span>  <span class="s">&#34;Ethernet&#34;</span><span class="p">,</span>  <span class="s">&#34;Internet&#34;</span><span class="p">,</span>
    <span class="s">&#34;Multicast&#34;</span><span class="p">,</span>   <span class="s">&#34;Qos&#34;</span><span class="p">,</span>     <span class="s">&#34;Ces&#34;</span><span class="p">,</span>  <span class="s">&#34;Voip&#34;</span><span class="p">,</span>      <span class="s">&#34;Alarm&#34;</span><span class="p">,</span>
    <span class="s">&#34;Performance&#34;</span><span class="p">,</span> <span class="s">&#34;Version&#34;</span><span class="p">,</span> <span class="s">&#34;Xdsl&#34;</span><span class="p">,</span>  <span class="s">&#34;Db&#34;</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">INT8U</span>  <span class="n">ucLogTypeNameNum</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">paLogTypeName</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">paLogTypeName</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="k">static</span> <span class="n">VOID</span> <span class="nf">SetGlobalLogCtrl</span><span class="p">(</span><span class="n">E_LOG_TYPE</span> <span class="n">eLogType</span><span class="p">,</span> <span class="n">INT8U</span> <span class="n">ucLogSwitch</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">LOG_ON</span> <span class="o">==</span> <span class="n">ucLogSwitch</span><span class="p">)</span>
        <span class="n">gOmciLogCtrl</span> <span class="o">=</span> <span class="n">LOG_ALL</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">gOmciLogCtrl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">VOID</span> <span class="nf">SetSpecificLogCtrl</span><span class="p">(</span><span class="n">E_LOG_TYPE</span> <span class="n">eLogType</span><span class="p">,</span> <span class="n">INT8U</span> <span class="n">ucLogSwitch</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">LOG_ON</span> <span class="o">==</span> <span class="n">ucLogSwitch</span><span class="p">)</span>
        <span class="n">SET_BIT</span><span class="p">(</span><span class="n">gOmciLogCtrl</span><span class="p">,</span> <span class="n">eLogType</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">CLR_BIT</span><span class="p">(</span><span class="n">gOmciLogCtrl</span><span class="p">,</span> <span class="n">eLogType</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">VOID</span> <span class="nf">OmciLogCtrl</span><span class="p">(</span><span class="n">CHAR</span> <span class="o">*</span><span class="n">pszLogType</span><span class="p">,</span> <span class="n">INT8U</span> <span class="n">ucLogSwitch</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">strncasecmp</span><span class="p">(</span><span class="n">pszLogType</span><span class="p">,</span> <span class="s">&#34;All&#34;</span><span class="p">,</span> <span class="n">LOG_TYPE_CMP_LEN</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">SetGlobalLogCtrl</span><span class="p">(</span><span class="n">LOG_ALL</span><span class="p">,</span> <span class="n">ucLogSwitch</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">INT8U</span> <span class="n">ucIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">ucIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ucIdx</span> <span class="o">&lt;</span> <span class="n">ucLogTypeNameNum</span><span class="p">;</span> <span class="n">ucIdx</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">strncasecmp</span><span class="p">(</span><span class="n">pszLogType</span><span class="p">,</span> <span class="n">paLogTypeName</span><span class="p">[</span><span class="n">ucIdx</span><span class="p">],</span> <span class="n">LOG_TYPE_CMP_LEN</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">SetSpecificLogCtrl</span><span class="p">(</span><span class="n">ucIdx</span><span class="p">,</span> <span class="n">ucLogSwitch</span><span class="p">);</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&#34;LogType: %s, LogSwitch: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">paLogTypeName</span><span class="p">[</span><span class="n">ucIdx</span><span class="p">],</span>
                   <span class="p">(</span><span class="mi">1</span><span class="o">==</span><span class="n">ucLogSwitch</span><span class="p">)</span><span class="o">?</span><span class="s">&#34;On&#34;</span><span class="o">:</span><span class="s">&#34;Off&#34;</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">OmciLogHelp</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="掩码表">掩码表</h4>
<p>参见<a href="https://www.cnblogs.com/clover-toeic/p/3732444.html" target="_blank" rel="noopener noreffer">采用掩码方式简化产品国家地区支持能力的表示 - clover_toeic - 博客园</a>一文。该例实现中用到消息、掩码、函数指针等概念。</p>
<h2 id="编程思想">编程思想</h2>
<p>表驱动法属于数据驱动编程的一种，其核心思想在《Unix编程艺术》和《代码大全2》中均有阐述。两者均认为人类阅读复杂数据结构远比复杂的控制流程容易，即<strong>相对于程序逻辑，人类更擅长于处理数据</strong>。本节将由Unix设计原则中的“分离原则”和“表示原则”展开。</p>
<blockquote>
<p><strong>分离原则：策略同机制分离，接口同引擎分离</strong></p>
</blockquote>
<p>机制即提供的功能；策略即如何使用功能。策略的变化要远远快于机制的变化。将两者分离，可以使机制相对保持稳定，而同时支持策略的变化。代码大全中提到“隔离变化”的概念，以及设计模式中提到的将易变化的部分和不易变化的部分分离也是这个思路。</p>
<blockquote>
<p><strong>表示原则：把知识叠入数据以求逻辑质朴而健壮</strong></p>
</blockquote>
<p>即使最简单的程序逻辑让人类来验证也很困难，但就算是很复杂的数据，对人类来说，还是相对容易推导和建模的。数据比编程逻辑更容易驾驭。在复杂数据和复杂代码中选择，宁可选择前者。更进一步，在设计中，应该主动将代码的复杂度转移到数据中去(参考“版本控制”)。</p>
<p>在“消息处理”示例中，每个消息处理的逻辑不变，但消息可能是变化的。将容易变化的消息和不容易变化的查找逻辑分离，即“隔离变化”。此外，该例也体现消息内部的处理逻辑(机制)和不同的消息处理(策略)分离。</p>
<p>数据驱动编程可以应用于：</p>
<ul>
<li>函数级设计，如本文示例。</li>
<li>程序级设计，如用表驱动法实现状态机。</li>
<li>系统级设计，如DSL。</li>
</ul>
<p>注意，数据驱动编程不是全新的编程模型，只是一种设计思路，在Unix/Linux开源社区应用很多。数据驱动编程中，数据不但表示某个对象的状态，实际上还定义程序的流程，这点不同于面向对象设计中的数据“封装”。</p>
<h2 id="附录">附录</h2>
<h3 id="网友观点">网友观点</h3>
<p>(以下观点摘自博客园网友“七心葵”的回帖，非常具有启发性。)</p>
<p>Booch的《面向对象分析与设计》一书中，提到所有的程序设计语言大概有3个源流：结构化编程、面向对象编程、数据驱动编程。我认为数据驱动编程的本质是“参数化抽象”的思想，不同于OO的“规范化抽象”的思想。</p>
<p>数据驱动编程在网络游戏开发过程中很常用，但是少有人专门提到这个词。数据驱动编程有很多名字：元编程，解释器/虚拟机，LOP/微语言/DSL等。包括声明式编程、标记语言、甚至所见即所得的拖放控件，都算是数据驱动编程的一种吧。</p>
<p>数据驱动编程可以帮助处理复杂性，和结构化编程、OO 均可相容。(正交的角度)将变和不变的部分分离，策略和机制分离，由此联想到的还有：(数据和代码的分离，微语言和解释器的分离，被生成代码和代码生成器的分离)；更近一步：(微内核插件式体系结构)。</p>
<p>元编程应该说是更加泛化的数据驱动编程，元编程不是新加入一个间接层，而是退居一步，使得当前的层变成一个间接层。元编程分为静态元编程(编译时)和动态元编程(运行时)，静态元编程本质上是一种代码生成技术或者编译器技术；动态元编程一般通过解释器(或虚拟机)加以实现。</p>
<p>数据驱动编程当然也不应该说是“反抽象的”，但的确与“OO抽象”的思维方式是迥然不同，泾渭分明的，如TAOUP一书中所述：“在Unix的模块化传统和围绕OO语言发展起来的使用模式之间，存在着紧张的对立关系”应该说数据驱动编程的思路与结构化编程和OO是正交的，更类似一种“跳出三界外，不在五行中”的做法。</p>
<h3 id="编程和人的关系">编程和人的关系</h3>
<p>人类心智的限制，一切的背后都有人的因素作为依据：</p>
<ol>
<li>
<p>人同时关注的信息数量：7+-2 (所以要分模块)</p>
</li>
<li>
<p>人接收一组新信息的平均时间5s(所以要简单，系统总的模块数不要太多)</p>
</li>
<li>
<p>人思维的直观性(人的视觉能力和模糊思维能力)，这意味这两点：</p>
<ul>
<li>“直”——更善于思考自己能直接接触把玩的东西；(所以要“浅平透”、使用具象的设计，要尽量代码中只有顺直的流程);</li>
<li>“观”——更善于观图而不是推算逻辑；(所以要表驱动法，数据驱动编程，要UML，要可视化编程——当然MDA是太理想化了)</li>
</ul>
</li>
<li>
<p>人不能持续集中注意力(人在一定的代码行数中产生的bug数量的比例是一定的，所以语言有具有表现力，要体现表达的经济性)，所以要机制与策略分离，要数据和代码分离(数据驱动编程)，要微语言，要DSL，要LOP……</p>
</li>
<li>
<p>人是有创造欲，有现实利益心的(只要偶可能总是不够遵从规范，或想创造规范谋利——只要成本能承受，在硬件领域就不行)</p>
</li>
</ol>
<p>另外，开一个有意思的玩笑，Unix编程艺术艺术的英文缩写为TAOUP，我觉得可以理解为UP之TAO——向上抛出之道——将复杂的易变的逻辑作为数据或更高层代码抛给上层！</p>
<h3 id="函数指针">函数指针</h3>
<p>“消息处理”一节示例中的函数指针有点插件结构的味道。可对这些插件进行方便替换，新增，删除，从而改变程序的行为。而这种改变，对事件处理函数的查找又是隔离的(隔离变化)。</p>
<p>函数指针非常有用，但使用时需注意其缺陷：无法检查参数(parameter)和返回值(return value)的类型。因为函数已经退化成指针，而指针不携带这些类型信息。缺少类型检查，当参数或返回值不一致时，可能会造成严重的错误。</p>
<p>例如，定义三个函数，分别具有两个参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">max</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>  <span class="p">{</span>  <span class="k">return</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="o">?</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">y</span><span class="p">;</span>  <span class="p">}</span>
<span class="kt">int</span> <span class="nf">min</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>  <span class="p">{</span>  <span class="k">return</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">?</span> <span class="nl">x</span><span class="p">:</span> <span class="n">y</span><span class="p">;</span>  <span class="p">}</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>  <span class="p">{</span>  <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>而处理函数却定义为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">process</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)())</span>  <span class="p">{</span>  <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中，第三个参数是一个没有参数且返回int型变量的函数指针。但后面却用<code>process(a,b,max)</code>的方式进行调用，max带有两个参数。若编译器未检查出错误，而又不小心将<code>return (*f)(x,y);</code>写成<code>return (*f)(x);</code>，那么后果可能很严重。</p>
<p>因此在C语言中使用函数指针时，一定要小心<strong>类型陷阱</strong>。</p>
<hr>
<p>注：夹带一些私货，最近上下班会用耳机后台听tinyfool的一些视频，下面这个是关于学习曲线和规律的，启发比较大。如果要成为一个高手，需要在某个领域有一个合理的学习曲线（视频中所说的乐学者的学习曲线），认真练习和总结，持续学习，总会有所小成。因为这个讲座，最近开始阅读之前买了一直没看的《思考，快与慢》和《异类》这两本书，等读完了写个读书笔记。视频见下方</p>
<div class="bilibili"><iframe src="//player.bilibili.com/player.html?bvid=BV1uU4y147Zi&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe></div>

<hr>
<figure>
     <figcaption>
            <h4>欢迎扫码关注我的公众号</h4>
        </figcaption>
</figure>]]></description>
</item><item>
    <title>请回答2020</title>
    <link>https://bugxch.github.io/%E8%AF%B7%E5%9B%9E%E7%AD%942020/</link>
    <pubDate>Sat, 02 Jan 2021 22:26:25 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://bugxch.github.io/%E8%AF%B7%E5%9B%9E%E7%AD%942020/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.pixabay.com/photo/2020/12/10/09/21/face-mask-5819709_960_720.jpg" referrerpolicy="no-referrer">
            </div><p>每个人的一生由记忆组成，但是记忆会随着时间模糊甚至消逝，幸好我们有相机，回望这一年，在人生的长河里给它打个鲜亮的标签。</p>
<p>看到<a href="https://www.cnfeat.com/2021/01/01/question2020/" target="_blank" rel="noopener noreffer">Question2020 - 笨方法学写作</a>的这篇文章，有感而发，我也写一篇2020的年终总结。文章里面写下的答案都是凭第一感觉，每个人的记忆都会有偏差，但是在2021年初的这个当下它们是我此时脑中真实的反应。</p>
<h3 id="问题清单">问题清单</h3>
<p>在过去的一年里，</p>
<p><div class="details admonition question open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-question-circle fa-fw"></i>问题<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">你的什么观念发生了改变？</div>
        </div>
    </div>
以可信考试为例，有四点感触比较深。</p>
<p>第一，如果想要在某个技能上有所突破，必须以<strong>咬定青山不放松的毅力持续投入有效的时间和精力</strong>，这意味着为了将技能磨练到足够高的水平，必须有足量有效的投入，甚至在<strong>必要的时候放弃休息娱乐的时间</strong>。比如因为公司的可信考试，我投入大量时间刷leetcode题目，从之前不知道c++的stl为何物，到现在也能熟练完成中等题目，甚至有勇气参加周赛挑战自己，靠的是8月份以来连续3个月的持续不断的刷题。下图就是今年的力扣的年度总结，当前leetcode的排名是全球27000名左右，希望今年还能更进一层，进入到5000以内吧。</p>
<p></p>
<p>第二，工作之后的学习与学生时代不同，白天大部分时间用于完成日常的工作，而且没有整块的时间预留给你做持续深入的学习，但是又要面临持续提升工作技能的压力，以我学习C++的经历体会，最有效的方法是“<strong>以考促训，预留不被打扰的两小时</strong>”。如果要想有效精进，每天一定要预留不被打扰的整段时间用于练习，最好是早起后上班前或者下班后睡觉前，腾出时间好好学习和思考。</p>
<p>第三，相信<strong>功不唐捐</strong>。持续的微小的积累达到一定的程度之后，往往会发生质变。技能训练尤为明显，借用《为学》的那一段</p>
<blockquote>
<p>天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。人之为学有难易乎？学之，则难者亦易矣；不学，则易者亦难矣。
不问年龄，不求结果，持续投入，水平必然会有提升。</p>
</blockquote>
<p>第四，做一件事情要达到极致，你做到level B是不够的，下定决心之后一定要做到level A。职场上只有惊艳到给别人留下深刻的印象，晋升的机会才会更青睐于你，平平凡凡虽然也没有错，但是如果真的笃定升职，全力以赴做到顶尖才是效率最高的方法。比如，如果要你想给人技术很厉害的印象，那么可信考试科目一做出来两道题是不够的，必须3道全部完成，只有这样的shock才能让别人在心里留下“编程NB”的印象。</p>
<p><div class="details admonition question open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-question-circle fa-fw"></i>问题<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">你的生活有什么大的变化吗？最大的幸福感来自哪里?</div>
        </div>
    </div>
应该说从2019年开始，有两件事情，<strong>养育小孩</strong>和<strong>拥有属于自己的房子</strong>。</p>
<p>在有小孩之前，老婆觉得生小孩就是完成女性的生育任务，她的人生是金融界大佬、保代人和投行精英，哪成想生下果果的那一刻起就母性大发，现在恨不得辞职在家天天在家带娃，果果带给我们的快乐确实很多，小孩子天真烂漫，成长中的小趣事能解大人的多重烦忧啊。果果带给我很多<strong>惊奇时刻</strong>，现在回想起来有两件事情我印象深刻。今年过年之后他第一次回上海，那时候大概14个月大刚学着走路，不会说话，当时我、丫丫和妈妈都在卧室，妈妈问果果“哪个是妈妈呀？”，我以为他不知道，结果他指着丫丫，然后又问“哪个是爸爸？”，他又指着我，问“谁是奶奶？”，指着妈妈。那一刻我直接被shock了，虽然他不会说话，但是实际上已经可以分清楚爸爸、妈妈和奶奶了。</p>
<figure>
     <figcaption>
            <h4>5月份，14个月大的果果</h4>
        </figcaption>
</figure>

<p>今年6月底回湖北最多只能说两个词，9月份回到上海的时候就已经是成天指着这个问“这个是什么？”的好奇宝宝了，耳朵也异常灵敏，听到洗衣机运转的声音就会问，“什么东西响呀？”。我惊叹于人类小孩大脑发育的速度之快，短短几个月语言功能就发展到惊人的程度，有一次他自己在沙发上玩小汽车，玩弄了半天终于把车门打开了，顺口说出“终于打开了”，“终于”这个词语之前没有人跟他提起过，就算是他无意间听到了，也没人教他什么意思怎么用，他正确无误得把这个词语用得恰到好处，我和丫丫、妈妈觉得又可爱又惊讶。</p>
<figure>
     <figcaption>
            <h4>9月份，在家乐福，三代同框</h4>
        </figcaption>
</figure>

<p>我小时候因为照片很少，不能知道自己小时候的样子，非常遗憾。我现在随手会给果果拍照片或者录视频，他不会有第2个2岁、3岁和5岁，人生就是一把开弓离弦的箭，不断奔向时间的前方，他长大后回看这些曾经的照片视频，应该是很有意思的一件事情。初步计划会在我的公众号给他开一个专栏，就叫<strong>果果成长记</strong>系列，不定期更新他的照片和视频，将来就是给他最好的礼物之一。打个广告，请扫描文末的二维码关注我的公众号。</p>
<p>买房子之后最大的幸福感来自于可以敞开钱包购置自己想买的那些大件商品，比如一个好床垫，一个好书桌，一台好电视。</p>
<p><figure>
     <figcaption>
            <h4>5月份，逛小区</h4>
        </figcaption>
</figure>

我们在3月份签订了购房居间合同，按照正常的流程应该在贷款下来之后就可以交接入住了，但是房东由于坐月子所以延迟两个月交房，中间我会突然兴起去看小区，经常想着入住之后的样子，幸好房东近两年刚装修完，而且装修风格简洁明快，风格不错，有自己的小窝感觉还是很幸福的。交接之后，我们去宜家挑了书桌、床垫和餐桌，购置了新冰箱，双十一换了新燃气热水器，房子虽小，好好收拾了下书房，不过当下住着还是蛮舒服的。
<figure>
     <figcaption>
            <h4>9月份，书房刚收拾好时的样子</h4>
        </figcaption>
</figure>
</p>
<p><div class="details admonition question open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-question-circle fa-fw"></i>问题<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">你有哪些有意思的发现？比如公众号，综艺节目或者一本书？</div>
        </div>
    </div>
在之前我有一个习惯，发现有意思的网站，都会放在我博客的<a href="https://bugxch.github.io/collection/" target="_blank" rel="noopener noreffer">杂记</a>的页面，2018年收集了很多，但是后来博客迁来迁去丢失了，现在又在慢慢攒。当前我时常浏览的博客就是下面几个，</p>
<ul>
<li>
<p><a href="https://pmthinking.com/" target="_blank" rel="noopener noreffer">产品沉思录 · Product Thinking</a>，2020年发现的比较好的&gt; 产品的网站</p>
</li>
<li>
<p><a href="https://hugoloveit.com/zh-cn/" target="_blank" rel="noopener noreffer">LoveIt</a>，当前网站的主题介绍文章，可以参考文章插入图片、视频和音乐</p>
</li>
<li>
<p><a href="http://www.sharetechnote.com/" target="_blank" rel="noopener noreffer">ShareTechnote</a>，一个韩国高级工程师搭建的专业知识共享网站</p>
</li>
<li>
<p><a href="https://coolshell.cn/" target="_blank" rel="noopener noreffer">酷壳 – CoolShell.cn</a>，左耳朵耗子的官方博客，对我影响比较大的技术大佬</p>
</li>
<li>
<p><a href="https://spaces.ac.cn/" target="_blank" rel="noopener noreffer">科学空间|Scientific Spaces</a>，非常不错的后生，天文、数学、AI、竞赛，博文质量极高，在这么小的年龄以十年的尺度更新不辍，非常难得</p>
</li>
<li>
<p><a href="https://www.ruanyifeng.com/blog/" target="_blank" rel="noopener noreffer">阮一峰的网络日志</a>，IT圈子中小有名气的大佬，比较喜欢他每周一推的科技爱好者周刊系列
推荐搞IT的同学关注。
另外，推荐腾讯视频的<a href="https://v.qq.com/x/cover/mzc002006bujgo5/c3217pq213q.html?" target="_blank" rel="noopener noreffer">《十三邀》</a>节目，当前最新一期是去年的五条人乐队，这些访谈采访比较随意，不通过制造噱头可以拉高收视率，率真自然，推荐观看。去年没怎么看书，依然推荐老六的<a href="http://www.duku.cn/" target="_blank" rel="noopener noreffer">《读库》</a>系列，最近好像涨价了，不过品质一直没变。我最近有强烈的感受，现在我已经对之前大学时期的偏文学社科的书目不太感兴趣了，更多的将精力投入到职业技能的提升上，我去年C++的书籍买了一堆，计划今年攻克这些大部头，愚公移山，犹未为晚也。
</p>
</li>
<li>
<p>今年完整看过极力推荐的两部电视剧都改编自紫金陈的小说，<a href="https://movie.douban.com/subject/33404425/?from=subject-page" target="_blank" rel="noopener noreffer">隐秘的角落 (豆瓣)</a>和<a href="https://movie.douban.com/subject/33447642/" target="_blank" rel="noopener noreffer">沉默的真相 (豆瓣)</a>，第二部豆瓣给出了9.2的高分，国产电视剧能到8.0以上就值得花时间看了，第二部我是在国庆的客厅沙发上几乎通宵追完的，为此还买了一个月的爱奇艺会员，确实值得。不过今年有一部好剧烂尾了，改编自孙皓晖的<a href="https://book.douban.com/subject/3079029/" target="_blank" rel="noopener noreffer">《大秦帝国》</a>的终章<a href="https://movie.douban.com/subject/26413293/" target="_blank" rel="noopener noreffer">《大秦赋 》</a>，情节冗长拖沓，剧本被资方改得七零八碎，追了大概20集弃剧了，不建议入坑。</p>
</li>
</ul>
<p><div class="details admonition question open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-question-circle fa-fw"></i>问题<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">你买到了什么好东西，可以推荐给大家吗？</div>
        </div>
    </div>
今年最大支出是房子，这个就不多谈了，我在设备更新上花钱比较多，年中给我的整体升级了我的小黑硬件配置</p>
<ul>
<li>500大洋的<a href="https://item.jd.com/6212482.html" target="_blank" rel="noopener noreffer">三星（SAMSUNG）500GB SSD固态硬盘 SATA3.0接口 860 EVO（MZ-76E500B）</a>把原来的机械硬盘换到固态硬盘</li>
<li>200大洋将当前的内存从4G升级到16G，<a href="https://item.jd.com/26139216296.html" target="_blank" rel="noopener noreffer">三星SAMSUNG内存条4g8g16g32g ddr4 ddr3l</a>
仅仅700大洋，之前的电脑卡死现象改善明显，开始时间由原来的1分钟降到10秒钟，打开大型文档或者多任务并行也不卡了，电脑体验的大幅改善肉眼可见，幸福感爆棚，建议大家也早点升级自己的硬件装备，早买早享受。</li>
<li>老婆将自己原来的T460电脑给了岳父，我转手4000大洋在公司内购了一台华为的2019 MateBook 14，内存小了点（8G），512G的固态硬盘，对于老婆这种重文档处理的情景用起来也足够，打开文档嗖嗖快。</li>
<li>我现在在用公司内测机的Mate 30 Pro，之前一直用iphone SE，今年上半年还曾动过买iphone SE 2的念头，不过现在完全喜欢上手上的这部手机了，华为手机最大优点是续航，但是别的方便做的也不错，很结实耐用，真的是钢铁直男做出来的手机，如果内测机折价卖给我，那肯定就这部了。</li>
<li>1600大洋，8月份手痒买了<a href="https://time.geekbang.org/" target="_blank" rel="noopener noreffer">《极客时间》</a>的算法训练营课程，现在想来稍微有点贵，因为他视频的课程在3个月之后是要失效的，不能永久保存，上这门课最大的收获是养成了正确的算法练习方法，这个可以再单独写一篇感想。</li>
<li>剩下的大件就是购置新家的家具，零零碎碎加上电器购置下来也有1w大洋左右了，主要选宜家，这里推荐<strong>宜家</strong>，质量和售后有保证，9月份买的床垫短了，我在12月份退掉买了个新的，过程有点波折，但是总体感受还可以。
在消费上，在满足自己需求的条件下，我坚持下面两个原则，</li>
</ul>
<ol>
<li><strong>不看贵贱，买价格和价值最匹配的</strong>，有可能这个东西比较贵，但是如果他贵的有道理，那就值得它的价格；</li>
<li><strong>对于长期需要使用的商品，在可承受的范围之内，我宁可买个贵而且好用的，也不会将就买便宜的</strong>，比如床垫，冰箱，键盘。</li>
</ol>
<p><div class="details admonition question open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-question-circle fa-fw"></i>问题<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">你的养成了什么好习惯或者坏习惯？</div>
        </div>
    </div>
最大的好习惯包括坚持刷题，勤耕不辍，题目做不出来茶饭不思。
坏习惯包括，</p>
<ul>
<li>喜欢躺在床上看手机，这个既对颈椎不好而且晚上看久了也影响第二天工作的精力，必须改；</li>
<li>没有坚持健身，今年体检就有脂肪肝了，问题比往年要多一些，今年也要改善，老婆买了划船机也要定期用起来。</li>
<li>之前使用随手记记账的习惯也丢了，去年因为买房所以花销肯定比较大，今年从元旦开始重新记账。</li>
</ul>
<p><div class="details admonition question open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-question-circle fa-fw"></i>问题<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">你最大的变化是什么？来年你期待有什么变化？</div>
        </div>
    </div>
相信努力的效果，在强手如林的我司，尤其是我们团队，相信自己能精进技能而且可以找到自己的定位。来年期待可以花更多精力在育儿上，果果慢慢大了，到了狗都嫌的2岁了，现在性格有些胆小，虽然不知道什么原因，但是我发现只要我陪伴多一点他就快乐胆大些。多读些育儿书籍，多与果果互动。还有一个，加强锻炼，已经到了不投入时间健身疾病就会找上门来的年龄了，以长远计，健康的体魄是迎接挑战享受日后人生的保障那~</p>
<h3 id="年度照片">年度照片</h3>
<p>下面是我的年度照片，每个月挑选1到2张有代表性的意思一下（右键 -&gt; 在新标签页中打开图片可以看到高清大图，博客不知道为什么不能显示最大的清晰度），</p>
<figure>
     <figcaption>
            <h4>1月下旬，因为新冠爆发，我和丫丫只能在上海过年，家乐福购物归来</h4>
        </figcaption>
</figure>

<figure>
     <figcaption>
            <h4>2月份，work at home，自制办公桌，后来不小心把显示器掉下来摔坏右上角</h4>
        </figcaption>
</figure>

<figure>
     <figcaption>
            <h4>2月份，疫情期间在家坚持学习的易老师</h4>
        </figcaption>
</figure>

<figure>
     <figcaption>
            <h4>2月份，第一个上班日，公司严正以待</h4>
        </figcaption>
</figure>

<figure>
     <figcaption>
            <h4>2月份，同上，连按压取水都要用纸巾衬着</h4>
        </figcaption>
</figure>

<figure>
     <figcaption>
            <h4>3月份，与易老师去高行看房，拍照留念小发卡</h4>
        </figcaption>
</figure>

<figure>
     <figcaption>
            <h4>4月份，老树发新芽的博兴路</h4>
        </figcaption>
</figure>

<figure>
     <figcaption>
            <h4>5月份，不记得在哪里拍的了</h4>
        </figcaption>
</figure>

<figure>
     <figcaption>
            <h4>5月份，一家人逛滨江大道</h4>
        </figcaption>
</figure>

<figure>
     <figcaption>
            <h4>5月份，有起床气的某宝宝</h4>
        </figcaption>
</figure>

<figure>
     <figcaption>
            <h4>5月份，有了自己的房子</h4>
        </figcaption>
</figure>

<figure>
     <figcaption>
            <h4>6月份，不肯睡觉喜欢玩妈妈化妆品的某宝宝</h4>
        </figcaption>
</figure>

<figure>
     <figcaption>
            <h4>7月份，疫情期间装修停滞的西西弗书店金桥国际店开了</h4>
        </figcaption>
</figure>

<figure>
     <figcaption>
            <h4>8月份，和易老师骑行黄浦滨江，美哉</h4>
        </figcaption>
</figure>

<figure>
     <figcaption>
            <h4>8月份，易老师骑行黄浦滨江的曼妙身影</h4>
        </figcaption>
</figure>

<figure>
     <figcaption>
            <h4>8月份，搬离最后的出租屋，迁入新家</h4>
        </figcaption>
</figure>

<figure>
     <figcaption>
            <h4>9月份，新家阳台所摄，很喜欢满眼的绿色，远处是上海中心大厦</h4>
        </figcaption>
</figure>

<figure>
     <figcaption>
            <h4>9月份，和易老师到杨浦宜家购置新家具</h4>
        </figcaption>
</figure>

<figure>
     <figcaption>
            <h4>10月份，爸爸第一次来上海，祖孙三代合影</h4>
        </figcaption>
</figure>

<figure>
     <figcaption>
            <h4>12月份，初冬的博兴路</h4>
        </figcaption>
</figure>

<hr>
<figure>
     <figcaption>
            <h4>欢迎扫码关注我的公众号</h4>
        </figcaption>
</figure>]]></description>
</item><item>
    <title>LeetCode区间问题总结</title>
    <link>https://bugxch.github.io/intersection/</link>
    <pubDate>Sun, 16 Aug 2020 22:31:31 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://bugxch.github.io/intersection/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.pixabay.com/photo/2013/07/18/20/26/sea-164989_960_720.jpg" referrerpolicy="no-referrer">
            </div><p>上周五考试没有过，其中专业级第二题是关于区间的问题，在leetcode上找到类似的题目，总结复习下。</p>
<h2 id="引子">引子</h2>
<p>先看这道题，<a href="https://leetcode-cn.com/problems/corporate-flight-bookings/" target="_blank" rel="noopener noreffer">1109. 航班预订统计</a>，题目是这样的</p>
<p>这里有<code>n</code> 个航班，它们分别从 1 到 n 进行编号。</p>
<p>我们这儿有一份航班预订表，表中第 <code>i</code> 条预订记录 <code>bookings[i] = [i, j, k]</code> 意味着我们在从 <code>i</code> 到<code> j</code> 的每个航班上预订了 <code>k</code> 个座位。</p>
<p>请你返回一个长度为 n 的数组 <code>answer</code>，按航班编号顺序返回每个航班上预订的座位数。参考示例如下，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="err">输入：</span><span class="n">bookings</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">20</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">25</span><span class="p">]],</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span>
<span class="err">输出：</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">55</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">25</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="解题思路">解题思路</h3>
<p>将这道题的示例画一张表格表示一下，就是下面的结果</p>
<table>
<thead>
<tr>
<th style="text-align:center">booking</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">10</td>
<td style="text-align:center">10</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">20</td>
<td style="text-align:center">20</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">25</td>
<td style="text-align:center">25</td>
<td style="text-align:center">25</td>
<td style="text-align:center">25</td>
</tr>
<tr>
<td style="text-align:center">total</td>
<td style="text-align:center">10</td>
<td style="text-align:center">55</td>
<td style="text-align:center">45</td>
<td style="text-align:center">25</td>
<td style="text-align:center">25</td>
</tr>
</tbody>
</table>
<p>常规思路就是以航班号为基本坐标，计算每一个航班增加的座位数，然后逐项汇总相加即可。</p>
<ol>
<li>设置初始结果<code>vector&lt;int&gt; res(n, 0)</code>;</li>
<li>遍历<code>bookings</code>，每次取其中的航班的预定数，添加到<code>res</code>对应的数组中，比如第1个booking，那么<code>res[0]+=10; res[1]+=10</code>，依次类推，直到遍历截止。</li>
</ol>
<p>上面的算法比较简单直观，但是可以分析发现，算法的复杂度有点高，两层遍历算法时间复杂度是$O(n^2)$，空间复杂度是$O(n)$不甚理想。</p>
<p>有没有复杂度更简单的思路呢？这里有一个类比<strong>公交站的思路</strong>，可以将航班号码比作公交站牌，比如1号公交站，2号公交站，假定这些公交站是依次按顺序分布在一条直线公路上，<strong>第<code>i</code>个航班的飞机的预定数目就是公交车在第<code>i</code>个公交站发车时候的乘客数目（包括了上车和下车的乘客数</strong>）。</p>
<p>举例说明，第1行表示，第1站交车上人数是10，说明公交车行驶到第1站时上车10人，到第2站时候车上的乘客仍然是10人，说明没有乘客上下车，到第3站时候车上乘客0人，说明此时有10人下车。如果使用长度为<code>N</code>的数组<code>count</code>表示每一站<strong>上下乘客的变化量</strong>(<code>count[i]</code> 表示第<code>i + 1</code>站上下车的乘客变化量），</p>
<blockquote>
<p>对于<code>booking = [i,j,k]</code>，</p>
<ol>
<li>表示在公交站第<code>i</code>站上车<code>k</code>人，<code>count[i - 1] += k</code>；</li>
<li>第<code>i + 1</code>站直到第<code>j</code>站都没有乘客上下车，<code>count[i],...,count[j - 1]</code>无操作；</li>
<li>在第<code>j + 1</code>站下车<code>k</code>人，所以<code>count[j] -= k</code></li>
</ol>
</blockquote>
<p>为了方便起见，<strong>我们缩小问题的规模，以具体的数字代替抽象的代数字母</strong>，假如我们就只有3个公交站，取示例中的前2行，</p>
<ol>
<li>公交车刚开始上的人数是0，<code>vector&lt;int&gt; count(4, 0)</code>；</li>
<li>读取第1行，到达第1站，公交车上10人，说明<strong>上车10人，无人下车，<code>count[0]+= 10</code></strong>，到达第2站公交车上依然是10人，说明也<strong>无人上车和下车</strong>，到达第3站，公交车上0人，说明<strong>10人下车，<code>count[2] -= 10</code></strong>；</li>
<li>读取第2行，公交车到达第2站，公交车上20人，说明<strong>上车20人无人下车，<code>count[1] += 20</code></strong>，第3站车上20人，说明<strong>无人下车</strong>，第4站车上0人，说明<strong>有20人下车, <code>count[3]-=20</code></strong>。</li>
</ol>
<p>遍历结束，得到<code>count = {10, 20, -10，-20}</code>，那么最后每个站点的乘客数就很清楚了，到达第1站前车上乘客0人，到达后上车10人，所以第1站发车前车上10人，第2站到站后上车20人，所以第2站发车前车上乘客10 + 20  = 30人，第3站到站后下车10人，所以发车前车上乘客 30 - 10 = 20人。意思搞清楚之后，代码就很好写了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">corpFlightBookings</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">bookings</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">counter</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">booking</span> <span class="p">:</span> <span class="n">bookings</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">booking</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">booking</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="c1">// 记录每个booking的开始和结尾即可，中间的站点人数无变化
</span><span class="c1"></span>            <span class="n">counter</span><span class="p">[</span><span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">booking</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// start站上车
</span><span class="c1"></span>            <span class="n">counter</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">-=</span> <span class="n">booking</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// end + 1站下车
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>时间复杂度为$O(n)$。</p>
<h2 id="通用框架">通用框架</h2>
<p>「待补充」</p>
<h2 id="典型题目">典型题目</h2>
<p>「待补充」</p>
<h3 id="no-986-区间列表交集">No. 986 区间列表交集</h3>
<p>题目的链接参考<a href="https://leetcode-cn.com/problems/interval-list-intersections/" target="_blank" rel="noopener noreffer">986. 区间列表的交集 - 力扣（LeetCode）</a>，</p>
<h3 id="no-452-引爆气球">No. 452 引爆气球</h3>
<p>题目链接参考<a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener noreffer">452. 用最少数量的箭引爆气球 - 力扣（LeetCode）</a>，这道题目使用<strong>贪心法</strong>，将气球的坐标放在坐标轴上，然后从0开始从左到右逐气球扫描，查看是否有交集，图示如下。</p>
<h2 id="参考资料">参考资料</h2>
<p>「待补充」</p>]]></description>
</item><item>
    <title>「转载」C&#43;&#43;中的sort函数（一）</title>
    <link>https://bugxch.github.io/sort_intro/</link>
    <pubDate>Sat, 15 Aug 2020 21:25:46 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://bugxch.github.io/sort_intro/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://pic.imgdb.cn/item/6002ed073ffa7d37b305c866.jpg" referrerpolicy="no-referrer">
            </div><p>公司认证的leetcode题目中经常会用到sort函数，不是很熟悉，今天系统学习总结下。</p>
<h2 id="总述">总述</h2>
<p>下面是C++的stl中的排序的所有函数，这个系列的博客会逐一介绍，这次的博客先关注最常用的<code>sort</code>函数。</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>sort (first, last)</td>
<td>对容器或普通数组中 [first, last) 范围内的元素进行排序，默认进行升序排序。</td>
</tr>
<tr>
<td>stable_sort (first, last)</td>
<td>和 sort() 函数功能相似，不同之处在于，对于 [first, last) 范围内值相同的元素，该函数不会改变它们的相对位置。</td>
</tr>
<tr>
<td>partial_sort (first, middle, last)</td>
<td>从 [first,last) 范围内，筛选出 muddle-first 个最小的元素并排序存放在 [first，middle) 区间中。</td>
</tr>
<tr>
<td>partial_sort_copy (first, last, result_first, result_last)</td>
<td>从 [first, last) 范围内筛选出 result_last-result_first 个元素排序并存储到 [result_first, result_last) 指定的范围中。</td>
</tr>
<tr>
<td>is_sorted (first, last)</td>
<td>检测 [first, last) 范围内是否已经排好序，默认检测是否按升序排序。</td>
</tr>
<tr>
<td>is_sorted_until (first, last)</td>
<td>和 is_sorted() 函数功能类似，唯一的区别在于，如果 [first, last) 范围的元素没有排好序，则该函数会返回一个指向首个不遵循排序规则的元素的迭代器。</td>
</tr>
<tr>
<td>void nth_element (first, nth, last)</td>
<td>找到 [first, last) 范围内按照排序规则（默认按照升序排序）应该位于第 nth 个位置处的元素，并将其放置到此位置。同时使该位置左侧的所有元素都比其存放的元素小，该位置右侧的所有元素都比其存放的元素大。</td>
</tr>
</tbody>
</table>
<h2 id="sort函数">sort函数</h2>
<h3 id="使用范围">使用范围</h3>
<p>C++ STL 标准库中的 sort() 函数，本质就是一个模板函数。正如表 1 中描述的，该函数专门用来对容器或普通数组中指定范围内的元素进行排序，排序规则默认以元素值的大小做升序排序，除此之外我们也可以选择标准库提供的其它排序规则（比如<code>std::greater&lt;T&gt;</code>降序排序规则），甚至还可以自定义排序规则。</p>
<p>需要注意的是，sort() 函数受到底层实现方式的限制，它仅适用于普通数组和部分类型的容器。换句话说，只有普通数组和具备以下条件的容器，才能使用 sort() 函数：</p>
<ol>
<li>容器支持的迭代器类型必须为随机访问迭代器。这意味着，sort() 只对 array、vector、deque 这 3 个容器提供支持；</li>
<li>如果对容器中指定区域的元素做默认升序排序，则元素类型必须支持<code>&lt;</code>小于运算符；同样，如果选用标准库提供的其它排序规则，元素类型也必须支持该规则底层实现所用的比较运算符；</li>
<li>sort() 函数在实现排序时，需要交换容器中元素的存储位置。这种情况下，如果容器中存储的是自定义的类对象，则该类的内部必须提供移动构造函数和移动赋值运算符。</li>
</ol>
<h3 id="局限">局限</h3>
<p><code>sort</code>函数不保证排序的<a href="https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%A8%B3%E5%AE%9A%E6%80%A7" target="_blank" rel="noopener noreffer">稳定性</a>，即如果被排序的序列中有多个相同值的元素，并不能保证排序之后他们的相对位置保持不变。</p>
<h3 id="使用方法">使用方法</h3>
<p>值得一提的是，sort() 函数位于<code>&lt;algorithm&gt;</code>头文件中，因此在使用该函数前，程序中应包含如下语句：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">#include &lt;algorithm&gt;
</code></pre></td></tr></table>
</div>
</div><p>sort() 函数有 2 种用法，其语法格式分别为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//对 [first, last) 区域内的元素做默认的升序排序
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">sort</span> <span class="p">(</span><span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">RandomAccessIterator</span> <span class="n">last</span><span class="p">);</span>
<span class="c1">//按照指定的 comp 排序规则，对 [first, last) 区域内的元素进行排序
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">sort</span> <span class="p">(</span><span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">RandomAccessIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">Compare</span> <span class="n">comp</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>其中，first 和 last 都为随机访问迭代器，它们的组合 [first, last) 用来指定要排序的目标区域；另外在第 2 种格式中，comp 可以是 C++ STL 标准库提供的排序规则（比如 std::greater<T>），也可以是自定义的排序规则。比如，如果需要做<strong>降序</strong>排序，那么可以使用<code>std::less&lt;T&gt;</code>，也可以自己写一个降序的函数。具体的用法如下所示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;     // std::cout</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;    // std::sort</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;       // std::vector</span><span class="cp">
</span><span class="cp"></span><span class="c1">//以普通函数的方式实现自定义排序规则
</span><span class="c1"></span><span class="kt">bool</span> <span class="nf">mycomp</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//以函数对象的方式实现自定义排序规则
</span><span class="c1"></span><span class="k">class</span> <span class="nc">mycomp2</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myvector</span><span class="p">{</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">71</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">33</span> <span class="p">};</span>
    <span class="c1">//调用第一种语法格式，对 32、71、12、45 进行排序
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">//(12 32 45 71) 26 80 53 33
</span><span class="c1"></span>    <span class="c1">//调用第二种语法格式，利用STL标准库提供的其它比较规则（比如 greater&lt;T&gt;）进行排序
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span> <span class="c1">//(71 45 32 12) 26 80 53 33
</span><span class="c1"></span>
    <span class="c1">//调用第二种语法格式，通过自定义比较规则进行排序
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myvector</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">mycomp2</span><span class="p">());</span> <span class="c1">// 80 71 53 45 33 32 26 12
</span><span class="c1"></span>    <span class="n">sort</span><span class="p">(</span><span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">myvector</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">mycomp</span><span class="p">);</span> <span class="c1">// 80 71 53 45 12 26 32 33
</span><span class="c1"></span>    <span class="c1">//输出 myvector 容器中的元素
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">myvector</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="http://c.biancheng.net/view/7457.html" target="_blank" rel="noopener noreffer">C++ sort()排序函数用法详解</a>，c语言中文网的介绍</li>
<li><a href="https://www.geeksforgeeks.org/sort-c-stl/" target="_blank" rel="noopener noreffer">std::sort() in C++ STL - GeeksforGeeks</a>，国外的网站介绍</li>
</ul>]]></description>
</item><item>
    <title>广度优先搜索详解</title>
    <link>https://bugxch.github.io/dfs_intro/</link>
    <pubDate>Sat, 08 Aug 2020 11:24:24 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://bugxch.github.io/dfs_intro/</guid>
    <description><![CDATA[<p>总结一下广度优先搜索的原理和用法。</p>
<p></p>
<h2 id="引子">引子</h2>
<p>先看这道题<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener noreffer">104. 二叉树的最大深度</a>，题目中给出一个二叉树，求这个二叉树的最大深度。例子中给出下面的二叉树</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">    <span class="m">3</span>
   / <span class="se">\
</span><span class="se"></span>  <span class="m">9</span>  <span class="m">20</span>
    /  <span class="se">\
</span><span class="se"></span>   <span class="m">15</span>   <span class="m">7</span>
</code></pre></td></tr></table>
</div>
</div><p>这个如何解决呢？肉眼可见，最大深度是3。</p>
<h3 id="构建二叉树">构建二叉树</h3>
<p>首先为了便于调试，需要构建一颗二叉树，题目中的给出的是二叉树的层序遍历的结果，我们用<code>INT_MAX</code>代替null，使用如下函数构造二叉树</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">ConstructBinTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">nodes</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">INT_MAX</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">root</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">iq</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">id</span><span class="o">++</span><span class="p">];</span>
    <span class="n">iq</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">iq</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="n">nodes</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">TreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">iq</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">iq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

        <span class="c1">// check vectors for left node
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INT_MAX</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">leftNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">;</span>
            <span class="n">leftNode</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">leftNode</span><span class="p">;</span>
            <span class="n">iq</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">leftNode</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">id</span><span class="o">++</span><span class="p">;</span>
		
        <span class="c1">// add right node
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INT_MAX</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">rightNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">;</span>
            <span class="n">rightNode</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">rightNode</span><span class="p">;</span>
            <span class="n">iq</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">rightNode</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">id</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>下面是中序遍历二叉树</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">ScanBinMiddle</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">tree</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tree</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// handle value
</span><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ScanBinMiddle</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ScanBinMiddle</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="递归解法">递归解法</h3>
<p>二叉树的比较普遍的解法是使用递归，我们需要找出递归的关系式，然后用程序写出来。递归解决问题的思路包括下面两点</p>
<h4 id="描述变量">描述变量</h4>
<p>我们有一个关于目标变量的描述，在这个题目中目标变量是整棵树的最大深度，放弃整体的概念，假设你站在根节点往下看，会看到它有左右两个子树，每棵树又有自己的节点和深度。所以假定推导的变量是</p>
<blockquote>
<p><code>maxdepth[node]</code>表示以<code>node</code>为根节点的树的最大深度</p>
</blockquote>
<h4 id="递归关系式">递归关系式</h4>
<p>查看这个值和左右子树的关系是什么？3这个node的最大深度是9这个node最大深度和20这个node的最大深度的最大值 + 1，重新表述下就是下面的关系式<code>maxD[node] = max(maxD[node-&gt;left], maxD[node-&gt;right]) + 1</code>。</p>
<h4 id="终止条件">终止条件</h4>
<p>终止条件比较简单，在访问到null节点的时候返回0即可，因为以这个节点为根的树是不存在的，所以深度为0。于是有下面的代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> 
<span class="p">{</span>	
    <span class="c1">// 终止条件
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
	<span class="c1">// 关系式
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">),</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="广度优先搜索算法bfs">广度优先搜索算法（BFS）</h3>
<p>不使用递归，还有另一种解法，一层层观察整棵树，第一层1个节点，第二层2个节点，第三层2个节点。每一层的节点之间使用左右子树联系起来，所以根据第1层的节点可以访问第2层的节点，根据第2层的节点可以访问第3层的节点，所以可以这么做。记录整棵树最深的深度是<code>maxdepth = 0</code>，</p>
<ol>
<li>访问第一层的根节点，如果非空则<code>maxdepth++</code>，否则返回；</li>
<li>查看第一层的根节点是否有左右子树，有的话再分别访问左子树和右子树，<code>maxdepth++</code>；</li>
<li>循环步骤2，直到所有的节点都被访问到。</li>
</ol>
<p>这里可以使用<strong>队列</strong>保存需要被访问的节点，如下图所示，分别在头和尾弹出和插入节点，</p>
<p></p>
<p>结合上面的步骤，<code>depth = 1</code>，将root的根节点添加到队列结尾</p>
<ol>
<li>我们一次将一层的节点放入到队列中；</li>
<li>判断当前队列是否为空。
<ul>
<li>如果当前的队列不为空，那么将队列中的每个节点pop出来之后再考察这个节点的左右子树，如果有就将它们插入到队列的尾巴，<code>depth++</code>；</li>
<li>如果当前队列为空，return</li>
</ul>
</li>
</ol>
<p>所以有了下面的代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="c1">// 如果为空，那么返回0
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">qu</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// 添加根节点
</span><span class="c1"></span>    <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">qu</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">qz</span> <span class="o">=</span> <span class="n">qu</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">qz</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 考察队列中的每个节点，是否有左子树和右子树
</span><span class="c1"></span>            <span class="n">TreeNode</span> <span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">qu</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">qu</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="c1">// 如果有左右子节点，那么添加到队列中
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">depth</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">depth</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>下图是资料3中的图示过程，简单明了。</p>
<p></p>
<h2 id="数据结构">数据结构</h2>
<h3 id="队列">队列</h3>
<p>使用<strong>队列</strong>保存每一层的节点，如下图所示，队列是先进先出的数据结构，包括如下的属性和方法</p>
<p></p>
<ul>
<li>队列头（front），表示队列最开始的元素；</li>
<li>队列尾（rear），表示队列最后加入的元素；</li>
<li>队列长度，当前的队列长度，就是rear - front + 1；</li>
<li>出队（pop），队列头弹出，队列长度-1，front++；</li>
<li>入队（push），队列尾添加元素，队列长度+1，rear++</li>
</ul>
<h3 id="stl中的queue">STL中的queue</h3>
<p>C++的stl使用queue表示队列，常用的操作和属性如下表所示</p>
<ul>
<li><code>front()</code>：返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</li>
<li><code>back()</code>：返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</li>
<li><code>push(const T&amp; obj)</code>：在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。</li>
<li><code>push(T&amp;&amp; obj)</code>：以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。</li>
<li><code>pop()</code>：删除 queue 中的第一个元素。</li>
<li><code>size()</code>：返回 queue 中元素的个数。</li>
<li><code>empty()</code>：如果 queue 中没有元素的话，返回 true。</li>
<li><code>emplace()</code>：用传给 emplace() 的参数调用 T 的构造函数，在 queue 的尾部生成对象。</li>
<li><code>swap(queue&lt;T&gt; &amp;other_q)</code>：将当前 queue 中的元素和参数 queue 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。</li>
</ul>
<p>典型的使用方法如下，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// CPP program to illustrate 
</span><span class="c1">// Application of push() and pop() function 
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt; </span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;queue&gt; </span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span> 

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span> 
	<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
	<span class="c1">// Empty Queue 
</span><span class="c1"></span>	<span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myqueue</span><span class="p">;</span> 
	<span class="n">myqueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> 
	<span class="n">myqueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">13</span><span class="p">);</span> 
	<span class="n">myqueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> 
	<span class="n">myqueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span> 
	<span class="n">myqueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> 
	<span class="c1">// queue becomes 5, 13, 0, 9, 4 
</span><span class="c1"></span>
	<span class="c1">// Counting number of elements in queue 
</span><span class="c1"></span>	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">myqueue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span> 
		<span class="n">myqueue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span> 
		<span class="n">c</span><span class="o">++</span><span class="p">;</span> 
	<span class="p">}</span> 
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">;</span> 
<span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><h2 id="典型题目">典型题目</h2>
<h3 id="二叉树的右视图">二叉树的右视图</h3>
<p>题目链接见<a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener noreffer">199. 二叉树的右视图 - 力扣（LeetCode）</a>，如果有了上面题目的框架，这个题目其实很简单，既然每次遍历队列保存的<strong>这一层所有节点</strong>，而且节点的顺序是从左到右保存的，所以可以在每一层遍历的时候将队列的最后一个node加入到这个vector中，代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rightSideView</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rlt</span><span class="p">;</span>
    <span class="c1">// empty rlt for empty tree
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">rlt</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">qu</span><span class="p">;</span>
    <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">qu</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">qz</span> <span class="o">=</span> <span class="n">qu</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="c1">// add the last node in the current queue
</span><span class="c1"></span>        <span class="n">rlt</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">qu</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="c1">// add nodes of next layer into the queue
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">qz</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">TreeNode</span> <span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">qu</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">qu</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">rlt</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="二叉树中所有距离为-k-的结点">二叉树中所有距离为 K 的结点</h3>
<p>题目见<a href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/" target="_blank" rel="noopener noreffer">863. 二叉树中所有距离为 K 的结点 - 力扣（LeetCode）</a>，这道题稍微有点复杂，观察给出的例子（如下图），与5的节点距离为2的节点除了4和7之外还有1，如果仅仅给出4和7是比较简单的，只要以5为根节点，记录depth = 1，套用引子中的程序，将depth = K + 1的所有的节点列出来即可。</p>
<p></p>
<p>但是往上回溯比较难，换一个思路，我们遍历整个二叉树，</p>
<ol>
<li>记录每个节点的<code>father</code>节点，<code>left</code>节点和<code>right</code>节点，将二叉树变成图，表示A与这3个节点的任意一个都是连通的；</li>
<li>初始化目标节点的<code>depth = 1</code>，以该节点为圆心，遍历所有的节点，打印出来所有<code>depth = K + 1</code>的节点</li>
</ol>
<p>第2步实际上是对BFS算法的升维，将二叉树转换为图，代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">distanceK</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">umap</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rlt</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="o">||</span> <span class="n">target</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">rlt</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/************ PART 1 ************/</span>
    <span class="c1">// find the father node of all the nodes in the tree
</span><span class="c1"></span>    <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">qu</span><span class="p">;</span>
    <span class="n">umap</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">qu</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">qz</span> <span class="o">=</span> <span class="n">qu</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">qz</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">qu</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">qu</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="c1">// father node
</span><span class="c1"></span>                <span class="n">umap</span><span class="p">[</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
                <span class="c1">// father node
</span><span class="c1"></span>                <span class="n">umap</span><span class="p">[</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/************ PART 2 ************/</span>
    <span class="c1">// find the node with depth of K
</span><span class="c1"></span>    <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">newQ</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">usedmap</span><span class="p">;</span>
    <span class="n">usedmap</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">newQ</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">newQ</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">depth</span> <span class="o">&lt;=</span> <span class="n">K</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">qz</span> <span class="o">=</span> <span class="n">newQ</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">qz</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">newQ</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">usedmap</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">newQ</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="n">K</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">rlt</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">usedmap</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">newQ</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">usedmap</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">newQ</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">umap</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">usedmap</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">umap</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">newQ</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">umap</span><span class="p">[</span><span class="n">node</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">depth</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//BFS for final rlt
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">rlt</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个程序分为前后两大部分，</p>
<ol>
<li>第一部分遍历二叉树的每一个节点，记录每个节点的父节点，这里我们使用了哈希表来保存每个节点和它的父节点；</li>
<li>第二部分就是核心代码，以target为圆心，将二叉树当作图来遍历，如果这个node有左右节点或者父节点，则表示它跟其他的节点之间联通，则使用BFS算法访问整个图网络。这里尤其要注意，遍<strong>历图需要标记当前图中的节点是否被访问过</strong>，否则会被多次重复遍历而陷入到死循环中，在这个程序里面，使用<code>usedmap</code>来做这件事，其实也可以使用<code>vector&lt;TreeNode *&gt;</code>来记录。</li>
</ol>
<p>为了方便调试，再补一个寻找target node的程序</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">TreeNode</span> <span class="o">*</span><span class="nf">FindTargetNode</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">targetVal</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">qu</span><span class="p">;</span>
    <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">qu</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">qz</span> <span class="o">=</span> <span class="n">qu</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">qz</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">qu</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">qu</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">targetVal</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="颜色交替的最短路径">颜色交替的最短路径</h3>
<p>题目见<a href="https://leetcode-cn.com/problems/shortest-path-with-alternating-colors/" target="_blank" rel="noopener noreffer">1129. 颜色交替的最短路径 - 力扣（LeetCode）</a>，这道题难度要大一点，但是后面的方法仍然是BFS，代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="k">enum</span> <span class="nc">color</span> <span class="p">{</span><span class="n">RED</span><span class="p">,</span> <span class="n">BLUE</span><span class="p">};</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">shortestAlternatingPaths</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">red_edges</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">blue_edges</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// 由于存在自环或者平行边，所以定义哈希表保存每个结点对应的多条边并初始化
</span><span class="c1"></span>        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">redGraph</span><span class="p">;</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">blueGraph</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">red</span> <span class="p">:</span> <span class="n">red_edges</span><span class="p">)</span> <span class="n">redGraph</span><span class="p">[</span><span class="n">red</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="n">push_back</span><span class="p">(</span><span class="n">red</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">blue</span> <span class="p">:</span> <span class="n">blue_edges</span><span class="p">)</span> <span class="n">blueGraph</span><span class="p">[</span><span class="n">blue</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="n">push_back</span><span class="p">(</span><span class="n">blue</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

        <span class="k">const</span> <span class="kt">int</span> <span class="n">colorNum</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">maxNode</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

        <span class="c1">// 由于存在环和平行边，用数组 visit[x][y][color]=true 代表从节点x到节点y的且颜色为color的边被访问过，防止重复访问
</span><span class="c1"></span>        <span class="c1">// 第三维[2]有两维，第0维代表红色是否访问，第1维代表蓝色是否访问
</span><span class="c1"></span>        <span class="c1">// 所有的点初始化为0代表为被访问过
</span><span class="c1"></span>        <span class="kt">bool</span> <span class="n">visited</span><span class="p">[</span><span class="n">maxNode</span><span class="p">][</span><span class="n">maxNode</span><span class="p">][</span><span class="n">colorNum</span><span class="p">];</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">visited</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">visited</span><span class="p">));</span>

        <span class="c1">// step用于记录当前的步长，即从节点0到各节点的步长，从0逐渐+1自增
</span><span class="c1"></span>        <span class="c1">// res代表节点 0 到节点 X 的最短路径的长度，初始化为最大值
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>

        <span class="c1">// 定义队列进行BFS，并进行初始化，pair&lt;int, int&gt;的意思是 &lt;当前节点, 路径上颜色&gt;
</span><span class="c1"></span>        <span class="c1">// 队列初始化先进&lt;0, 1&gt;, 再进&lt;0, 0&gt;，即我们先访问蓝色，再访问红色。
</span><span class="c1"></span>        <span class="n">queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">color</span><span class="o">&gt;&gt;</span> <span class="n">myQue</span><span class="p">;</span> <span class="c1">// &lt;node, color&gt; means start from node and select the edge with color
</span><span class="c1"></span>        <span class="n">myQue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">BLUE</span><span class="p">));</span>
        <span class="n">myQue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">RED</span><span class="p">));</span>

        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">myQue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">myQue</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
            <span class="o">++</span><span class="n">step</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// 队首元素出队列，得到其节点，以及颜色
</span><span class="c1"></span>                <span class="kt">int</span> <span class="n">curNode</span> <span class="o">=</span> <span class="n">myQue</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">first</span><span class="p">;</span>
                <span class="kt">int</span> <span class="n">curColor</span> <span class="o">=</span> <span class="n">myQue</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">second</span><span class="p">;</span>
                <span class="n">myQue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

                <span class="c1">//若当前已访问的为蓝色边，希望下一个节点的边是红色；反之亦然
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">curColor</span> <span class="o">==</span> <span class="n">BLUE</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="c1">// 遍历当前节点每一个相邻的节点，寻找相连的红色边
</span><span class="c1"></span>                    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">nextNode</span> <span class="p">:</span> <span class="n">blueGraph</span><span class="p">[</span><span class="n">curNode</span><span class="p">])</span>
                    <span class="p">{</span>
                        <span class="c1">// 如果 curNode 和 nextNode 相连的红色边未被访问过，访问并加入队列
</span><span class="c1"></span>                        <span class="c1">// 同时需要更新两点之间的最短路径
</span><span class="c1"></span>                        <span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">curNode</span><span class="p">][</span><span class="n">nextNode</span><span class="p">][</span><span class="n">RED</span><span class="p">]</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="n">res</span><span class="p">[</span><span class="n">nextNode</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">nextNode</span><span class="p">],</span> <span class="n">step</span><span class="p">);</span>

                            <span class="c1">// make_pair&lt;nextNode, 0&gt; 的含义是标记当前访问的边为红色，下次应该访问蓝色的
</span><span class="c1"></span>                            <span class="n">myQue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">nextNode</span><span class="p">,</span> <span class="n">RED</span><span class="p">));</span>
                            <span class="n">visited</span><span class="p">[</span><span class="n">curNode</span><span class="p">][</span><span class="n">nextNode</span><span class="p">][</span><span class="n">RED</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">curColor</span> <span class="o">==</span> <span class="n">RED</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="c1">// 遍历当前节点每一个相邻的节点，寻找相连的蓝色边
</span><span class="c1"></span>                    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">nextNode</span> <span class="p">:</span> <span class="n">redGraph</span><span class="p">[</span><span class="n">curNode</span><span class="p">])</span>
                    <span class="p">{</span>
                        <span class="c1">// 如果 curNode 和 nextNode 相连的蓝色边未被访问过，访问并加入队列
</span><span class="c1"></span>                        <span class="c1">// 同时需要更新两点之间的最短路径
</span><span class="c1"></span>                        <span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">curNode</span><span class="p">][</span><span class="n">nextNode</span><span class="p">][</span><span class="n">BLUE</span><span class="p">]</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="n">res</span><span class="p">[</span><span class="n">nextNode</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">nextNode</span><span class="p">],</span> <span class="n">step</span><span class="p">);</span>

                            <span class="c1">// make_pair&lt;nextNode, 1&gt; 的含义是标记当前访问的边为蓝色，下次应该访问红色的
</span><span class="c1"></span>                            <span class="n">myQue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">nextNode</span><span class="p">,</span> <span class="n">BLUE</span><span class="p">));</span>
                            <span class="n">visited</span><span class="p">[</span><span class="n">curNode</span><span class="p">][</span><span class="n">nextNode</span><span class="p">][</span><span class="n">BLUE</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 根据题意，0 到自身的距离为0；在上述操作后，若 0 到其他节点距离仍为INT_MAX，说明不存在符合要求的路径，设置为-1；
</span><span class="c1"></span>        <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">INT_MAX</span><span class="p">)</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>

    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>从代码可以看出，</p>
<ol>
<li>使用<code>blueGraph/redGraph</code>保存图中的节点，数据结构是哈希 +  vector，哈希的键是节点，值是和该节点直接相连的其他节点；</li>
<li>使用<code>visited</code>三维数组标识节点是否被访问过的信息；</li>
<li>使用队列<code>myQueue</code>保存BFS中的node，这个队列中的元素是<code>&lt;node, expectColor&gt;</code>，即从<code>node</code>出发，从<code>node</code>起始的边的颜色，如果存在这样的边，那么将这条边的终点node和它的下一条不同颜色的边push进队列，循环往复直到所有的边都被访问到为止。</li>
</ol>
<h3 id="接雨水-ii">接雨水 II</h3>
<p>题目见<a href="https://leetcode-cn.com/problems/trapping-rain-water-ii/" target="_blank" rel="noopener noreffer">407. 接雨水 II - 力扣（LeetCode）</a>，「待补充」。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.wikiwand.com/zh-hans/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2" target="_blank" rel="noopener noreffer">深度优先搜索 - Wikiwand</a>，维基百科介绍</li>
<li><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/bfs-kuang-jia" target="_blank" rel="noopener noreffer">BFS 算法解题套路框架 - labuladong的算法小抄</a>，非常直观富有启发性的介绍文章</li>
<li><a href="https://www.cnblogs.com/python27/archive/2011/12/09/2282486.html" target="_blank" rel="noopener noreffer">【算法16】递归算法的时间复杂度终结篇 - python27 - 博客园</a>，如何评价递归算法的复杂度</li>
<li><a href="https://developer.aliyun.com/article/756316" target="_blank" rel="noopener noreffer">图文详解 DFS 和 BFS | 算法必看系列知识二十四-阿里云开发者社区</a>，图解DFS和BFS的过程</li>
</ul>]]></description>
</item><item>
    <title>滑动窗口技巧</title>
    <link>https://bugxch.github.io/slidingwindow/</link>
    <pubDate>Sun, 02 Aug 2020 15:40:45 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://bugxch.github.io/slidingwindow/</guid>
    <description><![CDATA[<p>今天主要刷leetcode的滑动窗口的题目，需要完成如下题目，本文主要记录解题思路和方法，以便加深理解记忆，答案到处都是，只有消化了才是自己的。</p>
<p></p>
<h2 id="引子">引子</h2>
<p>首先来看leetcode中No. 3的<strong>无重复字符的最长子串</strong>这个题目，参考<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener noreffer">题目链接</a>，题目很简单</p>
<blockquote>
<p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">输入: <span class="s2">&#34;abcabcbb&#34;</span>
输出: <span class="m">3</span> 
解释: 因为无重复字符的最长子串是 <span class="s2">&#34;abc&#34;</span>，所以其长度为 3。
</code></pre></td></tr></table>
</div>
</div><p>拿到题目的第一反应就是暴力解法，</p>
<ol>
<li>
<p>先暴力穷举所有的子串$S_i = [S[left], S[right])$；</p>
</li>
<li>
<p>判断这个子串，如果不含重复字符就记录子串长度$l_i$，此处判断是否有重复字串的时间复杂度是$O(n)$；</p>
</li>
<li>
<p>找出所有记录的子串长度的最大值$max_i{l_i}$。
一段伪代码如下，</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="n">maxlen</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">S</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">left</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">S</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">right</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if</span><span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="n">contain</span> <span class="err">重复字符</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
     <span class="k">if</span><span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">maxlen</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">maxlen</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span><span class="n">left</span><span class="p">;</span>
     <span class="p">}</span>
    <span class="p">}</span>
<span class="k">return</span> <span class="n">maxlen</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>很明显，该方法的时间复杂度是$O(n^3)$，非常费时。这个算法的复杂度主要来自于第一步，仔细想想那个子串伪代码中的第3行有点问题，伪代码可以看作我们用一个窗口截取所有子串，left表示窗口的左边界（包含），right表示窗口的右边界（不包含），如果窗口中含有重复子串，那么不应该继续扩展右边界的，所以right不能一直向右<strong>扩展</strong>，此时应该向右移动左边界，<strong>缩小</strong>窗口的长度。以示例中给出的字符串为例，参考下面的示意图</p>
<p></p>
<p>所以我们有一个更通用的实现框架。</p>
<h2 id="通用框架">通用框架</h2>
<p>维护一个<strong>滑动窗口</strong>，</p>
<blockquote>
<ol>
<li>窗口的边界是$[left, right)$，刚开始窗口的长度为0，即left = right = 0；</li>
<li>维护一个哈希表table，用于记录窗口中的字符的统计情况，比如上面的图一中就<code>table['a'] = 2, table['b'] = 1, table['c'] = 1</code>；</li>
<li>窗口可<strong>扩展</strong>可<strong>收缩</strong>，</li>
</ol>
<ul>
<li>如果当前窗口中没有重复字符，则窗口扩展，<code>right++</code>，更新哈希表；</li>
<li>如果当前窗口中有重复字符，那么窗口收缩，<code>left++</code>，更新哈希表；</li>
</ul>
<ol start="4">
<li>直到<code>right</code>超过需要遍历的字符串的边界为止。</li>
</ol>
</blockquote>
<p>需要注意，上面的扩展和收缩的时机，对于当前的这个程序，如何判断当前的窗口中是否有重复字符呢？一般的想法是遍历每个键的值，如果有大于1的值就认为有重复字符，而且是在窗口位置发生变化的时候触发遍历动作。其实，这里有一个小技巧，<strong>键值只有在向右扩展的时候才会增长</strong>，刚开始窗口是没有键的，或者即便有也只能是1，所以在窗口扩展的时候，只要去查看新加入的<code>right</code>位置的字符的键值是否超过1即可。通过以上分析，我们有了下面的新的伪代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">maxlen</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="k">while</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// 增大窗口
</span><span class="c1"></span>    <span class="n">window</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">]);</span>
    <span class="n">right</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">window</span> <span class="n">doesnot</span> <span class="n">contain</span> <span class="n">repeat</span> <span class="n">charactor</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">maxlen</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxlen</span><span class="p">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">window</span> <span class="n">needs</span> <span class="n">shrink</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 缩小窗口
</span><span class="c1"></span>        <span class="n">window</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]);</span>
        <span class="n">left</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">maxlen</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>将上面的伪代码翻译成最后的c++代码，列示如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">maxlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">window</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">rch</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
        <span class="n">right</span><span class="o">++</span><span class="p">;</span>
        <span class="n">window</span><span class="p">[</span><span class="n">rch</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="n">rch</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">maxlen</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxlen</span><span class="p">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="n">rch</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">auto</span> <span class="n">lch</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
                <span class="n">left</span><span class="o">++</span><span class="p">;</span>
                <span class="n">window</span><span class="p">[</span><span class="n">lch</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">maxlen</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="类似题目">类似题目</h2>
<p>下面使用上面的框架解答一下其他的滑动窗口的类似题目</p>
<h3 id="最小覆盖子串---力扣leetcode">最小覆盖子串 - 力扣（LeetCode）</h3>
<p>题目见<a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener noreffer">76. 最小覆盖子串 - 力扣（LeetCode）</a>：给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p>
<p>示例：</p>
<blockquote>
<p><strong>输入:</strong> S = &ldquo;ADOBECODEBANC&rdquo;, T = &ldquo;ABC&rdquo;
<strong>输出:</strong> &ldquo;BANC&rdquo;</p>
</blockquote>
<p>也是同样的做法，但是需要搞清楚几个问题</p>
<h4 id="何时扩展窗口">何时扩展窗口？</h4>
<p>如果窗口中没有将所有的T中的字符包含，那么向右扩展窗口。</p>
<h4 id="何时更新长度">何时更新长度？</h4>
<p>扩展窗口之后，检查窗口的字符集合。如果当前窗口包含了所有的T中的字符，那么更新子串的起始位置id及长度。</p>
<h4 id="何时缩减窗口">何时缩减窗口？</h4>
<p>更新长度之后，窗口的左端右移，缩减窗口。于是有了下面的代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// No. 76
</span><span class="c1"></span><span class="n">string</span> <span class="nf">minWindow</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">string</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">startId</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">rightId</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">minLen</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span>  <span class="n">matchCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// record the only need characters
</span><span class="c1"></span>    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">window</span><span class="p">;</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">need</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">ch</span> <span class="p">:</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">need</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">rch</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
        <span class="n">right</span><span class="o">++</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">need</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">rch</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// expand window
</span><span class="c1"></span>            <span class="n">window</span><span class="p">[</span><span class="n">rch</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="n">rch</span><span class="p">]</span> <span class="o">==</span> <span class="n">need</span><span class="p">[</span><span class="n">rch</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">matchCount</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>       

        <span class="c1">// shrink the window
</span><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">matchCount</span> <span class="o">==</span> <span class="n">need</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">minLen</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">startId</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
                <span class="n">rightId</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
                <span class="n">minLen</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">auto</span> <span class="n">lch</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">need</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">lch</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">window</span><span class="p">[</span><span class="n">lch</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="n">lch</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">need</span><span class="p">[</span><span class="n">lch</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">matchCount</span><span class="o">--</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>            
            <span class="n">left</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">rightId</span> <span class="o">-</span> <span class="n">startId</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">startId</span><span class="p">,</span> <span class="n">rightId</span> <span class="o">-</span> <span class="n">startId</span><span class="p">)</span> <span class="o">:</span> <span class="s">&#34;&#34;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的写法中，需要注意几个问题</p>
<ol>
<li><code>window</code>仅仅记录了<code>[left, right)</code>的子串中的出现在need窗口中的字符的情况，并没有对窗口中所有的字符都做统计，其实也没有必要做，因为我们并不关心其他的字符；</li>
<li><code>minLen</code>用来记录最短的子串长度，刚开始初始化为字符串的长度+1；</li>
<li>我们用<code>matchCount</code>标记匹配的字符的个数，如果匹配了一个字符就加一，否则减一，匹配的标准是该字符的出现次数在window中<strong>不少于</strong>在need中出现的次数。注意，这个<strong>参数在扩展窗口时增加，在缩减窗口时减少</strong>，增加或减少之后即刻与need比较判断。</li>
</ol>
<h3 id="424-替换后的最长重复字符">424. 替换后的最长重复字符</h3>
<p>题目见<a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/" target="_blank" rel="noopener noreffer">424. 替换后的最长重复字符 - 力扣（LeetCode）</a>，题目也比较简单，维护滑动窗口，每次在扩展窗口时候检查当前的窗口中的最多的字符的个数与替换的数量k的和是否大于等于窗口的长度？</p>
<ol>
<li>如果是，则更新窗口的长度，窗口继续扩展；</li>
<li>如果否，则缩减窗口的长度；</li>
</ol>
<p>循环往复，直到窗口的右边界超过了字符串的长度。代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">characterReplacement</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">window</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">rch</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
            <span class="n">window</span><span class="p">[</span><span class="n">rch</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
            <span class="n">right</span><span class="o">++</span><span class="p">;</span>

            <span class="c1">// find max count char
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">maxCount</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">window</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">window</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">iter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">maxCount</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxCount</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">maxCount</span> <span class="o">+</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">maxLen</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">,</span> <span class="n">maxLen</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">lch</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
                <span class="n">window</span><span class="p">[</span><span class="n">lch</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
                <span class="n">left</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">maxLen</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="1004-最大连续1的个数-iii">1004. 最大连续1的个数 III</h3>
<p>题目见<a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/" target="_blank" rel="noopener noreffer">1004. 最大连续1的个数 III - 力扣（LeetCode）</a>，与上一题目类似，直接看代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">longestOnes</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">window</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">rnum</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
            <span class="n">window</span><span class="p">[</span><span class="n">rnum</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
            <span class="n">right</span><span class="o">++</span><span class="p">;</span>
                        
            <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">K</span> <span class="o">&gt;=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">maxLen</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">,</span> <span class="n">maxLen</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">lnum</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
                <span class="n">window</span><span class="p">[</span><span class="n">lnum</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
                <span class="n">left</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">maxLen</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看出这个代码与上一题目非常相似，通用框架都是默认扩展窗口，如果不满足某些条件再缩减窗口。</p>
<h3 id="992-k个不同整数的数组">992. K个不同整数的数组</h3>
<p>题目见<a href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/" target="_blank" rel="noopener noreffer">992. K 个不同整数的子数组 - 力扣（LeetCode）</a>，这个比上面的两道题要复杂点，两次使用双指针解决，基本思路是：</p>
<ol>
<li>维护像之前一样的滑动窗口，如果当前的窗口不满足条件，那么向右扩张；</li>
<li>如果窗口满足条件了，停止向右扩张，右边界不变，左边界向右移动（收缩窗口），开始计算满足条件的窗口数目。注意，这里的动作，在满足条件的窗口上再开一个滑动窗口，但是该窗口的右边界不变，不停右移左边界，遍历满足条件的总数；</li>
<li>如此这般往复循环，直到滑动窗口的右边缘到达字符串的右边界为止。</li>
</ol>
<p>我第一次提交的代码如下，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">subarraysWithKDistinct</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">window</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">rnum</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
            <span class="n">window</span><span class="p">[</span><span class="n">rnum</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
            <span class="n">right</span><span class="o">++</span><span class="p">;</span>
            
			<span class="c1">// 如果当前的窗口中超过了K个不同的整数，那么需要缩小左边缘（即窗口左移）
</span><span class="c1"></span>            <span class="k">while</span> <span class="p">(</span><span class="n">window</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">lnum</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
                <span class="n">window</span><span class="p">[</span><span class="n">lnum</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="n">lnum</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">window</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">lnum</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="n">left</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span> 
            
            <span class="c1">// 当前的窗口有K个不同的整数，移动左边缘，遍历所有满足条件的窗口
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>                
                <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">subWindow</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
                <span class="kt">int</span> <span class="n">tmpLeft</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>

                <span class="k">while</span> <span class="p">(</span><span class="n">subWindow</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">count</span><span class="o">++</span><span class="p">;</span>
                    <span class="n">subWindow</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">tmpLeft</span><span class="p">]]</span><span class="o">--</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">subWindow</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">tmpLeft</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">subWindow</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">tmpLeft</span><span class="p">]);</span>
                    <span class="p">}</span>
                    <span class="n">tmpLeft</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>计算结果正确，但是超时了，仔细想想，其实不需要在创建一个subWindow窗口，可以复用原来的窗口，但是遍历完毕需要记得恢复，适当修改代码如下，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">subarraysWithKDistinct</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">window</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">rnum</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
            <span class="n">window</span><span class="p">[</span><span class="n">rnum</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
            <span class="n">right</span><span class="o">++</span><span class="p">;</span>

            <span class="k">while</span> <span class="p">(</span><span class="n">window</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">lnum</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
                <span class="n">window</span><span class="p">[</span><span class="n">lnum</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="n">lnum</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">window</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">lnum</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="n">left</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span> 
            
             
            <span class="kt">int</span> <span class="n">tmpLeft</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">window</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">count</span><span class="o">++</span><span class="p">;</span>
                <span class="n">window</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">tmpLeft</span><span class="p">]]</span><span class="o">--</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">tmpLeft</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">window</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">tmpLeft</span><span class="p">]);</span>
                <span class="p">}</span>
                <span class="n">tmpLeft</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// recover the window
</span><span class="c1"></span>            <span class="k">while</span> <span class="p">(</span><span class="n">tmpLeft</span> <span class="o">&gt;</span> <span class="n">left</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">window</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">tmpLeft</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>
                <span class="n">tmpLeft</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="数据结构">数据结构</h2>
<h3 id="哈希表">哈希表</h3>
<p>上面的示例都用到了哈希表，又称为散列表，具体的定义可以参考<a href="https://www.wikiwand.com/zh/%E5%93%88%E5%B8%8C%E8%A1%A8" target="_blank" rel="noopener noreffer">哈希表</a>。与一般的顺序访问的数组等数据结构不同，哈希表将查询的数据映射到表中的位置来记录，加快了查询的速度（类似于数组的下表和数组的值的映射关系）。一般而言，哈希表的查询，插入和删除的性能是$O(1)$。</p>
<h3 id="c-stl-中的哈希表">C++ STL 中的哈希表</h3>
<p>C++在stl中使用<code>unordered_map</code>的数据结构保存哈希表，基本的用法如下所示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// C++ program to demonstrate functionality of unordered_map 
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt; </span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;  // </span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span> 

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span> 
	<span class="c1">// Declaring umap to be of &lt;string, int&gt; type 
</span><span class="c1"></span>	<span class="c1">// key will be of string type and mapped value will 
</span><span class="c1"></span>	<span class="c1">// be of double type 
</span><span class="c1"></span>	<span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">umap</span><span class="p">;</span> 

	<span class="c1">// inserting values by using [] operator 
</span><span class="c1"></span>	<span class="n">umap</span><span class="p">[</span><span class="s">&#34;GeeksforGeeks&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> 
	<span class="n">umap</span><span class="p">[</span><span class="s">&#34;Practice&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> 
	<span class="n">umap</span><span class="p">[</span><span class="s">&#34;Contribute&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span> 

	<span class="c1">// Traversing an unordered map 
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">umap</span><span class="p">)</span> 
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 

<span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><p>创建一个哈希表格，在哈希表中添加“键-值”对。</p>
<ul>
<li>
<p><code>unordered_map</code>和<code>unordered_set</code>有什么区别？</p>
<p><code>unordered_set</code>中只保存了键，主要用于查看某元素是否在集合中，不能保存每个键出现的次数。</p>
</li>
<li>
<p><code>unordered_map</code>和<code>map</code>有什么区别？</p>
<ol>
<li>
<p><code>map</code>中的键值是按序保存的，但是<code>unorederd_map</code>的键值是无序保存的；</p>
</li>
<li>
<p>二者底层实现的数据结构不同，<code>map</code>使用的是<a href="https://zh.wikipedia.org/zh-my/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="noopener noreffer">红黑树</a>，操作性能分别是$O(logn)$和$O(1)$</p>
</li>
</ol>
</li>
</ul>
<p>常见的操作如下面的代码所示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// C++ program to demonstrate functionality of unordered_map 
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt; </span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt; </span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span> 

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Declaring umap to be of &lt;string, double&gt; type 
</span><span class="c1"></span>    <span class="c1">// key will be of string type and mapped value will 
</span><span class="c1"></span>    <span class="c1">// be of double type 
</span><span class="c1"></span>    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">umap</span><span class="p">;</span>

    <span class="c1">// 新增键值对
</span><span class="c1"></span>    <span class="n">umap</span><span class="p">[</span><span class="s">&#34;PI&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
    <span class="n">umap</span><span class="p">[</span><span class="s">&#34;root2&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.414</span><span class="p">;</span>
    <span class="n">umap</span><span class="p">[</span><span class="s">&#34;root3&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.732</span><span class="p">;</span>
    <span class="n">umap</span><span class="p">[</span><span class="s">&#34;log10&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.302</span><span class="p">;</span>
    <span class="n">umap</span><span class="p">[</span><span class="s">&#34;loge&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>

    <span class="c1">// 插入键值对，可以使用c++的make_pair函数
</span><span class="c1"></span>    <span class="n">umap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&#34;e&#34;</span><span class="p">,</span> <span class="mf">2.718</span><span class="p">));</span>

    <span class="n">string</span> <span class="n">key</span> <span class="o">=</span> <span class="s">&#34;PI&#34;</span><span class="p">;</span>

    <span class="c1">// 查询方法一
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">umap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">umap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">key</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; not found</span><span class="se">\n\n</span><span class="s">&#34;</span><span class="p">;</span>

    <span class="c1">// If key found then iterator to that key is returned 
</span><span class="c1"></span>    <span class="k">else</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Found &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">key</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n\n</span><span class="s">&#34;</span><span class="p">;</span>

    <span class="c1">// 查询方法二 
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">umap</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">key</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; not found</span><span class="se">\n\n</span><span class="s">&#34;</span><span class="p">;</span>

    <span class="c1">// If key found then iterator to that key is returned 
</span><span class="c1"></span>    <span class="k">else</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Found &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">key</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n\n</span><span class="s">&#34;</span><span class="p">;</span>

    <span class="c1">// 遍历方法一
</span><span class="c1"></span>    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">itr</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">All Elements : </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">itr</span> <span class="o">=</span> <span class="n">umap</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">itr</span> <span class="o">!=</span> <span class="n">umap</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">itr</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// itr works as a pointer to pair&lt;string, double&gt; 
</span><span class="c1"></span>        <span class="c1">// type itr-&gt;first stores the key part and 
</span><span class="c1"></span>        <span class="c1">// itr-&gt;second stroes the value part 
</span><span class="c1"></span>        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">itr</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">itr</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 遍历方法二
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">iter</span> <span class="p">:</span> <span class="n">umap</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">iter</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">iter</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>需要格外注意，除了上面的<code>find</code>方法之外，查询某个键是否在哈希表中，还可以通过如下代码查询某个键值<code>key</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">if</span> <span class="p">(</span><span class="n">umap</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">key</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; is found</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Not found</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果哈希表中没有这个键值，<strong>那么它会自动添加进去，并赋给它初值</strong>，所以在查询某个键是否存在时，不要用这样的方法。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hua-dong-chuang-kou-ji-qiao-jin-jie" target="_blank" rel="noopener noreffer">我写了首诗，把滑动窗口算法算法变成了默写题 - labuladong的算法小抄</a>，非常通俗易懂的算法说明，基本上按照这个顺序来刷题的</li>
<li><a href="https://www.geeksforgeeks.org/unordered_map-in-cpp-stl/" target="_blank" rel="noopener noreffer">unordered_map in C++ STL - GeeksforGeeks</a>，C++ stl中的unordered_map</li>
<li><a href="https://www.geeksforgeeks.org/hashing-set-1-introduction/" target="_blank" rel="noopener noreffer">Hashing | Set 1 (Introduction) - GeeksforGeeks</a>，哈希表的介绍</li>
</ul>]]></description>
</item><item>
    <title>使用linux vs code调试C&#43;&#43;程序</title>
    <link>https://bugxch.github.io/manjarovscode/</link>
    <pubDate>Sun, 26 Jul 2020 08:12:22 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://bugxch.github.io/manjarovscode/</guid>
    <description><![CDATA[<p>最近练习leetcode编程，我希望在manjaro系统的vs code上可以单步调试C++代码，找了很多资料都不能正常运行，所以参考<a href="https://code.visualstudio.com/docs/cpp/cpp-debug" target="_blank" rel="noopener noreffer">官方资料</a>自己整好了，记录一下。</p>
<h2 id="预置条件">预置条件</h2>
<p>首先完成如下工作</p>
<ol>
<li>
<p>安装vs code;</p>
</li>
<li>
<p>安装插件，如下图所示</p>
<p></p>
</li>
<li>
<p>确认linux系统已经正确安装gcc，输入如下命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">gcc -v <span class="c1"># 查看gcc版本</span>
sudo pacman -S build-essential gdb <span class="c1"># 安装必要工具軟件</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h2 id="创建hello-world工程">创建Hello world工程</h2>
<p>在本地创建目录，我在本地创建了leetcode的目录，所以有如下的步骤</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">mkdir project
<span class="nb">cd</span> project
mkdir 
<span class="nb">cd</span> helloworld
code . <span class="c1"># 在当前目录下打开vs code，当前打开的文件夹就是这个“工作空间”</span>
</code></pre></td></tr></table>
</div>
</div><p>阅读完本博客之后，你会在当前的目录下面创建下面的3个文件</p>
<ul>
<li><code>tasks.json</code> (compiler build settings)</li>
<li><code>launch.json</code> (debugger settings)</li>
</ul>
<h3 id="添加源文件">添加源文件</h3>
<p>如图所示，添加新的源文件<code>helloworld.cpp</code></p>
<p></p>
<p>在该文件中粘贴如下的源代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">msg</span> <span class="p">{</span><span class="s">&#34;Hello&#34;</span><span class="p">,</span> <span class="s">&#34;C++&#34;</span><span class="p">,</span> <span class="s">&#34;World&#34;</span><span class="p">,</span> <span class="s">&#34;from&#34;</span><span class="p">,</span> <span class="s">&#34;VS Code&#34;</span><span class="p">,</span> <span class="s">&#34;and the C++ extension!&#34;</span><span class="p">};</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="nl">word</span> <span class="p">:</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">word</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>然后保存该文件。</p>
<p></p>
<h3 id="构建helloworldcpp">构建helloworld.cpp</h3>
<p>接下来，你将创建一个<code>task.json</code>文件告诉VS code如何构建(编译)当前的程序。这将触发g++编译器按照源代码创建一个可执行程序。在主菜单选择<strong>终端-&gt;配置默认生成任务</strong>，然后在下拉菜单选择g++ build active file，如下图所示</p>
<p></p>
<p>你将在<code>.vscode</code>文件夹下面看到<code>tasks.json</code>文件，我们进一步编辑这个文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
	<span class="nt">&#34;version&#34;</span><span class="p">:</span> <span class="s2">&#34;2.0.0&#34;</span><span class="p">,</span>
	<span class="nt">&#34;tasks&#34;</span><span class="p">:</span> <span class="p">[</span>
		<span class="p">{</span>
			<span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;shell&#34;</span><span class="p">,</span>
			<span class="nt">&#34;label&#34;</span><span class="p">:</span> <span class="s2">&#34;C/C++: g++ build active file&#34;</span><span class="p">,</span>
			<span class="nt">&#34;command&#34;</span><span class="p">:</span> <span class="s2">&#34;/usr/bin/g++&#34;</span><span class="p">,</span>
			<span class="nt">&#34;args&#34;</span><span class="p">:</span> <span class="p">[</span>
				<span class="s2">&#34;-g&#34;</span><span class="p">,</span>
				<span class="s2">&#34;${file}&#34;</span><span class="p">,</span>
				<span class="s2">&#34;-o&#34;</span><span class="p">,</span>
				<span class="s2">&#34;${fileDirname}/${fileBasenameNoExtension}&#34;</span>
			<span class="p">],</span>
			<span class="nt">&#34;options&#34;</span><span class="p">:</span> <span class="p">{</span>
				<span class="nt">&#34;cwd&#34;</span><span class="p">:</span> <span class="s2">&#34;${workspaceFolder}&#34;</span>
			<span class="p">},</span>
			<span class="nt">&#34;problemMatcher&#34;</span><span class="p">:</span> <span class="p">[</span>
				<span class="s2">&#34;$gcc&#34;</span>
			<span class="p">],</span>
			<span class="nt">&#34;group&#34;</span><span class="p">:</span> <span class="p">{</span>
				<span class="nt">&#34;kind&#34;</span><span class="p">:</span> <span class="s2">&#34;build&#34;</span><span class="p">,</span>
				<span class="nt">&#34;isDefault&#34;</span><span class="p">:</span> <span class="kc">true</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>关于json文件中变量的具体含义可以进一步参考<a href="https://code.visualstudio.com/docs/editor/variables-reference" target="_blank" rel="noopener noreffer">Visual Studio Code Variables Reference</a></p>
</blockquote>
<p>文件中的指令指定了程序如何运行，当前文件中的<code>args</code>参数指定了传输给gcc的参数，这些参数必须按照编译器期望的顺序排列。</p>
<p>这个任务告诉g++将源文件<code>${file}</code>编译，在当前文件夹下面创建可执行文件<code>helloword</code>，注意可执行文件的名称和源文件相同，但是去掉了扩展后缀名。<code>label</code>字段表示你能看到的任务列表，你可以写成任何你想写的东西。<code>group</code>中的<code>&quot;isDefault&quot;: true</code>表示你可以使用<code>Ctrl+Shift+B</code>运行该任务，这个仅仅是为了使用上的方便，你依然可以通过菜单中的选项运行该任务。</p>
<h3 id="运行编译程序">运行编译程序</h3>
<p>回到原来的<code>helloworld.cpp</code>程序，按下<code>Ctrl+Shift+B</code>运行该任务，请留意编辑器下方的终端的打印，在任务运行结束之后一般会提示成功或者失败，如果运行顺利，你可以看到如下的提示</p>
<p></p>
<p>如果留意可以看到当前的文件夹中已经生成了可执行程序<code>helloworld</code>文件，打开新的终端，即可运行该程序</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">./helloworld <span class="c1"># 运行可执行程序</span>
</code></pre></td></tr></table>
</div>
</div><p></p>
<h3 id="修改tasksjson">修改tasks.json</h3>
<p>你可以修改这个文件中的参数，比如将<code>${workspaceFolder}/*.cpp</code>替换<code>${file}</code>，或者也可以将<code>${fileDirname}/${fileBasenameNoExtension}</code>替换成一个硬编码的程序名称<code>helloworld.out</code>。</p>
<h3 id="调试源程序">调试源程序</h3>
<p>接下来你将创建<code>launch.json</code>文件，当按下<code>F5</code>的时候VS Code调用GDB的调试器用于调试程序。找到菜单中的<strong>运行 &gt; 添加配置</strong>，然后选择<strong>C++ (GDB/LLDB)</strong>，如下图所示</p>
<p></p>
<p>我们选择<strong>g++ build and debug active file</strong>，你可以看到此处VS Code自动创建了文件<code>launch.json</code>文件，文件的内容如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="err">//</span> <span class="err">使用</span> <span class="err">IntelliSense</span> <span class="err">了解相关属性。</span> 
    <span class="err">//</span> <span class="err">悬停以查看现有属性的描述。</span>
    <span class="err">//</span> <span class="err">欲了解更多信息，请访问:</span> <span class="err">https://go.microsoft.com/fwlink/?linkid=830387</span>
    <span class="nt">&#34;version&#34;</span><span class="p">:</span> <span class="s2">&#34;0.2.0&#34;</span><span class="p">,</span>
    <span class="nt">&#34;configurations&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;g++ - 生成和调试活动文件&#34;</span><span class="p">,</span>
            <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;cppdbg&#34;</span><span class="p">,</span>
            <span class="nt">&#34;request&#34;</span><span class="p">:</span> <span class="s2">&#34;launch&#34;</span><span class="p">,</span>
            <span class="nt">&#34;program&#34;</span><span class="p">:</span> <span class="s2">&#34;${fileDirname}/${fileBasenameNoExtension}&#34;</span><span class="p">,</span>
            <span class="nt">&#34;args&#34;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="nt">&#34;stopAtEntry&#34;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
            <span class="nt">&#34;cwd&#34;</span><span class="p">:</span> <span class="s2">&#34;${workspaceFolder}&#34;</span><span class="p">,</span>
            <span class="nt">&#34;environment&#34;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="nt">&#34;externalConsole&#34;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
            <span class="nt">&#34;MIMode&#34;</span><span class="p">:</span> <span class="s2">&#34;gdb&#34;</span><span class="p">,</span>
            <span class="nt">&#34;setupCommands&#34;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;为 gdb 启用整齐打印&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;text&#34;</span><span class="p">:</span> <span class="s2">&#34;-enable-pretty-printing&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;ignoreFailures&#34;</span><span class="p">:</span> <span class="kc">true</span>
                <span class="p">}</span>
            <span class="p">],</span>
            <span class="nt">&#34;preLaunchTask&#34;</span><span class="p">:</span> <span class="s2">&#34;C/C++: g++ build active file&#34;</span><span class="p">,</span>
            <span class="nt">&#34;miDebuggerPath&#34;</span><span class="p">:</span> <span class="s2">&#34;/usr/bin/gdb&#34;</span>
        <span class="p">}</span>
    <span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>很明显在这个文件中<code>program</code>指定了需要debug的程序，和之前的文件一样，此处就是没有后缀名的与源文件一样的程序，这个例子中就是<code>helloworld</code>。默认情况下，C++插件不会在代码中插入任何断点，所以<code>stopAtEntry</code>是<code>false</code>。如果将该项改为<code>true</code>，那么就可以让调试器停在主函数的断点处。</p>
<h3 id="开始调试">开始调试</h3>
<p>回到源文件，按下<code>F5</code>就可以开始调试了，在代码编辑器的上访可以看到调试的控制条，包括了单步调试，跳过调试，重启调试和停止调试的功能。稍微探索一下就可以发现，<code>F9</code>是添加断点，其他的调试方法鼠标悬停在上面都会显示快捷键，你看到的编辑器应该是这样的</p>
<p></p>
<p>调试中可以看到每个变量的值，以及监视窗口。</p>
<blockquote>
<p>需要注意的是，当前的版本（2019年3月份之后）不会在单步调试模式下将cout的结果打印出来，只有程序运行完成之后才会统一打印出来。</p>
</blockquote>]]></description>
</item><item>
    <title>[转载]用于深入思考的小工具</title>
    <link>https://bugxch.github.io/think/</link>
    <pubDate>Sun, 19 Jul 2020 21:18:11 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://bugxch.github.io/think/</guid>
    <description><![CDATA[<p>为了能够进一步探讨创造力，深度思考，学习，以及AI当中的一些话题，我发现我不得不先写一篇post来引入关于思考的一些工具和运作方式，作为后续posts探讨的基石。这篇文章会基于我在medium上的post进行展开。</p>
<p>为了掌握一项技能，或者深入一个领域，我们首先要从它们的定义开始入手，即知道，它们是什么，意味着什么。同样的，为了具备创造力，我们首先得弄清楚它最基本的含义是什么。</p>
<p>所谓创造，其最基本的一个含义就是能够做出、发展出一些之前没有的东西，重点在于“之前没有”。这里很tricky的一个地方在于，只要是世人看不到的、接触不到的，即可认为是“没有”，而不必是哲学意义上的本来所固有之类的抽象属性。而为了创造出“世人看不到”的东西，你仅仅需要去看到那些其他人看不到的东西就可以了。</p>
<p>这种“看到他人看不到的东西”的技能，叫做“深入思考”。你的思想越有穿透性，你的洞察力越深入，你就越能看到表象之下他人注意不到的事情。并且，这是一个细密并且会随着你认知能力的成长而成长的动态过程：</p>
<p>为了能够进一步探讨创造力，深度思考，学习，以及AI当中的一些话题，我发现我不得不先写一篇post来引入关于思考的一些工具和运作方式，作为后续posts探讨的基石。这篇文章会基于我在medium上的post进行展开。</p>
<p>为了掌握一项技能，或者深入一个领域，我们首先要从它们的定义开始入手，即知道，它们是什么，意味着什么。同样的，为了具备创造力，我们首先得弄清楚它最基本的含义是什么。</p>
<p>所谓创造，其最基本的一个含义就是能够做出、发展出一些之前没有的东西，重点在于“之前没有”。这里很tricky的一个地方在于，只要是世人看不到的、接触不到的，即可认为是“没有”，而不必是哲学意义上的本来所固有之类的抽象属性。而为了创造出“世人看不到”的东西，你仅仅需要去看到那些其他人看不到的东西就可以了。</p>
<p>这种“看到他人看不到的东西”的技能，叫做“深入思考”。你的思想越有穿透性，你的洞察力越深入，你就越能看到表象之下他人注意不到的事情。并且，这是一个细密并且会随着你认知能力的成长而成长的动态过程：</p>
<ul>
<li>你的穿透性越强，你深入的层次就会越深入；</li>
<li>你的视野越开阔，你所深入的方向就会越丰富；</li>
<li>你对你要解决的问题理解得越透彻，你就越能把握深入的程度，知道深入到哪个层次就必须停止，否则就是偏离你的问题。</li>
</ul>
<p>每个人生而具备的能力是不同的，但我们不应该仅仅满足于继承于“天赋”的技能恒定值。正如人类区别于动物的地方在于，我们不会去接受大自然给我们的固有设定选项。我们会通过思考去发明工具，通过工具去开创出我们想要的世界。同样地，我们绝不应该也满足于自然给我们的“天赋”这一默认选项，我们会有意识地，通过练习、通过一些工具去塑造和提高我们想要的技能。</p>
<p>掌握一项技能从来都不是件容易的事情。其第一步，必须要能够排除一些心理成见，让自己能够专注于训练本身。关于“深入思考”，很多人会拒绝去寻找、去接受提高他们思考能力的工具。他们会把这件事看得非常情绪化，非常personal。他们给出的反应是：提高思考的能力？我难道不会思考？你是说我无法掌握我自己的大脑？你是在侮辱我吗？(One direct ruthless answer from psychology to all these questions is yes, except the last one.)我对这些反应的一个看法是，人们非常容易在那些half-mature的技能或事情上得出偏见性的矛盾结论。</p>
<ul>
<li>如果你想去一个很远的地方，比如某个跨过太平洋的国家，你会很容易地接受这样一个事实：你不能够仅仅通过步行去完成这趟旅行。你会很乐意地运用一些工具，比如汽车或飞机去帮助你到达你的目的地。</li>
<li>如果你想去搜索一些信息，你会很容易地接受你不能够仅仅通过自己的双手和眼睛去到处寻找材料。你会很乐意地运用一些工具，比如Google去帮助你寻找你想要的。</li>
</ul>
<p>那你为什么不能接受你需要运用工具才能好地提高你的思考技能的事实呢？人们通常会对那些他们穷尽所有能力都毫无办法的事情表现得客观一些，而对那些他们可以但却不够成熟的事情表现得很情绪化。（这也是为什么你比他人强一点点会引来嫉妒，强大很多会引来羡慕和祝福。）</p>
<p>请抛掉这些无畏的偏见和情绪，让我们集中于提高思考深度的问题上。</p>
<p>在我看来，问题列表(question list)，实践和写作是用于提高思考深度的最小巧并且最有效的工具组合。它们足够轻便，任何人都可以轻而易举地得到它们。但这样的易得性，丝毫没有降低它们在帮助你进入一个新的领域，解决一些复杂性难题时的有效性。恰恰相反，它们的小巧易得性，能够像Unix工具或者瑞士军刀一样，不仅能够为你提供各种行之有效的组合方案，而且还能将其复杂度和可操作性控制在你能接受的范围之内。</p>
<h2 id="问题列表">问题列表</h2>
<p>每一个领域都有独特的思维方式、思考角度和核心思想。在一个领域里的摸爬滚打，能让你学到的最有价值的东西不是这个领域的知识，而是这个领域独有的思维方式和它背后所展现的核心思想。另一方面，所谓进入一个领域，或者说在一个领域里开始入门，指的是你能够真正以这个领域所独有的角度去思考问题，能够用它背后所蕴含的思想去指导你的行事方式，进而让你具备这个领域所特有的做事风格。</p>
<p>然而，要开始这样一段入门进而不断精深的旅程，你不能够像跑步一样，仅仅对自己说一声“往前”，然后就可以不断前进。大脑不会那样乖乖听话，因为那不是大脑的运作方式。如同钓鱼需要鱼饵，为了能够让大脑开启它的引擎，你也必须提供它的诱饵：“问题”。</p>
<p>人的思维不会自动地往下深入，它只会根据你能提供给它的问题进行运转。你向什么方向抛出问题，它就向什么地方思考；你的问题越精细，它的思考就会越缜密；你抛给大脑的问题越频繁，它所训练的时间就会越长久。大师和新手之间的差距，在于处理一个问题时，他们头脑中的问题列表不同。大师头脑中的问题列表，不仅详实丰富，并且主次分明。他知道首先应该问出什么样的问题，去把握一件事的主题框架；然后，应该在哪些地方问出一些基本的构架性问题，以掌控住局势；最后，应该在哪些地方抛出更为细致的问题，以便能够进一步精细、优化自己所最关心的核心主题。你必须不断地扩充和删减你的问题列表，让它足够充分而又没有冗余，集中在“关节”性的部分，而不会被表象稀释它们的有效性。</p>
<p>如何开始你的成长之旅，让你可以不断扩充你的问题列表？特别是开始阶段，如何从0变为1？我想，一份能够跨越领域的通识性的“元问题”列表或许能够给予你帮助。</p>
<p>进入一个新的领域，你所需要开始的第一个问题系列便是：</p>
<ol>
<li>这个领域为什么会存在？它的意义是什么，能够为世界提供什么价值？</li>
<li>这个领域关心哪些问题？为什么这些问题值得这个领域关心？</li>
<li>你对上述问题的解答全面吗？如果是，你如何能够证明你的解答是完整的？如果不是，你怎样才能搜集到这个领域更多的信息？</li>
</ol>
<p>这些问题所展现的不仅是你如何进入新领域的途径，更是在向你说明，你的大脑如何在阅读上述材料时逐步落地，真正开始深入肤浅的表象，去进一步探索深刻的主题。很多人会嘲笑一些领域的“简单”和“枯燥”，对其从业者所表现出来的对该领域的“诗意”一般的向往表示费解和轻蔑，比如设计、电影、写作、数学和编程。</p>
<p>面对设计作品，我们往往很难体会到设计者背后的良苦用心。为什么我们会不懂设计？因为我们缺乏最起码的入门。但只要我们通过上面的元问题列表检测一下自己，立刻就会推演出自己应该努力的方向，进入深度的沉思状态。</p>
<ol>
<li>为什么设计会存在？它真的仅仅是简单的装饰的堆砌吗？如果是，那为什么有些人会把奢侈品穿成淘宝货，而另外一些人能够把淘宝货穿出奢侈品的格调？如果不是，到底是什么能够让它能够直指你的内心，让你的所有行事方式都跟随设计者的意图移动？（嗯？感觉惊讶吗？嗯，你开始深入思考了）</li>
<li>这个领域关心哪些问题？关心各种细小元素：长、短、明、暗？为什么这些问题值得这个领域关心？仅仅是因为它能影响你的审美吗？它会不会影响你的其它部分呢？你的情绪？判断力？甚至是你的价值取向？</li>
<li>你对上述问题的解答全面吗？所谓设计，仅仅考虑的是它的“美”吗？是否有可能我们完全弄错了它所关心的主题呢？会不会有可能它对“美”的理解完全不同于对装饰的关注呢？</li>
</ol>
<p>没有问题的引导，你甚至不会知道自己的“不知”，轻易地陷入习焉不察、不以为意的恶习。要知道其中的精髓和内在含义，就不得不细加推敲和反复琢磨。这些“推敲”与“琢磨”都是建立在你的“问题列表”之上的。很多新人面对师傅的指导，常常容易听到一句这样的话，“你得多看看，你再多想想”。在我看来，这是非常粗糙的指导。我应该看什么呢？想什么呢？对于稍有经验的人，没有进行深思熟虑是态度问题。可是，对于初学者来说，他还没有构建出相应的问题列表，还不知道应该问什么问题，应该反复推敲一些什么问题。这也就是俗称的没入门。此时给出一份该领域的问题列表，对于新手的成长将会是极其有帮助的。但即便是无人指导（每一个新领域的开拓者都会遇到这样的情况），跨界的元问题列表，也能为你提供一个很好的探索的起点。</p>
<p>所谓问之弥深，钻之弥坚，你思维的引擎会随着所问的问题而不断地提升其转速，而的你思考也会随着问题的引领而不断地加深。没有问题做诱饵，你的思考将无法深入，你的思维也无法缜密。“反复推敲”“心思缜密”“行事谨慎”，没有一份问题列表作依托，就会成为你的一厢情愿。</p>
<p>另一方面，问题列表本身即会构成一个领域的框架。所谓框架，即是一个领域所依托的骨架。如若能够将其骨架上的问题和所思所问一一解决和考量，这个领域的其它部分，便能够得以健康成长。而这些思维的框架无一不是由问题列表所构成，比如波特五力模型，CFA的企业财务健康分析，又或者是创业人士对自己将要构建的世界的分析。在如今创业大潮的时代背景下，列举一份我搜集整理的Google的问题列表，为大家作为参考，翻译如下：</p>
<h2 id="google问题列表">Google问题列表</h2>
<p>思考一下你理想中的工作是什么样的，不是你当前的设想，而是你五年后的图景你想到什么地方去？</p>
<ol>
<li>你想做什么事？</li>
<li>你想赚取多少薪水？</li>
<li>写下你理想中的工作的介绍 (job description)：想想如果你在网上看到它，它应该是什么样的？</li>
</ol>
<p>现在，再想象你穿越到5年后并且你已经得到了这份工作：</p>
<ol>
<li>这时，你的简历上五年前到现在的履历应该是什么样的？</li>
<li>从五年前到你现在得到这个职位，你应该会经历怎样的历程？</li>
</ol>
<p>请继续保持思考你理想中的工作，根据它去评估一下你自己的优势和劣势：你还需要提高哪些方面才能到达哪里？</p>
<p>顺便提一句，如果你的结论是你现在已经得到了你理想中的工作，那么，这说明你的思考还不够大胆。重新做一遍上述的步骤，并且要保证你理想中的工作是基于你当前实力的延展，而不是毫无根据的幻想。</p>
<p>如果你按照以上步骤行事，它应该会有效果。如果你不遵循它们，那么你很可能会为YogiBerra的一段话提供一段新的实例证明：“你要小心了，如果你都不知道你的理想乡在哪里，那么你很可能不会到达那里。”</p>
<p>提出问题和解释问题的技能同给出问题答案的技能同样重要。</p>
<p>现在，如果你对未来有你自己的一些看法，并且有了一些主意，那么你可以问问自己一些更加残酷的问题：</p>
<ol>
<li>一家非常小巧并且资本充裕的竞争公司，会如何去撼动你公司的核心业务？</li>
<li>它会怎样利用数字平台的优势去挖掘你的弱点，或者撬走为你公司带来盈利最多的客户呢？</li>
<li>你公司当前所做的哪些事情正在摧毁自己的业务呢？</li>
<li>同质竞争和收益受损是你公司扼杀潜在创新所经常给出的理由吗？</li>
<li>公司的领导层经常使用自己的产品吗？他们热爱它吗？</li>
<li>他们愿意把自己的产品作为礼物送给自己的另一半吗？（显然这在很多情况下会有点不切实际，但它依旧是一个很好的思想实验。）</li>
<li>你的客户热爱你的产品吗？</li>
<li>还是说，你的客户是被一些其它因素绑定在了你的产品上，但这些因素在未来很可能会消失？</li>
<li>想象一下如果你的客户完全不会被这些因素所绑定，那会发生什么？</li>
<li>上一问题的一个有趣的推论是，如果你强迫你的产品团队将产品做得来让客户可以轻易抛弃你的产品而转向你的竞争者，你的产品团队会有什么样的反应？他们依然能够将产品做得来非常出色，以至于客户想要继续使用你的产品，即便是他们不必如此？</li>
</ol>
<p>关于产品的问题列表：</p>
<ol>
<li>它们有多少部分是建立在独特的技术洞见之上？</li>
<li>有多少产品人是在高管阵营里面？</li>
<li>公司是否狠狠地奖励和提拔了那些在创造出色产品中做出最大贡献的人？</li>
<li>你的决策过程是导向最好的决策？还是导向最容易接受的决策？</li>
<li>你的员工有多大的自由度？</li>
<li>如果你的公司里有一名非常有创造力的员工，这名员工能够有足够的自由度去施展和实现他的想法而不用担心他自己的职位高低吗？</li>
<li>你在新想法的决策是依据产品的优良程度，还是盈利程度？</li>
<li>在你的公司里，谁的表现会更好呢？是那些掌握了大量信息的人，还是传播了大量信息的人？</li>
<li>那些掌握大量信息的人会阻止信息在人们之间互相传播吗？</li>
</ol>
<p>上面都是一些非常残酷的问题，并且他们都没有显而易见的答案。但可以肯定的是，如果这些问题不被提出，那么肯定不会有相应的解决方案。</p>
<p>另外，鉴于我自己的技术背景，这里再提供一份我整理的技术人员的问题列表供大家参考，它们来自于《技术人创业攻略》这本书。</p>
<h3 id="许世伟">许世伟</h3>
<ol>
<li>先了解整个背景，看别人一般怎么做</li>
<li>有哪些新兴的idea，这些idea是不是靠谱，如果我来做，会倾向于哪个方向</li>
<li>新技术的思考方式是什么</li>
<li>它要解决的问题是什么</li>
<li>它和自己要解决的问题有多大的相关性</li>
<li>你对这个技术的“了解”，是只限于多了解了一个名词？</li>
<li>你清楚了这个技术背后的具体原理吗？</li>
</ol>
<p>产品的思考</p>
<ol>
<li>你了解这个产品的业务吗</li>
<li>了解它的运作方式吗</li>
<li>这个产品和商业的关系是什么呢</li>
<li>用户为什么需要我们</li>
<li>我们到底在颠覆什么</li>
<li>到底要做什么，应该如何做</li>
<li>工种认知和服务认知</li>
</ol>
<p>为什么要做这个服务
把服务做好，要做哪些功能
某个功能为什么会受到用户群的欢迎</p>
<h3 id="刘睿敏">刘睿敏</h3>
<p>你想用钱去换技术：</p>
<ol>
<li>技术是别人吃饭的东西，为什么会给你？你如果不自己造一个饭碗，别人为什么会把他的给你呢？</li>
<li>什么叫自主可控？自己做的，从无到有的东西叫自主可控。不是自己做的，就不可控</li>
<li>产业链上最核心的技术有哪些？你是否掌握了这些核心技术？</li>
<li>你是否在持续跟踪这些核心技术？在应用真正开始盛行之前，你做好了理论上的准备吗？</li>
<li>你是否只能谈一些如何应用、基于实践和操作层面的东西？</li>
<li>你能深入细谈核心的技术要点和设计思路吗？</li>
<li>你是否理解你修改的开源产品背后的设计思路？</li>
<li>你是否有循序渐进地、逐层深入地了技术的核心？</li>
<li>上层的工具开发，你是否有做相应的工作？中层的解析执行，你是否知道它们遵循的路径是什么？底层的优化，你是否知道该如何设计，你的优化又如何与其它模块配合？</li>
<li>你的角色是否仅仅是一个使用者？</li>
<li>你是否甚至连这个领域的理论都不清楚，还混淆了其中的各种概念</li>
</ol>
<hr>
<p>这篇文章转载自下面的公众号，大家可以关注公众号GeekArtT</p>]]></description>
</item><item>
    <title>01背包问题详解</title>
    <link>https://bugxch.github.io/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/</link>
    <pubDate>Sat, 22 Feb 2020 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://bugxch.github.io/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/</guid>
    <description><![CDATA[<p>背包问题是非常经典的动态规划问题，但是中文书籍和资料很少有把这个问题说得清晰明了的，问题表述不清，递推公式错误，不一而足，我在彻底想清楚这个问题后，觉得很有必要记录下整个思考过程。</p>
<h2 id="原始问题">原始问题</h2>
<p>当前有$n$件物品，第$i$件物品的重量为$w_i$，价值为$p_i$，当前有一个容量为$C$的背包。此处物品的重量，价值以及背包的容量都是非负整数。从这些物品中精心挑选若干件装入包中，这若干件被挑选的物品<strong>总重量不超过背包容量$C$，总价值尽量大</strong>，那么所有可能的挑选方法得到的</p>
<ol>
<li>最大值为多少？</li>
<li>放进去哪些物件得到这个最大值？</li>
</ol>
<p>问题的表述比较抽象，如果上面的问题有统一的算法，那么即便问题的规模缩小，问题解决的逻辑也不会有变化，所以从规模比较小的情形入手，更容易分析出来。假设背包容量是4kg，我们有3件物品，每件物品的价格以及重量见下表</p>
<table>
<thead>
<tr>
<th>物品</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>重量/kg</td>
<td>1</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>价格/$</td>
<td>8</td>
<td>9</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>我相信大多数人看到这个问题，会使用如下的<strong>贪婪算法</strong>。</p>
<h2 id="贪婪算法">贪婪算法</h2>
<ol>
<li>
<p>第1个想法是将物品按照价格从高到低进行排序，如果背包的空余容量可以容纳该物品，则将它放入背包。按照这个方法处理对于上面的例子，结果应该是仅仅放入第3件物品，价值是10，但是明显是错的，因为放入物品1和2的价值更大（17），所以<strong>这个方法行不通</strong>。</p>
</li>
<li>
<p>与上面的方法类似，可以按照重量从轻到重装入背包，但是对于下面的情形一样行不通</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>序号</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>重量/kg</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>价格/$</td>
<td>8</td>
<td>9</td>
<td>18</td>
</tr>
</tbody>
</table>
<p>放入背包的重量是物品1和2，总重是3，价值是17，正确答案是放入1和3，总价值是26，所以这种方法<strong>明显是错误的</strong>。</p>
<ol start="3">
<li>另一种改进的方法，定义物品的价值密度为</li>
</ol>
<p>$$
\rho_i = p_i/w_i
$$
按照价值密度由高到低排序，依次核验后放入背包，但是按照该算法处理下面的情形依然是失败的</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>重量/kg</td>
<td>1</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>价格/$</td>
<td>8</td>
<td>9</td>
<td>18</td>
</tr>
<tr>
<td>$\rho_i$</td>
<td>8</td>
<td>4.5</td>
<td>9</td>
</tr>
</tbody>
</table>
<p>该方法的结果是放入1和3，但是明显2和3号的价值更大。</p>
<p>所以，无论是按照重量，大小，还是密度排序，这样的方法都是错误的。其实考虑最周全的方法，求$n$件物品的是否放入背包的全部组合，记录所有总重量可以放入背包的组合的价值，然后选一个最大值即可，但是对于$n$件物品，需要考虑的组合有$2^n$组，算法的复杂度很高，当$n$比较大的时候就很不实际。</p>
<p>上面的三种方法使用贪婪算法，下面是《算法的乐趣》中对贪婪算法的描述，</p>
<blockquote>
<p>贪婪算法是寻找最优解的常用方法，该方法将求解的过程分成若干步骤，在每个步骤都应用贪心原则，选取当前状态下最好的或者最优的选择（局部最有利的选择），并以此希望最后堆叠出的结果是最好的或者最优的解。</p>
</blockquote>
<p>之前的算法将物品的选择分解为依次挑选物品，这里的次序可以是价值从高到低，重量从低到高或者密度从大到小，并且希冀于每一步结束之后，整体上的价值是最高的，重量是最轻的或者密度是最大的。这个就是明显的贪婪算法思想，但是<strong>局部最优不等于全部最优</strong>，因此这样的算法是失败的。</p>
<h2 id="动态规划">动态规划</h2>
<h3 id="重新定义问题">重新定义问题</h3>
<p>重新思考这个问题，换一个角度将其理解为<strong>有限空间利用价值最大化</strong>的问题，我们更清晰的描述一下这个问题，有助于我们进一步思考。<strong>从$n$个物品中挑选出其中的$m(m \le n)$个，用于填充大小为$C$的空间，</strong></p>
<blockquote>
<ol>
<li>使得$m$个物件的的总重量不超过$C$，即$ \sum_{k=1}^{m}{w_k} \le C$</li>
<li>在满足条件1的情况下，$m$个物件的总价值在所有可能的挑选组合中<strong>最大</strong>。</li>
</ol>
</blockquote>
<p>我们用$V[i, C]$表示这$m$个物件的总价值，即
$$
V[i,C] = \max_{s.t.}{\sum_{k=1}^{m}{p_k}}，m \le n
$$
重申一下$V[i,C]$的含义，它表示**使用$i$个物件充分填充空间$C$得到的最大价值，**所以，这个问题就需要找到两样答案，</p>
<ol>
<li>$V[i,C]$的值；</li>
<li>得到$V[i,C]$的值对应的$m$个物件的集合$M_i$</li>
</ol>
<p><strong>很多文章根本就没有把$V[i,C]$的含义说清楚！</strong></p>
<p><strong>很多文章根本就没有把$V[i,C]$的含义说清楚！</strong></p>
<p><strong>很多文章根本就没有把$V[i,C]$的含义说清楚！</strong></p>
<p><strong>请注意，这个含义非常重要，在后面的推导和计算过程中会反复使用，请务必深刻理解！</strong></p>
<hr>
<h3 id="递推思路">递推思路</h3>
<p>注意前方高能，<strong>下面是这个算法的关键</strong>, 假定我们已经得到上面两个问题的答案，**如果此时再有第$i + 1$个物品加进来，该怎么处理？**此时，问题转换为求</p>
<blockquote>
<ol>
<li>使用$i + 1$个物件充分填充空间C得到的最大价值$V[i + 1,C]$</li>
<li>以及$V[i + 1,C]$对应的物件的组合$M_{i+1}$</li>
</ol>
</blockquote>
<p>当你手里拿着这个重量为$w_{i+1}$的物品，准备填充容量为$C$的**空包**时候（**注意此处的空包，不要想当然得以为包里面已经有前面的$i - 1$中挑选的物件**了），有下面两种情形，</p>
<ol>
<li>该物件的重量大于背包的容量，即$w_{i+1} \gt C$，那么这个物品无论如何也放不进背包，因此这个物品不会被选中，所以只能**使用前面$i$个物件填充$C$**，得出$V[i + 1,C] = V[i, C]，M_{i + 1} = M_{i}$。</li>
<li>该物件的重量小于等于背包容量，即$w_{i+1} \le C$，这个时候你有两种选择，</li>
</ol>
<ul>
<li>
<p>先将这个物件放入背包，此处背包的可用空间还有$C-w_{i+1}$，那么可以使用之前的$i$件物品去充分填充这个剩余空间。注意，此时背包空间由两部分的物件充分填充，</p>
<p></p>
<ol>
<li>
<p>物件$i+1$充分填充空间$w_{i+1}$，该空间的最大价值为$p_{i+1}$</p>
</li>
<li>
<p>之前的$i$个物件充分填充剩余的空间$C - w_{i+1}$，该空间的最大价值为$V[i-1, C-w_{i+1}]$
所以，当前的情形下**使用$i+1$个物件填充空间$C$**的最大价值是上述二者的和，即$V[i+1, C] = V[i, C-w_{i+1}] + p_{i+1}，M_{i+1} = M_i\bigcup  i+1$。</p>
</li>
</ol>
</li>
<li>
<p>不放入背包，那结果和之前的第一种情形一样，空间$C$由前面的$i$件物品充分填充，那么$V[i + 1,C] = V[i, C]，M_{i + 1} = M_{i}$。
因此，结合上面的分析，对于这种可以放入背包的情形，取二者的最大值，有$V[i+1, C]=\max {V[i, C-w_{i+1}] + p_{i+1}，V[i, C]}$。</p>
</li>
</ul>
<p>综合以上分析，我们得到了一个递推关系式，</p>
<p></p>
<p>**终于水落石出！**将递推关系式中的$i$换成$i-1$，于是得到如下的结果</p>
<p></p>
<hr>
<h3 id="初始条件及推导方法">初始条件及推导方法</h3>
<p>根据上面的推导式，就可以求出最后的结果，最后还有两点需要明确：</p>
<ol>
<li>
<p><strong>$V[i, C]$的最初的值是什么？</strong></p>
<p>回想一下这个值表示的含义，<strong>使用$i$个物件充分填充空间$C$得到的最大价值</strong>，仔细考虑这个含义可以得到</p>
<ul>
<li>$V[0,0] = 0$，使用0个物件填充大小为0的空间的最大价值肯定是0</li>
<li>$V[0,C] = 0$，使用0个物件填充大小为C的空间的最大价值肯定是0，背包空空如也，价值为0</li>
<li>$V[i,0] = 0$，使用$i$个物件填充大小为0的空间的最大价值肯定是0，背包空空如也，价值为0</li>
</ul>
</li>
<li>
<p><strong>如何根据最初的值，一步步推导出最终的结果$V[i, C]$？</strong></p>
<p>再观察上面的递推公式，$i$个物件总的最大价值依赖于前$i-1$个物件总的最大价值以及当前第$i$个物件本身的重量以及价值，换句话说，如果<strong>我知道了前$i-1$个物件总的最大价值以及当前第$i$个物件本身的重量以及价值，那么我也能推导出$i$个物件总的最大价值。</strong></p>
<p>更仔细的观察公式里面的max的公式，我们不仅需要知道$V[i-1, C]$，还需要知道$V[i-1, C-w_i]$，特别地，这里的$w_i$表示第$i$个物件的重量，它可以是任意的非负整数，因此我们需要知道$V[i-1,0]$到$V[i-1,C]$的所有值，于是下面的<strong>二维数组</strong>填充就呼之欲出。</p>
</li>
</ol>
<h3 id="二维数组">二维数组</h3>
<p>我们使用二维数组记录$V[i,C]$，二维数组的行数为物件的总数$i$，二维数组的列数是背包的容量$C+1$（<strong>注意此处多加了一列，因为从上面的推导看出我们需要知道$V[i-1,0]$的值，所以多加一列作为第0列</strong>），我们使用之前的问题，使用4Kg容量的背包挑选下面的物件</p>
<table>
<thead>
<tr>
<th>物品</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>重量/kg</td>
<td>1</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>价格/$</td>
<td>8</td>
<td>9</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>我们一步步看看这个表格怎么填充，</p>
<ol>
<li>
<p>建立空的二维数组，行数是3，列数是5，表格中的所有值都是未知数（<strong>注意此表从第0列开始，我们数第0列，第1列直到第4列</strong>），</p>
<p></p>
</li>
<li>
<p>根据之前的推论$V[i,0] = 0,i = 1,2,3$，所有行的<strong>第0列都是0</strong>，得到如下的表格</p>
<p></p>
</li>
<li>
<p>计算<strong>第1行</strong>的值$V[1,k],k=1,2,3,4$，再回想一下这个含义的意思，<strong>使用1个物件填充空间为$k$的最大价值</strong>，第一个物件的重量是1，价值为8，那么</p>
<ul>
<li>可以填充大小为1的空间，填充后的剩余空间为0，总价值为8，即$V[1,1]= 8$；</li>
<li>可以填充大小为2的空间，填充后的剩余空间为1，<strong>但是此时你手上没有别的物件了，所以填充到此为止</strong>，总价值为8，即$V[1,2]= 8$；</li>
<li>可以填充大小为3的空间，填充后的剩余空间为2，但是此时你手上没有别的物件了，所以填充到此为止，总价值为8，即$V[1,3]= 8$；</li>
<li>可以填充大小为4的空间，填充后的剩余空间为3，但是此时你手上没有别的物件了，所以填充到此为止，总价值为8，即$V[1,4]= 8$；</li>
</ul>
<p>于是，我们得到第一行的值如下表所示</p>
<p></p>
</li>
<li>
<p>有了<strong>第2行</strong>的值，就可以根据之前的递推公式机械式得计算，第2件物品的重量为$w_2=3$，价值为$p_2=9$，</p>
<ul>
<li>第2件物品的$w_2&gt;1$，所以<strong>根据递推公式</strong>计算$V[2,1]=V[1,1]=8$，这件物品不放入包中；</li>
<li>第2件物品的$w_2&gt;2$，所以<strong>根据递推公式</strong>计算$V[2,2]=V[1,2]=8$，这件物品不放入包中；</li>
<li>第2件物品的$w_2=3$，所以<strong>根据递推公式</strong>计算$V[2,3]=\max {V[1, 3-w_2] + p_{2}，V[1, 3]}=\max {V[1,0] + 9，V[1, 3]}=9$，这件物品放入包中；</li>
<li>第2件物品的$w_2&lt;4$，所以<strong>根据递推公式</strong>计算$V[2,4]=\max{V[1, 4-w_2] + p_{2}，V[1, 4]}=\max{V[1, 1] + 9，V[1, 4]}=17$，这件物品放入包中；</li>
</ul>
<p>于是得到第二行的结果如下</p>
<p></p>
</li>
<li>
<p>按照计算第2行值的方法，计算第3行的值，结果如下</p>
<p></p>
<p>所以最终的结果是用3个物件填充空间为4的背包，得到的最大价值为$V[3,4] = 17$。</p>
</li>
</ol>
<h3 id="放入哪些物件">放入哪些物件</h3>
<p>但是且慢，文章的开头还有一个问题，我们放进去哪些物件，得到这个最大值的呢？请注意之前的递推思路那一小节中的物件集合$M_i$的变化，**当且仅当$V[i, C] = V[i-1, C-w{i}] + p_{i}$时，第$i$件物品才会被放进来**。再仔细观察一下递推公式，我们可以看到$V[i,C]$的值要么等于$V[i-1, C-w{i}] + p_{i}$，要么等于$V[i-1,C]$，所以可以确认</p>
<blockquote>
<p>如果$V[i, C] = V[i-1, C]$，那么第$i$件物品没有被放入背包中</p>
</blockquote>
<p>但是仅仅有这个条件判断是不是已经足够了，如果第$i$个物品是被放入背包中的，下一步回溯还是考察$V[i-1,C]$是否与$V[i-2,C]$的值相等吗？回到之前的那幅图</p>
<p></p>
<p>总的问题与子问题有相同的结构，如果第$i+1$个物品已经验证放入背包中了，更小的问题是**使用$i$个物件填充大小为$C-w_{i+1}$空间**，那么我们应该考察$V[i,C-w_{i}]$是否与$V[i-1,C-w_{i}]$的值相等。所以回溯的算法如下：</p>
<ol>
<li>从二维数组的$V[i, C]$开始，检查$V[i, C]$的值是否与$V[i-1, C]$相同；</li>
<li>考察第1步的结果</li>
</ol>
<ul>
<li>
<p>如果相同，那么第$i$件物品没有被放入背包，令$i-1\rightarrow i$，即继续检查$V[i-1, C]$的值是否与$V[i-2, C]$相同；</p>
</li>
<li>
<p>如果不同，那么第$i$件物品被放入背包，令$i-1\rightarrow i, C-w_i\rightarrow C$，即继续检查$V[i-1, C-w_i]$的值是否与$V[i-2, C-w_i]$相同；</p>
</li>
</ul>
<ol start="3">
<li>不停使用步骤2的逻辑，直到考察到$i=0$为止。</li>
</ol>
<p>那么，就可以逐行倒着回溯二维数组，</p>
<ol>
<li>
<p>我们先看第3行，$V[3,4]=V[2,4]$，所以第3件物品没有放入背包；</p>
<p></p>
</li>
<li>
<p>第2行，$V[2,4]\ne V[1,4]$，所以<strong>第2件</strong>物品放入背包，接下来需要检查$V[1,4-w_2]$是否与$V[0,4-w_2]$相同；</p>
<p></p>
</li>
<li>
<p>第1行，$V[1,1]\ne V[0,1]$，所以<strong>第1件</strong>物品放入背包（注意此处$V[0,4] = 0$，二维表格没有第0行，但是我们初始条件中推导过这个值），检查结束。
</p>
</li>
</ol>
<h3 id="编程代码">编程代码</h3>
<p>下面是C++的程序代码，</p>
<p>定义一个背包的类，默认有10物件，每个物件大重量为6，最高价格为35。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// knapsack.h
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;ctime&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">tagObj</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">weight</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">price</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Obj</span><span class="p">;</span>

<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">max</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>

<span class="k">class</span> <span class="nc">Knapsack</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Knapsack</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">maxWeight</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">maxPrice</span> <span class="o">=</span> <span class="mi">35</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">SolvePro</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">totalW</span><span class="p">);</span>
    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Knapsack</span><span class="o">&amp;</span> <span class="n">nap</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Obj</span><span class="o">&gt;</span> <span class="n">knapsack_</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">index_</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">totalPrice_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>方法如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// knapsack.cpp
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;knapsack.h&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;ctime&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">Knapsack</span><span class="o">::</span><span class="n">Knapsack</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">maxWeight</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">minPrice</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">srand</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)));</span>
    <span class="n">Obj</span> <span class="n">obj</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
         <span class="c1">// 随机生成价值和重量
</span><span class="c1"></span>        <span class="n">obj</span><span class="p">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">maxWeight</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">obj</span><span class="p">.</span><span class="n">price</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">minPrice</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">knapsack_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">totalPrice_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Knapsack</span><span class="o">&amp;</span> <span class="n">nap</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Dispaly knapsack list</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">nap</span><span class="p">.</span><span class="n">knapsack_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; object as below</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nap</span><span class="p">.</span><span class="n">knapsack_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;: weight &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">nap</span><span class="p">.</span><span class="n">knapsack_</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">weight</span> <span class="o">&lt;&lt;</span> \
            <span class="s">&#34;, price &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">nap</span><span class="p">.</span><span class="n">knapsack_</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">price</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Knapsack</span><span class="o">::</span><span class="n">SolvePro</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">totalW</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">knapsack_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">totalW</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">matrix</span><span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">row</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">col</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">knapsack_</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">).</span><span class="n">weight</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> \
                    <span class="n">matrix</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">knapsack_</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">).</span><span class="n">weight</span><span class="p">]</span> <span class="o">+</span> \
                    <span class="n">knapsack_</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">).</span><span class="n">price</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">totalPrice_</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">];</span>

    <span class="kt">int</span> <span class="n">startRow</span> <span class="o">=</span> <span class="n">row</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">startCol</span> <span class="o">=</span> <span class="n">col</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">startRow</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">startRow</span><span class="p">][</span><span class="n">startCol</span><span class="p">]</span> <span class="o">==</span> <span class="n">matrix</span><span class="p">[</span><span class="n">startRow</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">startCol</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">startRow</span><span class="o">--</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">index_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">startRow</span><span class="p">);</span>
        <span class="n">startCol</span> <span class="o">-=</span> <span class="n">knapsack_</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">startRow</span> <span class="o">-</span> <span class="mi">1</span><span class="p">).</span><span class="n">weight</span><span class="p">;</span>
        <span class="n">startRow</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">reverse</span><span class="p">(</span><span class="n">index_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">index_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">Weight capacity is &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">totalW</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, and totalPrice is &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">matrix</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">&lt;&lt;</span> \
        <span class="s">&#34;, selected obj index is: &#34;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">index_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">index_</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>使用main函数，调用如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;knapsack.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Knapsack</span> <span class="n">nap1</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">// 我们有10个物品，最大重量为6，最大价值为10，价值和重量都是随机生成的
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nap1</span><span class="p">;</span>
    <span class="n">nap1</span><span class="p">.</span><span class="n">SolvePro</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span> <span class="c1">// 背包容量30
</span><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>结果如下</p>
<p></p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.jianshu.com/p/a66d5ce49df5" target="_blank" rel="noopener noreffer">0-1背包问题 - 简书</a>，描述《算法图解》中对该问题的解法，比较有趣</li>
<li><a href="https://www.cnblogs.com/Christal-R/p/Dynamic_programming.html" target="_blank" rel="noopener noreffer">动态规划解决01背包问题 - Christal_R - 博客园</a>，中文博客写得不错的文章</li>
<li><a href="https://oi-wiki.org/dp/knapsack/" target="_blank" rel="noopener noreffer">背包 DP - OI Wiki</a>，在没有Google下搜索出来的总结比较全面的文章</li>
<li><a href="https://www.kancloud.cn/kancloud/pack" target="_blank" rel="noopener noreffer">背包问题九讲 · 看云</a>，非常系统的背包问题的解释</li>
</ul>]]></description>
</item><item>
    <title>《CPlusPlus Primer Plus》第九章习题及答案</title>
    <link>https://bugxch.github.io/cplusplus-primer-plus%E7%AC%AC%E4%B9%9D%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/</link>
    <pubDate>Mon, 27 Jan 2020 12:49:07 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://bugxch.github.io/cplusplus-primer-plus%E7%AC%AC%E4%B9%9D%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://raw.githubusercontent.com/bugxch/blogpics/master/202001/c%2B%2B.jpg" referrerpolicy="no-referrer">
            </div><p>假期做题，记录下。</p>
<p>此处是复习题的答案，编程练习题的答案见<a href="https://github.com/bugxch/Solutions_C-PrimerPlus" target="_blank" rel="noopener noreffer">bugxch/Solutions_C-PrimerPlus</a>。</p>
<h3 id="answer-1">Answer #1</h3>
<p>a) 形参在函数调用时候创建，在函数返回时销毁，自动存储变量，无链接性，所以是自动变量；</p>
<p>b) 文件共享的变量具有外部链接性，所以使用静态存储外部链接性的变量，比如在A文件中定义，在B中使用extern关键字引用；</p>
<p>c) 内部链接性，静态存储变量，可以使用static修饰符，或者使用未命名的命名空间；</p>
<p>d) 无链接性，但是是静态存储变量，在函数内部使用static修饰符定义</p>
<h3 id="answer-2">Answer #2</h3>
<p>有一下几点区别：</p>
<ol>
<li>using声明仅仅导入特定的名称，但是using编译命令将导入一个名称空间的所有名称；</li>
<li>假如名称空间和声明区域定义了相同的名称。using声明中如果该名称与局部名称发生冲突，编译器会发出警告，但是using编译指令导入的而名称会被局部版本隐藏。</li>
</ol>
<h3 id="answer-3">Answer #3</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#inlcude &lt;iostream&gt;
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="kt">double</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Enter valud: &#34;</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Bad input! Please enter a number: &#34;</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Value = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="answer-4">Answer #4</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#inlcude &lt;iostream&gt;
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">;</span>
    <span class="k">using</span> <span class="kt">double</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Enter valud: &#34;</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Bad input! Please enter a number: &#34;</span><span class="p">;</span>
        <span class="n">cin</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">cin</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Value = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="answer-5">Answer #5</h3>
<p>因为两个函数的形参和顺序一样，仅仅是返回值不同，因此无法使用函数重载。如果在不同的文件中使用，这两个函数的作用域不同，有两种方式实现，</p>
<ol>
<li>可以使用static关键字，</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">static</span> <span class="kt">double</span> <span class="n">average</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">intb</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>将函数的声明和定义放在未命名的名称空间中</li>
</ol>
<h3 id="answer-6">Answer #6</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="m">10</span>
<span class="m">4</span>
<span class="m">0</span>
Other: 10, <span class="m">1</span>
another<span class="o">()</span>: 10, -4
</code></pre></td></tr></table>
</div>
</div><h3 id="answer-7">Answer #7</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="m">1</span>
4, 1, <span class="m">2</span>
<span class="m">2</span>
<span class="m">2</span>
4, 1, <span class="m">2</span>
<span class="m">2</span>
</code></pre></td></tr></table>
</div>
</div>]]></description>
</item></channel>
</rss>
