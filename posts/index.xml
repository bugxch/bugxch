<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - Dive Into Think</title>
        <link>https://bugxch.github.io/posts/</link>
        <description>所有文章 | Dive Into Think</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>bugxch@126.com (bugxch)</managingEditor>
            <webMaster>bugxch@126.com (bugxch)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 06 May 2021 22:33:59 &#43;0800</lastBuildDate><atom:link href="https://bugxch.github.io/posts/" rel="self" type="application/rss+xml" /><item>
    <title>二分搜索——从入门到精通</title>
    <link>https://bugxch.github.io/binary_search/</link>
    <pubDate>Thu, 06 May 2021 22:33:59 &#43;0800</pubDate>
    <author>bugxch</author>
    <guid>https://bugxch.github.io/binary_search/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://pic.imgdb.cn/item/60940147d1a9ae528fdc3a1d.png" referrerpolicy="no-referrer">
            </div><p>最近在准备考试，做了一些二分搜索的题目，感觉有点意思，记录下做题的心得😁。</p>
<h2 id="文章目标">文章目标</h2>
<p>通过阅读本文，可以彻底搞懂二分查找的基本原理及各种变体，可以独立完成下面的力扣题目</p>
<table>
<thead>
<tr>
<th>力扣题目</th>
<th>考查点</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/" target="_blank" rel="noopener noreffer">374. 猜数字大小</a></td>
<td>基本模板</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener noreffer">69. x 的平方根</a></td>
<td>基本模板</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/first-bad-version/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china" target="_blank" rel="noopener noreffer">278. 第一个错误的版本</a></td>
<td>查找左边界</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener noreffer">153. 寻找旋转排序数组中的最小值</a></td>
<td>寻找旋转数组中的目标值（无重复元素）</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener noreffer">154. 寻找旋转排序数组中的最小值 II</a></td>
<td>寻找旋转数组中的目标值（包含重复元素）</td>
</tr>
<tr>
<td><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener noreffer">34. 在排序数组中查找元素的第一个和最后一个位置</a></td>
<td>查找左右边界</td>
</tr>
</tbody>
</table>
<h2 id="基本原理">基本原理</h2>
<p>在计算机科学中，二分搜索又被成为<strong>半区间</strong>搜索，对数搜索或者二分chop，它用于在排序数列中找到目标值的位置。算法不断比较数列中间元素与目标值，</p>
<ol>
<li>如果目标值与中间元素匹配，那直接返回中间的位置；</li>
<li>如果目标值比中间元素小，继续搜索低半边的数列；</li>
<li>如果目标值比中间元素大，那么继续搜索高半边</li>
</ol>
<p>注意到<strong>每次在比较元素之后搜索的区间会减少一半（去掉目标值不可能在的那一半区间）</strong>，所以在最坏的情况下，算法的复杂度是$O(logn)$。下面是二分搜索与线性搜索的比较示意图，以<strong>严格单调增且无重复元素</strong>的序列为例，查找目标值为37的序列值。</p>
<p></p>
<p>序列长度是17，</p>
<ol>
<li>二分查找第一次寻找整个搜索区间的中间的index（从0开始计数）为(0 + 16) / 2 = 8的数字23，23比37小，所以<strong>更新查找区间为</strong>[9,16]；</li>
<li>查找新区间的中间index = (9 + 16) /2 = 12，结果是数字41，比37大，<strong>更新查找区间</strong>为[9, 11];</li>
<li>查找新区间的中间index = (9 + 11) / 2 = 10，结果是数字31，比37大，继续<strong>更新查找区间</strong>为[11, 11]，此时中间元素就是第11号元素，即37，找到目标值，查找结束。</li>
</ol>
<p>根据以上算法步骤，很顺利就可以写出下面的伪代码，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">// basic template
<span class="k">function</span> binary_search<span class="o">(</span>A, n, T<span class="o">)</span> is
    L :<span class="o">=</span> <span class="m">0</span>
    R :<span class="o">=</span> n − <span class="m">1</span>
    <span class="k">while</span> L ≤ R <span class="k">do</span>
        m :<span class="o">=</span> floor<span class="o">((</span>L + R<span class="o">)</span> / 2<span class="o">)</span>
        <span class="k">if</span> A<span class="o">[</span>m<span class="o">]</span> &lt; T <span class="k">then</span>
            L :<span class="o">=</span> m + <span class="m">1</span>
        <span class="k">else</span> <span class="k">if</span> A<span class="o">[</span>m<span class="o">]</span> &gt; T <span class="k">then</span>
            R :<span class="o">=</span> m − <span class="m">1</span>
        <span class="k">else</span>:
            <span class="k">return</span> m
    <span class="k">return</span> unsuccessful
</code></pre></td></tr></table>
</div>
</div><p>使用上面的基本模板我们就可以解答文章开始列出的第一道题目了，<a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/" target="_blank" rel="noopener noreffer">374. 猜数字大小</a>题目，给出二分查找的基本模板。这道题目就是最传统的猜大小的谜题，标准的解答模板的代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cm">/**
</span><span class="cm"> * Forward declaration of guess API.
</span><span class="cm"> * @param  num   your guess
</span><span class="cm"> * @return 	     -1 if num is lower than the guess number
</span><span class="cm"> *			      1 if num is higher than the guess number
</span><span class="cm"> *               otherwise return 0
</span><span class="cm"> * int guess(int num);
</span><span class="cm"> */</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">guessNumber</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// detail 1
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">((</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// detail 2
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">rlt</span> <span class="o">=</span> <span class="n">guess</span><span class="p">(</span><span class="n">mid</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">rlt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
            <span class="p">}</span>
			<span class="c1">// detail 3
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">rlt</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>  <span class="k">else</span> <span class="p">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="关键技术细节">关键技术细节</h3>
<blockquote>
<p><em>Although the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky</em>  &ndash; <strong>Donald Knuth</strong></p>
</blockquote>
<p>就像高德纳所说，二分法的思想简单且易于理解，但是二分法的细节却藏了很多坑，<strong>魔鬼就在细节中</strong>。为了透彻理解二分法的实现，有必要对上面的代码的下面3个技术细节（标记为<code>detail</code>注释的地方）进行深究。</p>
<h4 id="循环的入口条件">循环的入口条件</h4>
<p>代码16行，为什么循环的入口条件是<code>left &lt;= right</code>？</p>
<blockquote>
<p>无论何时$[left, right]$表示<strong>可能包含目标值</strong>的搜索区间</p>
</blockquote>
<p>注意这是个<strong>左闭右闭</strong>的闭区间，单纯从数学角度出发，这个区间<strong>最短的长度就是1</strong>，也就是$left = right$的时候。如果$left &gt;  right$了，那$[left, right]$就是<strong>空集</strong>，这个集合<strong>肯定不包含目标值</strong>，也就<strong>没有继续搜索的必要</strong>了，所以循环退出。</p>
<h4 id="中点计算">中点计算</h4>
<p>为什么是<code>mid = left + ((right - left) &gt;&gt; 1)</code>，也就是数学的$floor((left + right) / 2)$?
这里的中点转换成数学表示就是
$$
\begin{align}
mid = \left \lfloor\frac{left + right}{2}  \right \rfloor
\end{align}
$$
其实，我们还有另外一种选择，将中间值定为
$$
\begin{align}
mid = \left \lceil\frac{left + right}{2}  \right \rceil
\end{align}
$$
第2种方式的中点值的选择是否可行？从后面的分析，**其实是可行的。**那这两个计算公式有什么区别？最大的区别在于$right = left + 1$的时候，也就是搜索区间长度为2左右端点挨着的时候，如下图所示，下一次循环计算mid，第1个公式结果是$mid = 4$，而第2个公式的结果是$mid = 5$，</p>
<p></p>
<p>，第1个公式$mid = \left \lfloor\frac{left + right}{2}  \right \rfloor = \left \lfloor\frac{left + left + 1}{2}  \right \rfloor = left$，而第2个公式$mid = \left \lceil\frac{left + right}{2}  \right \rceil = \left \lceil\frac{left + left + 1}{2}  \right \rceil = left + \lceil 0.5\rceil = left + 1 = right$，请记住这个重要的结论。</p>
<blockquote>
<p>当搜索区间的<strong>左右两端点挨着</strong>的时候（即$right = left + 1)$，floor函数计算的中点mid是left，ceil函数计算的中点mid是right</p>
</blockquote>
<p>请记住这个<strong>特殊的区间情况</strong>，至于为何基础模板选择floor而没有选择ceil，在后面的变化类型一节很关键。</p>
<h4 id="搜索区间调整">搜索区间调整</h4>
<p>在每次判断与target的差距之后，搜索区间为什么是这么调整的？
二分法另一个容易搞错的问题是区间调整，$left$和$right$好像可以选择$mid$的3个边界值$mid, mid - 1, mid + 1$中的任意一个，其实<strong>调整的原则</strong>很简单，</p>
<blockquote>
<ol>
<li><strong>排除</strong>target不可能存在的区间，<strong>保留</strong>可能存在的区间</li>
<li>保证<strong>任意判断分支为true时最后都可以跳出循环，尤其当$right = left + 1$时</strong></li>
</ol>
</blockquote>
<p>先看第1条原则，基础模板中，根据mid的值与目标值的差距，搜索区间$[left, right]$的调整有3个判断分支：</p>
<ol>
<li>如果和目标值相同$A[mid] = A[target]$，直接<strong>跳出循环</strong>，返回mid(代码第21行)；</li>
<li>如果比目标值大$A[mid] &gt; A[target]$，那么肯定$target &lt; mid$，所以$target \le mid - 1$，因此$target$位于区间$[left, mid - 1]$上，更新$right = mid - 1$；</li>
<li>如果比目标值小$A[mid] &lt; A[target]$，那么肯定$target &gt; mid$，所以$target \ge mid + 1$，因此$target$位于区间$[mid + 1， right]$上更新$left = mid + 1$。</li>
</ol>
<p>区间的调整仅仅保留了$target$可能存在的部分。</p>
<p>分支3的调整情况，看如下图示</p>
<p></p>
<p>考察第2条原则，<strong>是否可以退出循环</strong>？这个循环的退出条件是$left &gt; right$。对照上面的3个判断分支分别为true的情况：</p>
<ol>
<li>第1个判断分支直接退出循环，符合条件；</li>
<li>同理，第2个判断分支每次判断之后$right$在变小，所以必然在若干次之后比$left$小，直至退出循环</li>
<li>第3个判断分支每次调整之后$left$在变大，所以所以必然在若干次之后比$right$大，直至退出循环</li>
</ol>
<p>所以随着区间的调整，必然会在某一步满足退出的条件。<strong>特别的</strong>，当$right = left + 1$时，$mid = left$；</p>
<ul>
<li>第2个判断分支，$right = mid - 1 = left - 1 = right - 2 &lt; left = right - 1$，跳出循环</li>
<li>第3个判断分支，$left = mid + 1 = left + 1 = right$，再次进入循环，此时$mid = left = right$，$left = mid + 1 = right + 1 &gt; right$，可以看到在迭代2次之后也退出循环</li>
</ul>
<p>第2条原则满足。</p>
<hr>
<p>结合上面的分析，二分法的步骤包括：</p>
<p>从$A[mid]$与$target$的大小判断入手，判断它们的各种大小关系分支，确定每个判断分支的区间调整策略，需要满足下面的两条原则</p>
<blockquote>
<ol>
<li><strong>排除</strong>target不可能存在的区间，<strong>保留</strong>可能存在的区间</li>
<li>保证<strong>任意判断分支为true时最后都可以跳出循环，尤其当$right = left + 1$时</strong></li>
</ol>
</blockquote>
<h3 id="深入探究">深入探究</h3>
<p>上一小节讨论了3个关键技术细节，循环入口条件、中点计算和搜索区间调整，下面可以看到在满足上面的原则基础上，它们都可以变化。</p>
<h4 id="分支合并">分支合并</h4>
<p>当前的基础代码有3个判断分支，是否可以将3个分支合并成2个呢？下面的基础模板就可以。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">guessNumber</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 退出条件变了
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">((</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
            <span class="c1">// 调整策略的分支从3个变成了2个
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">guess</span><span class="p">(</span><span class="n">mid</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
		<span class="c1">// 返回的条件也变了
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">guess</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">left</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>再仔细考察一下，上面的代码，3个地方发生变化（已经在注释种标出）依然可以通过测试，其实还是按照上面的2个原则来看。</p>
<ol>
<li>
<p>每次调整区间，<strong>排除</strong>target不可能存在的区间，<strong>保留</strong>可能存在的区间</p>
<p>重新分析之前的3个判断分支，比较特殊是第1点，如果$A[mid] = A[target]$，那么$mid = target$，很明显</p>
<ul>
<li>判断分支1与判断分支2合并，当$A[mid] \ge A[target]$，$target \le mid$，所以$target$<strong>可能位于</strong>$[left, mid]$区间，调整$right = mid$，注意此处$right \ne mid -1$</li>
<li>判断分支1与判断分支3合并，当$A[mid] \le A[target]$，$target \ge mid$，所以$target$<strong>可能位于</strong>$[mid, right]$区间，调整$left = mid$，注意此处$left \ne mid +1$</li>
</ul>
<p>这两个策略看起来似乎都可以，结合其他两种情况，如果将3个分支合并为2个，应该有2种调整策略</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># solution 1，另一种正确的方案</span>
<span class="k">function</span> binary_search_alternative<span class="o">(</span>A, n, T<span class="o">)</span> is
    L :<span class="o">=</span> <span class="m">0</span>
    R :<span class="o">=</span> n − <span class="m">1</span>
    <span class="k">while</span> L &lt; R <span class="k">do</span>
        m :<span class="o">=</span> floor<span class="o">((</span>L + R<span class="o">)</span> / 2<span class="o">)</span>
        <span class="k">if</span> A<span class="o">[</span>m<span class="o">]</span> &gt;<span class="o">=</span> T <span class="k">then</span>
            R :<span class="o">=</span> m
        <span class="k">else</span>:
            L :<span class="o">=</span> m + <span class="m">1</span>
    <span class="k">if</span> A<span class="o">[</span>L<span class="o">]</span> <span class="o">=</span> T <span class="k">then</span>
        <span class="k">return</span> L
    <span class="k">return</span> unsuccessful
</code></pre></td></tr></table>
</div>
</div><p>或者</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># solution 2，错误示范</span>
<span class="k">function</span> binary_search_alternative<span class="o">(</span>A, n, T<span class="o">)</span> is
    L :<span class="o">=</span> <span class="m">0</span>
    R :<span class="o">=</span> n − <span class="m">1</span>
    <span class="k">while</span> L &lt; R <span class="k">do</span>
        m :<span class="o">=</span> floor<span class="o">((</span>L + R<span class="o">)</span> / 2<span class="o">)</span>
        <span class="k">if</span> A<span class="o">[</span>m<span class="o">]</span> &lt;<span class="o">=</span> T <span class="k">then</span>
            L :<span class="o">=</span> m
        <span class="k">else</span>:
            R :<span class="o">=</span> m - <span class="m">1</span>
    <span class="k">if</span> A<span class="o">[</span>L<span class="o">]</span> <span class="o">=</span> T <span class="k">then</span>
        <span class="k">return</span> L
    <span class="k">return</span> unsuccessful
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>保证<strong>任意判断分支为true时最后都可以跳出循环，尤其当$right = left + 1$时</strong></p>
<p>我们再看上面的两种伪代码，退出的条件是$left &gt;= right$，直接考察$left = right -1$的情况，如果在搜索的若干步之后搜索的区间变成下面的情况</p>
<p></p>
<p>下一步搜索的$mid = 4$，按照方案2，如果此时</p>
<ol>
<li>第2个判断分支为true，$right = mid - 1 = 3 &lt; left$，退出循环；</li>
<li>第1个判断分支为true（代码第7~8行），那么调整$left = mid = 4$，再次进入之后<strong>会发现陷入死循环</strong>，核心原因在于中点的选择上，因为使用的是floor函数，导致left永远恒等于mid，换句或说，$left$永远不再增加，而且也进不到更新$right$的分支，陷入死循环，考察方案1就没有这种情况。</li>
</ol>
<p>所以方案2的结果是错的。</p>
</li>
</ol>
<h4 id="中点计算变更">中点计算变更</h4>
<p>上面的方案2，因为不满足第2条原则而失败，那有没有办法通过改变其他部分而满足原则呢？第1个判断分支如果为true，当$right = left + 1$时，根据代码第6行，$mid = left$，所以进入分支之后$left = mid = left$，那可以将第6行的代码改成下面这样，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1"># solution 3，solution 2的改造</span>
<span class="k">function</span> binary_search_alternative<span class="o">(</span>A, n, T<span class="o">)</span> is
    L :<span class="o">=</span> <span class="m">0</span>
    R :<span class="o">=</span> n − <span class="m">1</span>
    <span class="k">while</span> L &lt; R <span class="k">do</span>
        m :<span class="o">=</span> ceil<span class="o">((</span>L + R<span class="o">)</span> / 2<span class="o">)</span> <span class="c1"># ceil取代floor函数</span>
        <span class="k">if</span> A<span class="o">[</span>m<span class="o">]</span> &lt;<span class="o">=</span> T <span class="k">then</span>
            L :<span class="o">=</span> m
        <span class="k">else</span>:
            R :<span class="o">=</span> m - <span class="m">1</span>
    <span class="k">if</span> A<span class="o">[</span>L<span class="o">]</span> <span class="o">=</span> T <span class="k">then</span>
        <span class="k">return</span> L
    <span class="k">return</span> unsuccessful
</code></pre></td></tr></table>
</div>
</div><p>再考察一下上面的搜索区间左右端点相邻的情况，下一次搜索的$mid = 5$，无论走哪一个判断分支，最终$left = right$，跳出循环，所以对于第2条原则需要补充</p>
<blockquote>
<p>可以通过调整中点的计算方式，满足原则2，从而避免死循环</p>
</blockquote>
<h4 id="判断条件变更">判断条件变更</h4>
<p>需要注意，其他2个的模板的循环条件为$left &lt; right$，当$left \ge right$时退出，如果$left = right$，那么搜索的区间只剩下一个元素，跳出循环之后别忘了要检查这个元素是否满足条件。如果最后的这个元素依然不是target，那么所有的元素也不是了，所以在最后我们加了一个判断，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">    <span class="k">if</span> A<span class="o">[</span>L<span class="o">]</span> <span class="o">=</span> T <span class="k">then</span>
        <span class="k">return</span> L
    <span class="k">return</span> unsuccessful
</code></pre></td></tr></table>
</div>
</div><h2 id="变种题目">变种题目</h2>
<p>理解上面的分析过程之后，进入进阶版的二分法题目。</p>
<h3 id="重复元素左边界">重复元素左边界</h3>
<p>参考<a href="https://leetcode-cn.com/problems/first-bad-version/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china" target="_blank" rel="noopener noreffer">278. 第一个错误的版本</a>，从某个版本开始，版本就已经不可用了，但是在这个版本之前，所有的版本均可用，需要找出第一个不可用的版本。假如说，我们有100个版本，从第70个版本开始不用，那么怎么快速找到70呢？如下所示</p>
<p></p>
<p>题目要找到最左边第一个true对应的下标70，也是找到重复的<code>true</code>区间的左边界。初始化$left = 0, right = 100$，我们还是<strong>从判断分支入手</strong>，</p>
<ol>
<li>如果$A[mid] = true$，那么$target$可能位于$[mid + 1, right]$区间，调整$left = mid + 1$；</li>
<li>如果$A[mid] = false$，$mid$可能是$target$，但是$mid + 1$不会是$target$（因为我们要找的是最左边的那个FALSE），那么$target$可能位于$[left, mid]$区间，调整$right = mid$</li>
</ol>
<p>结合中点的计算原则$mid = floor((left + right)/ 2)$，判断$right = left + 1$时候，2个判断分支最终都可以跳出循环。最终代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// The API isBadVersion is defined for you.
</span><span class="c1">// bool isBadVersion(int version);
</span><span class="c1"></span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">firstBadVersion</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">((</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">isBadVersion</span><span class="p">(</span><span class="n">mid</span><span class="p">)</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        
        <span class="k">return</span> <span class="n">left</span><span class="p">;</span>            
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>更一般的，假如我们要查找序列$[1,2,3,4,4,5,6,6,7,7,9,10,10,10]$中的<strong>最左边</strong>的10的index，该如何处理？从分支判断入手，</p>
<ol>
<li>如果$A[mid] \lt 10$，那么10可能位于区间$[mid + 1, right]$区间，调整$left = mid + 1$；</li>
<li>如果$A[mid] =  10$，那么10可能位于区间$[left, mid]$区间，调整$right = mid$；</li>
<li>如果$A[mid] \gt  10$，那么10可能位于区间$[left, mid - 1]$区间，调整$right = mid - 1$</li>
</ol>
<p>合并分支2和分支3，变成</p>
<ol>
<li>如果$A[mid] \lt 10$，那么10可能位于区间$[mid + 1, right]$区间，调整$left = mid + 1$；</li>
<li>如果$A[mid] \ge  10$，那么10可能位于区间$[left, mid]$区间，调整$right = mid$</li>
</ol>
<p>判断当$left = right - 1$时，两个分支都可以顺利退出。代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">CheckVal</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">((</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">left</span><span class="p">;</span>  
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>       
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="重复元素右边界">重复元素右边界</h3>
<p>假如我们要查找序列$[1,2,3,4,4,5,6,6,7,7,9,10,10,10]$中的<strong>最右边</strong>的10的index，该如何处理？从分支判断入手，</p>
<ol>
<li>如果$A[mid] \lt 10$，那么最右边的10可能位于区间$[mid + 1, right]$区间，调整$left = mid + 1$；</li>
<li>如果$A[mid] =  10$，这个$A[mid]$可能是最右边的10，也可能不是，但是$A[mid - 1]$肯定不是最右边的10了，所以目标值可能位于区间$[mid, right]$区间，调整$left = mid$；</li>
<li>如果$A[mid] \gt  10$，那么最右边的10可能位于区间$[left, mid - 1]$区间，调整$right = mid - 1$</li>
</ol>
<p>合并分支1和分支2，变成</p>
<ol>
<li>如果$A[mid] \le 10$，那么10可能位于区间$[mid, right]$区间，调整$left = mid$；</li>
<li>如果$A[mid] \gt  10$，那么10可能位于区间$[left, mid - 1]$区间，调整$right = mid - 1$</li>
</ol>
<p>判断当$left = right - 1$时，按照floor函数计算，第1个分支会陷入死循环，所以需要调整中点的计算方式为ceil，判断两个分支都可以顺利退出，所以代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">CheckVal</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">((</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">left</span><span class="p">;</span>  
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>       
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="旋转数组无重复元素">旋转数组（无重复元素）</h3>
<p>来做文章目标中的<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener noreffer">153. 寻找旋转排序数组中的最小值</a>这道题，具体看看示例2中的题目怎么做</p>
<p></p>
<p>具体的值和index的分布如下所示</p>
<p></p>
<ol>
<li>
<p>初始化搜索范围，$left = 0, right = n - 1 = 6$；</p>
</li>
<li>
<p>$mid = 3$，从判断$A[3] = 7$与$target$的值入手，但是比较棘手的是$target$是多少呢（我们不知道最小值是0，仅仅知道这是一个旋转序列）？那我们根据什么判断$target$存在的可能区间呢？注意下面这幅图
</p>
</li>
</ol>
<p>这个旋转数组分为前后两个区间，前面区间每一个数字都比后面区间的数字大（因为没有重复数字），分别称为高半区间和低半区间。很明显，</p>
<ol>
<li>最小值一定在低半区间，且位于低半区间的起始点上；</li>
<li>我们不知道低半区间的起始点在哪里，也不知道高半区间的终点在哪里；</li>
<li>我们可以根据当前元素与数组最后一个元素（想想为什么不是第一个元素）的大小确认出具体位于哪个半区间，如果$A[id] &gt; A[n - 1]$，那么在高半区间，否则在低半区间。</li>
</ol>
<p>那这个和判断$target$所在区间有什么关系呢？如果$mid$位于高半区间，那么可以肯定最小值肯定不在$[left, mid]$中，更新$left = mid + 1$，如果位于低半区间，可以肯定$[mid+ 1, right]$不可能是最小值，更新$right = mid$。于是有下面的代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">findMin</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">((</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>判断是否在$right = left +1$时，每个分支可以跳出循环，可以👍，完毕。</li>
</ol>
<h3 id="旋转数组-包含重复元素左边界">旋转数组（ 包含重复元素）左边界</h3>
<p>再来看<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener noreffer">154. 寻找旋转排序数组中的最小值 II - 力扣（LeetCode）</a>，这个题目与上面有点区别，就是它有重复元素，如下图</p>
<p></p>
<p>看起来可以按照上面的题目如法炮制，判断$A[mid]$与$A[n -1]$的大小，</p>
<ol>
<li>
<p>如果$A[mid] &gt; A[n -1]$，$mid$位于高半区间，则最小值肯定不在$[left, mid]$里面，更新$left = mid + 1$；</p>
</li>
<li>
<p>如果$A[mid] &lt; A[n -1]$，$mid$位于低半区间，则最小值肯定不在$[mid +1, right]$里面，更新$right = mid$；</p>
</li>
<li>
<p>如果$A[mid] = A[n-1]$，这个时候就说不清楚$mid$是在高区间还是低区间了。因为可能有下面的情况</p>
<p></p>
<p>再仔细想想，其实在这一步，我们不需要知道我们位于哪个区间，我们要清楚$mid$跟最小值的index的关系，参考下面的图</p>
<p></p>
<p>考虑数组中的最后一个元素$A[right]$，在最小值右侧的元素，它们的值一定都小于等于$A[right]$；而在最小值左侧的元素，它们的值一定都大于等于 $A[right]$。假定中点为$pilot$，比较$A[pilot]$与$A[right]$的大小，可以间接判断出$pilot$和$target$的位置关系。</p>
<p>第一种情况，$A[pilot]&lt;A[high]$，说明此时最小的点位于$pilot$的左边，所以更新$right = pilot$；</p>
<p></p>
<p>第二种情况，$A[pilot]&gt;A[high]$，说明此时最小的点位于$pilot$的右边，所以更新$left = pilot + 1$；</p>
<p></p>
<p>第三种情况，$A[pilot]=A[high]$，此时唯一可以确定的是最小值在$high$的左边，所以更新$right = right - 1$</p>
<p></p>
</li>
</ol>
<p>则有如下的答案</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">findMin</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">high</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">high</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">high</span> <span class="o">=</span> <span class="n">pivot</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">high</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">low</span> <span class="o">=</span> <span class="n">pivot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">high</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="n">low</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>考察$right = left + 1$时候，三个分支都可以顺利跳出循环，搞定👍</p>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="https://segmentfault.com/a/1190000016825704" target="_blank" rel="noopener noreffer">二分查找、二分边界查找算法的模板代码总结 - SegmentFault 思否</a>，给我很多启发的一篇文章</li>
<li><a href="https://en.wikipedia.org/wiki/Binary_search_algorithm" target="_blank" rel="noopener noreffer">Binary search algorithm</a>，维基百科页面，英文版里面的内容很详尽</li>
</ol>
<hr>
<figure><figcaption>
            <h4>欢迎扫码关注我的公众号</h4>
        </figcaption>
</figure>]]></description>
</item><item>
    <title>Factory Method模式精解（C&#43;&#43;版本）</title>
    <link>https://bugxch.github.io/dp_4/</link>
    <pubDate>Sun, 02 May 2021 21:43:54 &#43;0800</pubDate>
    <author>bugxch</author>
    <guid>https://bugxch.github.io/dp_4/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://pic.imgdb.cn/item/608eae16d1a9ae528f502e1a.png" referrerpolicy="no-referrer">
            </div><p>继续之前的设计模式第四弹，这次是大名鼎鼎的工厂方法模式。</p>
<h2 id="使用情景">使用情景</h2>
<blockquote>
<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method是创建型模式，使一个类的实例化延迟到其子类。</p>
</blockquote>
<p>Factory有工厂的意思，简单来看，这个模式利用到了上一篇的<a href="https://bugxch.github.io/dp_3/" target="_blank" rel="noopener noreffer">Template Method模式</a>用来生成具体的实例，说得更清楚一点，工厂方法模式将创建对象的过程延迟到子类实现，其他的父类的步骤保持完整。</p>
<h2 id="问题引入">问题引入</h2>
<p>想象一个养殖业的农民，他刚开始仅仅在养马场养马，每个马都需要养殖长大之后在市面出售，后来他获得足够的利润之后，扩展业务也养牛，但是在牛场养牛，每头牛也是需要养殖长大之后在市面出售的。在刚开始的时候，我们需要记录每只马的养殖过程，后面还要记录它的售价。如果你前面只有养马的程序（包括生产、饲养、销售的过程），比如下面这样</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Farm</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">CreateHorse</span><span class="p">();</span>
    <span class="n">FeedHorse</span><span class="p">();</span>
    <span class="n">SellHorse</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">Horse</span> <span class="n">horse_</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>需要添加金养牛的程序，那么大多数情况会出现一个<code>switch</code>的分支，随着饲养的品种越来越多，最后会在生产、饲养和售卖的各个过程中出现多个<code>switch</code>分支。如果我是农场主，代码会陷入“分支瘫痪”，对维护这一套代码感到厌烦。比如下面这样</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Farm</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">CreateAnimal</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">animaltype</span> <span class="o">==</span> <span class="s">&#34;horse&#34;</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// create horse
</span><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">animaltype</span> <span class="o">==</span> <span class="s">&#34;cow&#34;</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// ceate cow
</span><span class="c1"></span>        <span class="p">}</span> <span class="p">...</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// create others
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">FeedAnimal</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">animaltype</span> <span class="o">==</span> <span class="s">&#34;horse&#34;</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// feed horse
</span><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">animaltype</span> <span class="o">==</span> <span class="s">&#34;cow&#34;</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// feed cow
</span><span class="c1"></span>        <span class="p">}</span> <span class="p">...</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// feed others
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">SellAnimal</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">animaltype</span> <span class="o">==</span> <span class="s">&#34;horse&#34;</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// sell horse
</span><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">animaltype</span> <span class="o">==</span> <span class="s">&#34;cow&#34;</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// sell cow
</span><span class="c1"></span>        <span class="p">}</span> <span class="p">...</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// sell others
</span><span class="c1"></span>        <span class="p">}</span>

    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">animaltype</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>这样的方案有什么明显的缺点呢？</p>
<ul>
<li><strong>高耦合</strong>，这个大类中的函数有一处需要添加分支，每个函数就都需要变化，但是每个函数实际是售卖动物的不耦合的步骤（生产不影响饲养，饲养不影响售卖），这些步骤之间耦合太紧，导致“霰弹式修改”；</li>
<li><strong>分支瘫痪</strong>，添加的类别越多，代码的<code>if/else/switch</code>的分支越多，最后陷入分支瘫痪的状态。</li>
</ul>
<h2 id="解决方案">解决方案</h2>
<p>按照<a href="https://book.douban.com/subject/20406704/" target="_blank" rel="noopener noreffer">《设计模式解析》</a>中的原则，设计模式需要遵循如下的一些原则：</p>
<blockquote>
<ol>
<li>考虑设计中什么应该是可变的；</li>
<li>对变化的概念进行封装；</li>
<li>优先使用对象聚集而不是类继承</li>
</ol>
</blockquote>
<p>在上面的例子中，有两个基本要素——农场和动物，<strong>每一个类应该对自己的职责负责</strong>，</p>
<ul>
<li>农场负责生产和饲养动物，不同种类的动物<strong>生产和饲养的方式</strong>都不同；</li>
<li>动物被售卖，不同的动物<strong>售卖的价格</strong>均不同；</li>
</ul>
<p>可以看出可以将之前的方案拆解成两个类<code>Farm</code>和<code>Animal</code>，而且生产、饲养和售卖的方式都是<strong>可变</strong>的，所以这些方法<strong>都是虚方法</strong>。对于具体的动物，生成具体的农场和动物。</p>
<h2 id="uml表示及其代码">UML表示及其代码</h2>
<p>参考解决方案的内容，我们画出这些类的UML的图，如下所示</p>
<p></p>
<p>具体的代码如下所示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Animal</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">Sell</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">Animal</span><span class="p">(</span><span class="kt">int</span> <span class="n">price</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span><span class="n">price_</span><span class="p">(</span><span class="n">price</span><span class="p">),</span> <span class="n">id_</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="p">{};</span>
<span class="k">protected</span><span class="o">:</span>
	<span class="kt">int</span> <span class="n">price_</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Horse</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="kt">void</span> <span class="n">Sell</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">id_</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;: Horse sell &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">price_</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; yuan</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">Horse</span><span class="p">(</span><span class="kt">int</span> <span class="n">price</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">Animal</span><span class="p">(</span><span class="n">price</span><span class="p">,</span> <span class="n">id</span><span class="p">)</span> <span class="p">{};</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Cow</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Animal</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="kt">void</span> <span class="n">Sell</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">id_</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;: Cow sell &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">price_</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; yuan</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">Cow</span><span class="p">(</span><span class="kt">int</span> <span class="n">price</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">Animal</span><span class="p">(</span><span class="n">price</span><span class="p">,</span> <span class="n">id</span><span class="p">)</span> <span class="p">{};</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Farm</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="k">virtual</span> <span class="n">Animal</span><span class="o">*</span> <span class="n">Create</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">price</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">HorseFarm</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Farm</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">Animal</span><span class="o">*</span> <span class="n">Create</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">price</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">Horse</span><span class="p">(</span><span class="n">price</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">CowFarm</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Farm</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">Animal</span><span class="o">*</span> <span class="n">Create</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">int</span> <span class="n">price</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">Cow</span><span class="p">(</span><span class="n">price</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Farm</span><span class="o">*</span> <span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HorseFarm</span><span class="p">();</span>
	<span class="n">Animal</span><span class="o">*</span> <span class="n">horse</span> <span class="o">=</span> <span class="n">factory</span><span class="o">-&gt;</span><span class="n">Create</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
	<span class="n">horse</span><span class="o">-&gt;</span><span class="n">Sell</span><span class="p">();</span>

	<span class="n">factory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CowFarm</span><span class="p">();</span>
	<span class="n">Animal</span><span class="o">*</span> <span class="n">cow</span> <span class="o">=</span> <span class="n">factory</span><span class="o">-&gt;</span><span class="n">Create</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
	<span class="n">cow</span><span class="o">-&gt;</span><span class="n">Sell</span><span class="p">();</span>

	<span class="k">delete</span> <span class="n">factory</span><span class="p">;</span>
	<span class="k">delete</span> <span class="n">horse</span><span class="p">;</span>
	<span class="k">delete</span> <span class="n">cow</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><hr>
<figure><figcaption>
            <h4>欢迎扫码关注我的公众号</h4>
        </figcaption>
</figure>]]></description>
</item><item>
    <title>Template Method模式精解（C&#43;&#43;版本）</title>
    <link>https://bugxch.github.io/dp_3/</link>
    <pubDate>Fri, 30 Apr 2021 19:52:15 &#43;0800</pubDate>
    <author>bugxch</author>
    <guid>https://bugxch.github.io/dp_3/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://pic.imgdb.cn/item/608bef5dd1a9ae528f268767.png" referrerpolicy="no-referrer">
            </div><p>设计模式第三弹，设计模式<strong>行为型模式</strong>中的模板方法，也比较简单。</p>
<h2 id="使用情景">使用情景</h2>
<blockquote>
<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method是行为型模式，使得子类可以不改变算法的结构（步骤）即可重定义该算法的某些特定步骤。</p>
</blockquote>
<p>模板方法将整个算法转换为一系列独立的步骤， 以便子类能对其进行扩展， 同时还可让超类中所定义的结构保持完整。可以设想我们上学时候临摹毛笔字，你可以使用墨汁沿着田字格中的汉字临摹，也可以使用红墨水临摹，无论用哪种颜色的墨水，最后完成的字的形状是一样的。</p>
<p></p>
<p>汉字的字形就是模板，每个学生使用不同的工具或者墨水按照模板习字，就是模板方法。</p>
<h2 id="问题引入">问题引入</h2>
<p>Template Method就是带有模板功能的模式，它有下面的特点：</p>
<ol>
<li>组成模板的方法被定义在父类中，但是这些方法是抽象方法，具体的方法实现由各个子类实现；</li>
<li>父类中定义了<strong>处理流程的框架</strong>，这个流程由上面定义的这些方法<strong>按照特定的步骤完成</strong>。</li>
</ol>
<p>打一个比方，如果我们村里的每个人盖一座房子，无论是谁都需要完成如下的步骤，准备材料，设计图纸，雇佣施工队，开工建设，完成这些步骤之后才能盖起一座完整的房子。但是不同的人使用的材料不同，设计的图纸不同，施工队的质量也不一样，依照主人的品味和资金实力每一个步骤不同的人做就有不同的效果。这里的所有步骤就是模板方法，不同的人就是子类。</p>
<h2 id="uml表示及代码">UML表示及代码</h2>
<p>参考《图解设计模式》中第三章的例子，UML图及代码如下所示</p>
<p>
每个类的作用如下
</p>
<ul>
<li><code>AbstractDisplay</code>是抽象类，定义了整个的<strong>流程框架</strong>，即方法<code>display()</code>，该方法又由3个抽象方法实现<code>open(), print(), close()</code>；</li>
<li><code>CharDisplay</code>和<code>StringDisplay</code>是具体的继承类，它们实现了抽象类中的抽象方法。
仅仅从抽象类看不出来每个抽象方法的具体实现，这些方法由每个类具体负责，上面的所有的类的具体代码如下。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">AbstractDisplay</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">open</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">print</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">close</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">display</span><span class="p">()</span> <span class="k">final</span>
	<span class="p">{</span>
		<span class="n">open</span><span class="p">();</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">print</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">close</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">CharDisplay</span><span class="o">:</span> <span class="k">public</span> <span class="n">AbstractDisplay</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">CharDisplay</span><span class="p">(</span><span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="sc">&#39;h&#39;</span><span class="p">)</span> <span class="o">:</span> <span class="n">ch_</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="p">{};</span>
	<span class="kt">void</span> <span class="nf">open</span><span class="p">()</span> <span class="k">override</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;&lt;&lt;&#34;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="nf">close</span><span class="p">()</span> <span class="k">override</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;&gt;&gt;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="nf">print</span><span class="p">()</span> <span class="k">override</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ch_</span><span class="p">;</span>
	<span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
	<span class="kt">char</span> <span class="n">ch_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">StringDisplay</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AbstractDisplay</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">StringDisplay</span><span class="p">(</span><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&#34; &#34;</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">:</span><span class="n">width_</span><span class="p">(</span><span class="n">width</span><span class="p">),</span> <span class="n">str_</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">{};</span>
	<span class="kt">void</span> <span class="nf">open</span><span class="p">()</span> <span class="k">override</span>
	<span class="p">{</span>
		<span class="n">printLine</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="nf">print</span><span class="p">()</span> <span class="k">override</span>
	<span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;|&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">str_</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;|</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="nf">close</span><span class="p">()</span> <span class="k">override</span>
	<span class="p">{</span>
		<span class="n">printLine</span><span class="p">();</span>
	<span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
	<span class="n">string</span> <span class="n">str_</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">width_</span><span class="p">;</span>
	<span class="kt">void</span> <span class="nf">printLine</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;+&#34;</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">width_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;-&#34;</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;+</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">AbstractDisplay</span><span class="o">*</span> <span class="n">display</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CharDisplay</span><span class="p">(</span><span class="sc">&#39;H&#39;</span><span class="p">);</span>
	<span class="n">display</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">();</span>
	<span class="k">delete</span> <span class="n">display</span><span class="p">;</span>
	<span class="n">display</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringDisplay</span><span class="p">(</span><span class="s">&#34;Hello World!&#34;</span><span class="p">);</span>
	<span class="n">display</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">();</span>
	<span class="k">delete</span> <span class="n">display</span><span class="p">;</span>
	<span class="n">display</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringDisplay</span><span class="p">(</span><span class="s">&#34;Hello haha!&#34;</span><span class="p">);</span>
	<span class="n">display</span><span class="o">-&gt;</span><span class="n">display</span><span class="p">();</span>
	<span class="k">delete</span> <span class="n">display</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>运行结果如下，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="s">&lt;&lt;HHHHH</span>&gt;&gt;
+----------+
<span class="p">|</span>Hello World!<span class="p">|</span>
<span class="p">|</span>Hello World!<span class="p">|</span>
<span class="p">|</span>Hello World!<span class="p">|</span>
<span class="p">|</span>Hello World!<span class="p">|</span>
<span class="p">|</span>Hello World!<span class="p">|</span>
+----------+
+----------+
<span class="p">|</span>Hello haha!<span class="p">|</span>
<span class="p">|</span>Hello haha!<span class="p">|</span>
<span class="p">|</span>Hello haha!<span class="p">|</span>
<span class="p">|</span>Hello haha!<span class="p">|</span>
<span class="p">|</span>Hello haha!<span class="p">|</span>
+----------+
</code></pre></td></tr></table>
</div>
</div><hr>
<figure><figcaption>
            <h4>欢迎扫码关注我的公众号</h4>
        </figcaption>
</figure>]]></description>
</item><item>
    <title>Adapter模式精解（C&#43;&#43;版本）</title>
    <link>https://bugxch.github.io/dp_2/</link>
    <pubDate>Thu, 29 Apr 2021 22:39:41 &#43;0800</pubDate>
    <author>bugxch</author>
    <guid>https://bugxch.github.io/dp_2/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://pic.imgdb.cn/item/608ac85bd1a9ae528fde126e.png" referrerpolicy="no-referrer">
            </div><p>本篇是设计模式第二篇，适配器模式，比较好理解。</p>
<h2 id="使用情景">使用情景</h2>
<blockquote>
<p>适配器模式是一种<strong>结构型</strong>设计模式， 它能使接口<strong>不兼容</strong>的对象能够相互合作。</p>
</blockquote>
<p>如果你有出国的经验，那么在出国前肯定会在淘宝买一个电源的转接插头带在身上，在国外旅行时为手机或者PC充电。为什么需要这个东西？参考这篇<a href="https://www.skyscanner.net/news/international-travel-plug-adapter-guide" target="_blank" rel="noopener noreffer">国际旅行电源适配器指南</a>，从文章中可以看出，每个不同的国家和地区的电源插座的形状和电压都不同，比如中国家用交流电是220V，而印度是230V，从电压的角度出发，你也需要一个东西将230V的电源转换成为稳定的220V，才能给电脑供电。</p>
<h2 id="问题引入">问题引入</h2>
<p>那我们的问题自然就是如果我去印度旅行，如何使用工具将230V的电源转换成220V呢？</p>
<h2 id="解决方案">解决方案</h2>
<p>解决方案也很简单，使用一个电源适配器即可，它负责将230V电源转换成为220V供我使用。</p>
<h2 id="uml表示及代码">UML表示及代码</h2>
<p>参考《图解设计模式》的章节，我们有两种适配器模式。</p>
<h3 id="基于继承的适配器模式">基于继承的适配器模式</h3>
<p></p>
<p>上面的图示中，<code>Banner</code>就是印度的230V电源，<code>PrintBanner</code>是电源适配器，<code>Print</code>表示我的电脑插头，<code>Main</code>函数是我自己。具体的C++代码如下所示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">class</span> <span class="nc">Banner</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">Banner</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&#34;&#34;</span><span class="p">)</span> <span class="o">:</span> <span class="n">str_</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">{}</span>
	<span class="kt">void</span> <span class="nf">showWithParen</span><span class="p">()</span> <span class="k">const</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;(&#34;</span>  <span class="o">&lt;&lt;</span> <span class="n">str_</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;)&#34;</span> <span class="o">&lt;&lt;</span>  <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="nf">showWithAster</span><span class="p">()</span> <span class="k">const</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;*&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">str_</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;*&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Print</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">printWeak</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="nf">printStrong</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">PrintBanner</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Print</span><span class="p">,</span> <span class="n">Banner</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">PrintBanner</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">)</span> <span class="o">:</span> <span class="n">Banner</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">{}</span>
	<span class="kt">void</span> <span class="nf">printWeak</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
		<span class="n">showWithParen</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="nf">printStrong</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
		<span class="n">showWithAster</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">auto</span> <span class="n">printBanner</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PrintBanner</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">);</span>
	<span class="n">printBanner</span><span class="o">-&gt;</span><span class="n">printWeak</span><span class="p">();</span>
	<span class="n">printBanner</span><span class="o">-&gt;</span><span class="n">printStrong</span><span class="p">();</span>

	<span class="k">delete</span> <span class="n">printBanner</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="基于委托的适配器模式">基于委托的适配器模式</h3>
<p>另外一种形式是基于委托的模式，这里的“委托”意思是我将本来需要我自己做的事情，交给别人来做，适配器<code>PrintBanner</code>将接口的功能<strong>委托</strong>给<code>Banner</code>去做。</p>
<p>
具体的程序代码如下（与基于继承的代码仅仅在<code>PrintBanner</code>的类中的内容不同）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">PrintBanner</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Print</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">PrintBanner</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&#34;&#34;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">banner_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Banner</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="nf">printWeak</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
		<span class="n">banner_</span><span class="o">-&gt;</span><span class="n">showWithParen</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="nf">printStrong</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
		<span class="n">banner_</span><span class="o">-&gt;</span><span class="n">showWithAster</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="o">~</span><span class="n">PrintBanner</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">banner_</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">delete</span> <span class="n">banner_</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
	<span class="n">Banner</span><span class="o">*</span> <span class="n">banner_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><hr>
<figure><figcaption>
            <h4>欢迎扫码关注我的公众号</h4>
        </figcaption>
</figure>]]></description>
</item><item>
    <title>Iterator模式精解（C&#43;&#43;版本）</title>
    <link>https://bugxch.github.io/dp_1/</link>
    <pubDate>Sat, 10 Apr 2021 22:15:09 &#43;0800</pubDate>
    <author>bugxch</author>
    <guid>https://bugxch.github.io/dp_1/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://pic.imgdb.cn/item/6086d967d1a9ae528f307ce1.jpg" referrerpolicy="no-referrer">
            </div><p>从本文章开始，参考结城浩的<a href="https://www.ituring.com.cn/book/1811" target="_blank" rel="noopener noreffer">《图解设计模式》</a>写23种设计模式的系列介绍文章，结合网络上其他的设计模式的内容，使用C++的语言编写这些设计模式，记录自己的设计模式的心得。</p>
<h2 id="设计模式分类">设计模式分类</h2>
<p>在开始设计模式的系列文章之前，先对设计模式的分类做一个说明，下面的说明摘选自<a href="http://c.biancheng.net/view/1320.html" target="_blank" rel="noopener noreffer">GoF 的 23 种设计模式的分类和功能</a>。</p>
<p>设计模式有两种分类方法，即根据模式的目的来分和根据模式的作用的范围来分。</p>
<h3 id="根据目的来分">根据目的来分</h3>
<p>根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。</p>
<ul>
<li><strong>创建型模式</strong>：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</li>
<li><strong>结构型模式</strong>：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</li>
<li><strong>行为型模式</strong>：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。
###gg 根据作用范围来分
根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。</li>
<li>类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。</li>
<li>对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。</li>
</ul>
<p>一般都选用第一种设计模式的分类方法，总结如下</p>
<p></p>
<h2 id="使用情景">使用情景</h2>
<blockquote>
<p>迭代器模式是一种行为设计模式， 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象内部表示。</p>
</blockquote>
<p>C++中比较典型类似与std的vector的前向迭代器<code>begin()</code>和<code>end()</code>，以及后向迭代器<code>rbegin()</code>和<code>rend()</code>。</p>
<h2 id="问题引入">问题引入</h2>
<p>可以设想元素聚合成集合的方式，最简单的方式是顺序存储的数组或者列表，但是也有例如树、图和其他复杂的数据结构。所以，如果要遍历集合中的元素，有下面的两个问题需要解决：</p>
<ol>
<li>如何在不改变元素的前提下，遍历各种不同的集合？</li>
<li>同一个集合如果有不同的遍历方式（比如树有前中后序3种不同的遍历顺序），如果在不改变集合的前提下，比较容易扩展这些功能呢？</li>
</ol>
<p></p>
<h2 id="解决方案">解决方案</h2>
<p>为了满足开闭原则，我们将定义一个迭代器的类，将迭代从集合种抽象出来，作为一个行为的迭代器处理。如下图所示，对于一个树结构，我们定义了两个迭代器的类，DFS和BFS两个迭代器，这样可以将元素遍历和树本身进行解耦。</p>
<p></p>
<h2 id="uml表示">UML表示</h2>
<p>我们以《图解设计模式》中遍历书架中的书本为例，有如下的UML图</p>
<p></p>
<p>对上面的这幅图做进一步的说明，</p>
<ul>
<li>Aggregate表示集合的接口，书架实现该接口，所以书架必须要有迭代器的方法；</li>
<li>Iterator表示集合的迭代器的接口，书架的迭代器实现它；
需要说明的是，此处的迭代器只有一种前向的迭代器，也可以定义后向遍历的迭代器。</li>
</ul>
<h2 id="c代码">C++代码</h2>
<p>我们使用C++按照上面的UML图片实现这个设计模式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">enum</span> <span class="nc">State</span> <span class="p">{</span>
    <span class="n">RIGHT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">WRONG</span><span class="p">,</span>
    <span class="n">RESERVED</span> <span class="o">=</span> <span class="mi">22</span>
<span class="p">};</span>
<span class="c1">// 书本的类
</span><span class="c1"></span><span class="k">class</span> <span class="nc">Book</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Book</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&#34;&#34;</span><span class="p">)</span> <span class="o">:</span> <span class="n">name_</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">name_</span><span class="p">;</span> <span class="p">};</span>
    <span class="o">~</span><span class="n">Book</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 抽象的迭代器类，包括获得下一本书，以及是否有下一本书的判断
</span><span class="c1"></span><span class="k">class</span> <span class="nc">Iterator</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">Book</span> <span class="n">Next</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">HasNext</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Iterator</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 抽象的聚合类，该类有创建迭代器、取得某个位置的书本，弹出书本，计数，加入书本等功能
</span><span class="c1"></span><span class="k">class</span> <span class="nc">Aggregate</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">Iterator</span><span class="o">*</span> <span class="n">CreateIterator</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">State</span> <span class="nf">getBookAt</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">Book</span><span class="o">&amp;</span> <span class="n">book</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">Count</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Aggregate</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 书架的具体迭代器，实现上面的抽象类的虚函数
</span><span class="c1"></span><span class="k">class</span> <span class="nc">BookShelfIterator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Iterator</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">BookShelfIterator</span><span class="p">(</span><span class="n">Aggregate</span><span class="o">*</span> <span class="n">aggregate</span><span class="p">)</span> <span class="o">:</span> <span class="n">aggregate_</span><span class="p">(</span><span class="n">aggregate</span><span class="p">),</span> <span class="n">loc_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{};</span>
    <span class="o">~</span><span class="n">BookShelfIterator</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">aggregate_</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">delete</span> <span class="n">aggregate_</span><span class="p">;</span>
            <span class="n">aggregate_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">loc_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Book</span> <span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Book</span> <span class="n">book</span><span class="p">;</span>
        <span class="n">aggregate_</span><span class="o">-&gt;</span><span class="n">getBookAt</span><span class="p">(</span><span class="n">loc_</span><span class="p">,</span> <span class="n">book</span><span class="p">);</span>
        <span class="n">loc_</span><span class="o">++</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">book</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">HasNext</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">loc_</span> <span class="o">&lt;</span> <span class="n">aggregate_</span><span class="o">-&gt;</span><span class="n">Count</span><span class="p">();</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">loc_</span><span class="p">;</span>
    <span class="n">Aggregate</span><span class="o">*</span> <span class="n">aggregate_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 具体的聚合类——书架，实现上面的功能
</span><span class="c1"></span><span class="k">class</span> <span class="nc">BookShelf</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Aggregate</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">BookShelf</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">maxSize</span><span class="p">)</span> <span class="o">:</span><span class="n">maxSize_</span><span class="p">(</span><span class="n">maxSize</span><span class="p">),</span> <span class="n">count_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">iterator_</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">books_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">Iterator</span><span class="o">*</span> <span class="nf">CreateIterator</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">iterator_</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">iterator_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BookShelfIterator</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">iterator_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">State</span> <span class="nf">getBookAt</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">Book</span><span class="o">&amp;</span> <span class="n">book</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">count_</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Wrong index</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">WRONG</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">book</span> <span class="o">=</span> <span class="n">books_</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
        <span class="k">return</span> <span class="n">RIGHT</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">Pop</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">books_</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="n">count_</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">Count</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">count_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">Push</span><span class="p">(</span><span class="k">const</span> <span class="n">Book</span><span class="o">&amp;</span> <span class="n">book</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count_</span> <span class="o">==</span> <span class="n">maxSize_</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;bookshelf is full</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">books_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">book</span><span class="p">);</span>
        <span class="n">count_</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">BookShelf</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">iterator_</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">delete</span> <span class="n">iterator_</span><span class="p">;</span>
            <span class="n">iterator_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">maxSize_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">count_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">books_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">maxSize_</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Book</span><span class="o">&gt;</span> <span class="n">books_</span><span class="p">;</span>
    <span class="n">Iterator</span><span class="o">*</span> <span class="n">iterator_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// client
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">BookShelf</span><span class="o">*</span> <span class="n">myShelf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BookShelf</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="n">myShelf</span><span class="o">-&gt;</span><span class="n">Push</span><span class="p">(</span><span class="n">Book</span><span class="p">(</span><span class="s">&#34;《重构》&#34;</span><span class="p">));</span>
	<span class="n">myShelf</span><span class="o">-&gt;</span><span class="n">Push</span><span class="p">(</span><span class="n">Book</span><span class="p">(</span><span class="s">&#34;《图解设计模式》&#34;</span><span class="p">));</span>
	<span class="n">myShelf</span><span class="o">-&gt;</span><span class="n">Push</span><span class="p">(</span><span class="n">Book</span><span class="p">(</span><span class="s">&#34;《黎曼猜想》&#34;</span><span class="p">));</span>

	<span class="n">Iterator</span><span class="o">*</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">myShelf</span><span class="o">-&gt;</span><span class="n">CreateIterator</span><span class="p">();</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;书架上有&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">myShelf</span><span class="o">-&gt;</span><span class="n">Count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;本书：</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">HasNext</span><span class="p">()</span> <span class="o">==</span>  <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">().</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>具体的运行结果如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">书架上有3本书：
《重构》
《图解设计模式》
《黎曼猜想》
</code></pre></td></tr></table>
</div>
</div><h2 id="分析角色">分析角色</h2>
<p>这个模式有实际上由两个角色，<strong>集合以及集合的迭代器</strong>，这两个事物由分为抽象和具体两种。我们所举的例子中</p>
<ul>
<li><code>BookShelf</code>就是具体的集合，它实现自抽象的集合接口<code>Aggregate</code>；</li>
<li><code>BookShelfIterator</code>是具体的迭代器，它实现自抽象的迭代器接口<code>Iterator</code>。
迭代器接口中定义了迭代器的遍历的所有方法，<code>HasNext</code>以及<code>Next</code>。</li>
</ul>
<p>这里需要注意的是，在C++的版本里面集合的接口中不仅定义了创建迭代器的方法<code>CreateIterator</code>，而且定义了集合的个数<code>Count</code>和集合获取当前元素的方法<code>getBookAt</code>，这是因为迭代器中的方法实现依赖这些接口。</p>
<h2 id="扩展修改">扩展修改</h2>
<p>大家可以思考一下为什么我们需要这个模式呢？设计模式的初衷是实现代码的<strong>复用和可扩展</strong>，这个模式体现在哪里呢？</p>
<h3 id="遍历方法和集合本身解耦">遍历方法和集合本身解耦</h3>
<p>迭代器模式的重要作用是<strong>将集合的遍历和实现分离开来</strong>，换句话说，无论实现如何变化，我依然可以使用原来的方法进行遍历，也就是说<strong>遍历这个动作本身</strong>不会因为书架的实现发生变化而变化，所以下面的代码是不变的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">while</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">HasNext</span><span class="p">()</span> <span class="o">==</span>  <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">().</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们依然仅仅依靠<code>HasNext</code>以及<code>Next</code>接口就可以完成对于书架本身的遍历。</p>
<h3 id="遍历需求易于扩展">遍历需求易于扩展</h3>
<p>不妨设想一下，假如我们需要在原来的书架上新增一种遍历方式，从后向前实现后向遍历，这个代码该怎么修改呢？应该完成如下的工作：</p>
<ol>
<li>在原来的书架类中新增后向遍历的iter指针；</li>
<li>书架类中包含创建后向迭代器的方法；</li>
<li>后向迭代器继承自迭代器类别，实现后向迭代器</li>
</ol>
<p>然后就可以继续使用原来的遍历方式遍历集合了，具体的代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp">
<span class="k">enum</span> <span class="nc">State</span> <span class="p">{</span>
    <span class="n">RIGHT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">WRONG</span><span class="p">,</span>
    <span class="n">RESERVED</span> <span class="o">=</span> <span class="mi">22</span>
<span class="p">};</span>
<span class="c1">// concrete book
</span><span class="c1"></span><span class="k">class</span> <span class="nc">Book</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Book</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&#34;&#34;</span><span class="p">)</span> <span class="o">:</span> <span class="n">name_</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">name_</span><span class="p">;</span> <span class="p">};</span>
    <span class="o">~</span><span class="n">Book</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name_</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">class</span> <span class="nc">Iterator</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">Book</span> <span class="n">Next</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">HasNext</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Iterator</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">class</span> <span class="nc">Aggregate</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">Iterator</span><span class="o">*</span> <span class="n">CreateForwardIterator</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">Iterator</span><span class="o">*</span> <span class="nf">CreateBackwardIterator</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">State</span> <span class="nf">getBookAt</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">Book</span><span class="o">&amp;</span> <span class="n">book</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">Count</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Aggregate</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">BookShelfBackwardIterator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Iterator</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">BookShelfBackwardIterator</span><span class="p">(</span><span class="n">Aggregate</span><span class="o">*</span> <span class="n">aggregate</span><span class="p">)</span> <span class="o">:</span> <span class="n">aggregate_</span><span class="p">(</span><span class="n">aggregate</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">loc_</span> <span class="o">=</span> <span class="n">aggregate_</span><span class="o">-&gt;</span><span class="n">Count</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="o">~</span><span class="n">BookShelfBackwardIterator</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">aggregate_</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">aggregate_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">loc_</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Book</span> <span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Book</span> <span class="n">book</span><span class="p">;</span>
        <span class="n">aggregate_</span><span class="o">-&gt;</span><span class="n">getBookAt</span><span class="p">(</span><span class="n">loc_</span><span class="p">,</span> <span class="n">book</span><span class="p">);</span>
        <span class="n">loc_</span><span class="o">--</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">book</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">HasNext</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">loc_</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">loc_</span><span class="p">;</span>
    <span class="n">Aggregate</span><span class="o">*</span> <span class="n">aggregate_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">BookShelfForwardIterator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Iterator</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">BookShelfForwardIterator</span><span class="p">(</span><span class="n">Aggregate</span><span class="o">*</span> <span class="n">aggregate</span><span class="p">)</span> <span class="o">:</span> <span class="n">aggregate_</span><span class="p">(</span><span class="n">aggregate</span><span class="p">),</span> <span class="n">loc_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{};</span>
    <span class="o">~</span><span class="n">BookShelfForwardIterator</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">aggregate_</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">aggregate_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">loc_</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Book</span> <span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Book</span> <span class="n">book</span><span class="p">;</span>
        <span class="n">aggregate_</span><span class="o">-&gt;</span><span class="n">getBookAt</span><span class="p">(</span><span class="n">loc_</span><span class="p">,</span> <span class="n">book</span><span class="p">);</span>
        <span class="n">loc_</span><span class="o">++</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">book</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">HasNext</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">loc_</span> <span class="o">&lt;</span> <span class="n">aggregate_</span><span class="o">-&gt;</span><span class="n">Count</span><span class="p">();</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">loc_</span><span class="p">;</span>
    <span class="n">Aggregate</span><span class="o">*</span> <span class="n">aggregate_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">BookShelf</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Aggregate</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">BookShelf</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">maxSize</span><span class="p">)</span> <span class="o">:</span><span class="n">maxSize_</span><span class="p">(</span><span class="n">maxSize</span><span class="p">),</span> <span class="n">count_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">iterator_</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">backiter_</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">books_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">Iterator</span><span class="o">*</span> <span class="nf">CreateBackwardIterator</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">backiter_</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">backiter_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BookShelfBackwardIterator</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">backiter_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Iterator</span><span class="o">*</span> <span class="nf">CreateForwardIterator</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">iterator_</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">iterator_</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BookShelfForwardIterator</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">iterator_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">State</span> <span class="nf">getBookAt</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">Book</span><span class="o">&amp;</span> <span class="n">book</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">count_</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Wrong index</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">WRONG</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">book</span> <span class="o">=</span> <span class="n">books_</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
        <span class="k">return</span> <span class="n">RIGHT</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">Pop</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">books_</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="n">count_</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="nf">Count</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">count_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">Push</span><span class="p">(</span><span class="k">const</span> <span class="n">Book</span><span class="o">&amp;</span> <span class="n">book</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count_</span> <span class="o">==</span> <span class="n">maxSize_</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;bookshelf is full</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">books_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">book</span><span class="p">);</span>
        <span class="n">count_</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">BookShelf</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">iterator_</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">delete</span> <span class="n">iterator_</span><span class="p">;</span>
            <span class="n">iterator_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">backiter_</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">delete</span> <span class="n">backiter_</span><span class="p">;</span>
            <span class="n">backiter_</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">maxSize_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">count_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">books_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">maxSize_</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">count_</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Book</span><span class="o">&gt;</span> <span class="n">books_</span><span class="p">;</span>
    <span class="n">Iterator</span><span class="o">*</span> <span class="n">iterator_</span><span class="p">;</span>
    <span class="n">Iterator</span><span class="o">*</span> <span class="n">backiter_</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="c1">// book class
</span><span class="c1"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">BookShelf</span><span class="o">*</span> <span class="n">myShelf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BookShelf</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="n">myShelf</span><span class="o">-&gt;</span><span class="n">Push</span><span class="p">(</span><span class="n">Book</span><span class="p">(</span><span class="s">&#34;《重构》&#34;</span><span class="p">));</span>
	<span class="n">myShelf</span><span class="o">-&gt;</span><span class="n">Push</span><span class="p">(</span><span class="n">Book</span><span class="p">(</span><span class="s">&#34;《图解设计模式》&#34;</span><span class="p">));</span>
	<span class="n">myShelf</span><span class="o">-&gt;</span><span class="n">Push</span><span class="p">(</span><span class="n">Book</span><span class="p">(</span><span class="s">&#34;《黎曼猜想》&#34;</span><span class="p">));</span>

	<span class="n">Iterator</span><span class="o">*</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">myShelf</span><span class="o">-&gt;</span><span class="n">CreateForwardIterator</span><span class="p">();</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;前向遍历&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">myShelf</span><span class="o">-&gt;</span><span class="n">Count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;本书：</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">HasNext</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">().</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">iter</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

	<span class="n">iter</span> <span class="o">=</span> <span class="n">myShelf</span><span class="o">-&gt;</span><span class="n">CreateBackwardIterator</span><span class="p">();</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;后向遍历&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">myShelf</span><span class="o">-&gt;</span><span class="n">Count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;本书：</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">HasNext</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">().</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>运行效果如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">前向遍历3本书：
《重构》
《图解设计模式》
《黎曼猜想》
后向遍历3本书：
《黎曼猜想》
《图解设计模式》
《重构》
</code></pre></td></tr></table>
</div>
</div><h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="https://design-patterns.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener noreffer">图说设计模式 — Graphic Design Patterns</a></li>
<li><a href="https://edu.heibai.org/%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.pdf" target="_blank" rel="noopener noreffer">图灵程序设计丛书 图解设计模式</a>，图解设计模式的pdf下载地址</li>
<li><a href="https://refactoringguru.cn/design-patterns/catalog" target="_blank" rel="noopener noreffer">设计模式目录：22种设计模式</a>，乌克兰的某个程序员写的设计模式的网页，非常不错</li>
</ol>
<hr>
<figure><figcaption>
            <h4>欢迎扫码关注我的公众号</h4>
        </figcaption>
</figure>]]></description>
</item><item>
    <title>[转载]表驱动法代码实践</title>
    <link>https://bugxch.github.io/c_driven_table/</link>
    <pubDate>Fri, 22 Jan 2021 08:07:14 &#43;0800</pubDate>
    <author>bugxch</author>
    <guid>https://bugxch.github.io/c_driven_table/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://pic.imgdb.cn/item/600a17e53ffa7d37b3da9d49.jpg" referrerpolicy="no-referrer">
            </div><p>这是一篇转载，点击查看<a href="https://www.cnblogs.com/clover-toeic/p/3730362.html" target="_blank" rel="noopener noreffer">原文链接</a>。</p>
<div class="details admonition quote open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-quote-right fa-fw"></i>引用<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">数据压倒一切。如果选择了正确的数据结构并把一切组织的井井有条，正确的算法就不言自明。编程的核心是数据结构，而不是算法. &ndash; Rob Pike</div>
        </div>
    </div>
<div class="details admonition tip">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw"></i>说明<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">本文基于这样的认识：数据是易变的，逻辑是稳定的。本文例举的编程实现多为代码片段，但不影响描述的完整性。本文例举的编程虽然基于C语言，但其编程思想也适用于其他语言。此外，本文不涉及语言相关的运行效率讨论。</div>
        </div>
    </div>
<h2 id="概念提出">概念提出</h2>
<p>所谓表驱动法(Table-Driven Approach)简而言之就是用查表的方法获取数据。此处的“表”通常为数组，但可视为数据库的一种体现。根据字典中的部首检字表查找读音未知的汉字就是典型的表驱动法，即以每个字的字形为依据，计算出一个索引值，并映射到对应的页数。相比一页一页地顺序翻字典查字，部首检字法效率极高。</p>
<p>具体到编程方面，在数据不多时可用逻辑判断语句(if…else或switch…case)来获取值；但随着数据的增多，逻辑语句会越来越长，此时表驱动法的优势就开始显现。例如，用36进制(A表示10，B表示11，…)表示更大的数字，逻辑判断语句如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">if</span><span class="p">(</span><span class="n">ucNum</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ucNumChar</span> <span class="o">=</span> <span class="n">ConvertToChar</span><span class="p">(</span><span class="n">ucNum</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">ucNum</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ucNumChar</span> <span class="o">=</span> <span class="sc">&#39;A&#39;</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">ucNum</span> <span class="o">==</span> <span class="mi">11</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ucNumChar</span> <span class="o">=</span> <span class="sc">&#39;B&#39;</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">ucNum</span> <span class="o">==</span> <span class="mi">12</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ucNumChar</span> <span class="o">=</span> <span class="sc">&#39;C&#39;</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//... ...
</span><span class="c1"></span><span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">ucNum</span> <span class="o">==</span> <span class="mi">35</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ucNumChar</span> <span class="o">=</span> <span class="sc">&#39;Z&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当然也可以用switch…case结构，但实现都很冗长。而用表驱动法(将numChar存入数组)则非常直观和简洁。如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">CHAR</span> <span class="n">aNumChars</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;0&#39;</span><span class="p">,</span> <span class="sc">&#39;1&#39;</span><span class="p">,</span> <span class="sc">&#39;2&#39;</span><span class="p">,</span> <span class="cm">/*3~9*/</span><span class="sc">&#39;A&#39;</span><span class="p">,</span> <span class="sc">&#39;B&#39;</span><span class="p">,</span> <span class="sc">&#39;C&#39;</span><span class="p">,</span> <span class="cm">/*D~Y*/</span><span class="sc">&#39;Z&#39;</span><span class="p">};</span>
<span class="n">CHAR</span> <span class="n">ucNumChar</span> <span class="o">=</span> <span class="n">aNumChars</span><span class="p">[</span><span class="n">ucNum</span> <span class="o">%</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">aNumChars</span><span class="p">)];</span>
</code></pre></td></tr></table>
</div>
</div><p>像这样直接将变量当作下数组下标来读取数值的方法就是直接查表法。注意，如果熟悉字符串操作，则上述写法可以更简洁：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">CHAR</span> <span class="n">ucNumChar</span> <span class="o">=</span> <span class="s">&#34;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#34;</span><span class="p">[</span><span class="n">ucNum</span><span class="p">];</span>
</code></pre></td></tr></table>
</div>
</div><p>使用表驱动法时需要关注两个问题：一是如何查表，从表中读取正确的数据；二是表里存放什么，如数值或函数指针。前者参见1.1节“查表方式”内容，后者参见1.2节“实战示例”内容。</p>
<h3 id="查表方式">查表方式</h3>
<p>常用的查表方式有直接查找、索引查找和分段查找等。</p>
<h4 id="直接查找">直接查找</h4>
<p>即直接通过数组下标获取到数据。如果熟悉哈希表的话，可以很容易看出这种查表方式就是哈希表的直接访问法。如获取星期名称，逻辑判断语句如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">if</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">ucDay</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pszDayName</span> <span class="o">=</span> <span class="s">&#34;Sunday&#34;</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">ucDay</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pszDayName</span> <span class="o">=</span> <span class="s">&#34;Monday&#34;</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//... ...
</span><span class="c1"></span><span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="mi">6</span> <span class="o">==</span> <span class="n">ucDay</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pszDayName</span> <span class="o">=</span> <span class="s">&#34;Saturday&#34;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>而实现同样的功能，可将这些数据存储到一个表里：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">CHAR</span> <span class="o">*</span><span class="n">paNumChars</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;Sunday&#34;</span><span class="p">,</span> <span class="s">&#34;Monday&#34;</span><span class="p">,</span> <span class="s">&#34;Tuesday&#34;</span><span class="p">,</span> <span class="s">&#34;Wednesday&#34;</span><span class="p">,</span> <span class="s">&#34;Thursday&#34;</span><span class="p">,</span> <span class="s">&#34;Friday&#34;</span><span class="p">,</span>  <span class="s">&#34;Saturday&#34;</span><span class="p">};</span>
<span class="n">CHAR</span> <span class="o">*</span><span class="n">pszDayName</span> <span class="o">=</span> <span class="n">paNumChars</span><span class="p">[</span><span class="n">ucDay</span><span class="p">];</span>
</code></pre></td></tr></table>
</div>
</div><p>类似哈希表特性，表驱动法适用于无需有序遍历数据，且数据量大小可提前预测的情况。对于过于复杂和庞大的判断，可将数据存为文件，需要时加载文件初始化数组，从而在不修改程序的情况下调整里面的数值。</p>
<p>有时，访问之前需要先进行一次键值转换。如表驱动法表示端口忙闲时，需将槽位端口号映射为全局编号。所生成的端口数目大小的数组，其下标对应全局端口编号，元素值表示相应端口的忙闲状态。</p>
<h4 id="索引查找">索引查找</h4>
<p>有时通过一次键值转换，依然无法把数据(如英文单词等)转为键值。此时可将转换的对应关系写到一个索引表里，即索引访问。</p>
<p>如现有100件商品，4位编号，范围从0000到9999。此时只需要申请一个长度为100的数组，且对应2位键值。但将4位的编号转换为2位的键值，可能过于复杂或没有规律，最合适的方法是建立一个保存该转换关系的索引表。采用索引访问既节省内存，又方便维护。比如索引A表示通过名称访问，索引B表示通过编号访问。</p>
<h4 id="分段查找">分段查找</h4>
<p>通过确定数据所处的范围确定分类(下标)。有的数据可分成若干区间，即具有阶梯性，如分数等级。此时可将每个区间的上限(或下限)存到一个表中，将对应的值存到另一表中，通过第一个表确定所处的区段，再由区段下标在第二个表里读取相应数值。注意要留意端点，可用二分法查找，另外可考虑通过索引方法来代替。如根据分数查绩效等级：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#define MAX_GRADE_LEVEL   (INT8U)5
</span><span class="cp"></span><span class="n">DOUBLE</span> <span class="n">aRangeLimit</span><span class="p">[</span><span class="n">MAX_GRADE_LEVEL</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">50.0</span><span class="p">,</span> <span class="mf">60.0</span><span class="p">,</span> <span class="mf">70.0</span><span class="p">,</span> <span class="mf">80.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">};</span>
<span class="n">CHAR</span> <span class="o">*</span><span class="n">paGrades</span><span class="p">[</span><span class="n">MAX_GRADE_LEVEL</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;Fail&#34;</span><span class="p">,</span> <span class="s">&#34;Pass&#34;</span><span class="p">,</span> <span class="s">&#34;Credit&#34;</span><span class="p">,</span> <span class="s">&#34;Distinction&#34;</span><span class="p">,</span> <span class="s">&#34;High Distinction&#34;</span><span class="p">};</span>

<span class="k">static</span> <span class="n">CHAR</span><span class="o">*</span> <span class="nf">EvaluateGrade</span><span class="p">(</span><span class="n">DOUBLE</span> <span class="n">dScore</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">INT8U</span> <span class="n">ucLevel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(;</span> <span class="n">ucLevel</span> <span class="o">&lt;</span> <span class="n">MAX_GRADE_LEVEL</span><span class="p">;</span> <span class="n">ucLevel</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">dScore</span> <span class="o">&lt;</span> <span class="n">aRangeLimit</span><span class="p">[</span><span class="n">ucLevel</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">paGrades</span><span class="p">[</span><span class="n">ucLevel</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">paGrades</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述两张表(数组)也可合并为一张表(结构体数组)，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">DOUBLE</span>  <span class="n">aRangeLimit</span><span class="p">;</span>
    <span class="n">CHAR</span>    <span class="o">*</span><span class="n">pszGrade</span><span class="p">;</span>
<span class="p">}</span><span class="n">T_GRADE_MAP</span><span class="p">;</span>

<span class="n">T_GRADE_MAP</span> <span class="n">gGradeMap</span><span class="p">[</span><span class="n">MAX_GRADE_LEVEL</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="mf">50.0</span><span class="p">,</span>              <span class="s">&#34;Fail&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="mf">60.0</span><span class="p">,</span>              <span class="s">&#34;Pass&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="mf">70.0</span><span class="p">,</span>              <span class="s">&#34;Credit&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="mf">80.0</span><span class="p">,</span>              <span class="s">&#34;Distinction&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="mf">100.0</span><span class="p">,</span>             <span class="s">&#34;High Distinction&#34;</span><span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">CHAR</span><span class="o">*</span> <span class="nf">EvaluateGrade</span><span class="p">(</span><span class="n">DOUBLE</span> <span class="n">dScore</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">INT8U</span> <span class="n">ucLevel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(;</span> <span class="n">ucLevel</span> <span class="o">&lt;</span> <span class="n">MAX_GRADE_LEVEL</span><span class="p">;</span> <span class="n">ucLevel</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">dScore</span> <span class="o">&lt;</span> <span class="n">gGradeMap</span><span class="p">[</span><span class="n">ucLevel</span><span class="p">].</span><span class="n">aRangeLimit</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">gGradeMap</span><span class="p">[</span><span class="n">ucLevel</span><span class="p">].</span><span class="n">pszGrade</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">gGradeMap</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pszGrade</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>该表结构已具备的数据库的雏形，并可扩展支持更为复杂的数据。其查表方式通常为索引查找，偶尔也为分段查找；当索引具有规律性(如连续整数)时，退化为直接查找。</p>
<p>使用分段查找法时应注意边界，将每一分段范围的上界值都考虑在内。找出所有不在最高一级范围内的值，然后把剩下的值全部归入最高一级中。有时需要人为地为最高一级范围添加一个上界。同时应小心不要错误地用“&lt;”来代替“&lt;=”。要保证循环在找出属于最高一级范围内的值后恰当地结束，同时也要保证恰当处理范围边界。</p>
<h3 id="实战示例">实战示例</h3>
<p>本节多数示例取自实际项目。表形式为一维数组、二维数组和结构体数组；表内容有数据、字符串和函数指针。基于表驱动的思想，表形式和表内容可衍生出丰富的组合。</p>
<h4 id="字符统计">字符统计</h4>
<p>问题：统计用户输入的一串数字中每个数字出现的次数。普通解法主体代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">INT32U</span> <span class="n">aDigitCharNum</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="cm">/* 输入字符串中各数字字符出现的次数 */</span>
<span class="n">INT32U</span> <span class="n">dwStrLen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">szDigits</span><span class="p">);</span>

<span class="n">INT32U</span> <span class="n">dwStrIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(;</span> <span class="n">dwStrIdx</span> <span class="o">&lt;</span> <span class="n">dwStrLen</span><span class="p">;</span> <span class="n">dwStrIdx</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">szDigits</span><span class="p">[</span><span class="n">dwStrIdx</span><span class="p">])</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="sc">&#39;1&#39;</span><span class="o">:</span>
            <span class="n">aDigitCharNum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">&#39;2&#39;</span><span class="o">:</span>
            <span class="n">aDigitCharNum</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="c1">//... ...
</span><span class="c1"></span>        <span class="k">case</span> <span class="sc">&#39;9&#39;</span><span class="o">:</span>
            <span class="n">aDigitCharNum</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这种解法的缺点显而易见，既不美观也不灵活。其问题关键在于未将数字字符与数组aDigitCharNum下标直接关联起来。以下示出更简洁的实现方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">for</span><span class="p">(;</span> <span class="n">dwStrIdx</span> <span class="o">&lt;</span> <span class="n">dwStrLen</span><span class="p">;</span> <span class="n">dwStrIdx</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">aDigitCharNum</span><span class="p">[</span><span class="n">szDigits</span><span class="p">[</span><span class="n">dwStrIdx</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述实现考虑到0也为数字字符。该解法也可扩展至统计所有ASCII可见字符。</p>
<h4 id="月天校验">月天校验</h4>
<p>问题：对给定年份和月份的天数进行校验(需区分平年和闰年)。普通解法主体代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">switch</span><span class="p">(</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Month</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
    <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
    <span class="k">case</span> <span class="mi">5</span><span class="o">:</span>
    <span class="k">case</span> <span class="mi">7</span><span class="o">:</span>
    <span class="k">case</span> <span class="mi">8</span><span class="o">:</span>
    <span class="k">case</span> <span class="mi">10</span><span class="o">:</span>
    <span class="k">case</span> <span class="mi">12</span><span class="o">:</span>
        <span class="k">if</span><span class="p">(</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="o">&gt;</span><span class="mi">31</span> <span class="o">||</span> <span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">CtcOamLog</span><span class="p">(</span><span class="n">FUNCTION_Pon</span><span class="p">,</span><span class="s">&#34;Don&#39;t support this Day: %d(1~31)!!!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="p">);</span>
            <span class="n">retcode</span> <span class="o">=</span> <span class="n">S_ERROR</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
        <span class="k">if</span><span class="p">(((</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Year</span><span class="o">%</span><span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Year</span><span class="o">%</span><span class="mi">100</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Year</span><span class="o">%</span><span class="mi">400</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="o">&gt;</span><span class="mi">29</span> <span class="o">||</span> <span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">CtcOamLog</span><span class="p">(</span><span class="n">FUNCTION_Pon</span><span class="p">,</span><span class="s">&#34;Don&#39;t support this Day: %d(1~29)!!!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="p">);</span>
                <span class="n">retcode</span> <span class="o">=</span> <span class="n">S_ERROR</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="o">&gt;</span><span class="mi">28</span> <span class="o">||</span> <span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">CtcOamLog</span><span class="p">(</span><span class="n">FUNCTION_Pon</span><span class="p">,</span><span class="s">&#34;Don&#39;t support this Day: %d(1~28)!!!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="p">);</span>
                <span class="n">retcode</span> <span class="o">=</span> <span class="n">S_ERROR</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">4</span><span class="o">:</span>
    <span class="k">case</span> <span class="mi">6</span><span class="o">:</span>
    <span class="k">case</span> <span class="mi">9</span><span class="o">:</span>
    <span class="k">case</span> <span class="mi">11</span><span class="o">:</span>
        <span class="k">if</span><span class="p">(</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="o">&gt;</span><span class="mi">30</span> <span class="o">||</span> <span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">CtcOamLog</span><span class="p">(</span><span class="n">FUNCTION_Pon</span><span class="p">,</span><span class="s">&#34;Don&#39;t support this Day: %d(1~30)!!!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="p">);</span>
            <span class="n">retcode</span> <span class="o">=</span> <span class="n">S_ERROR</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="n">CtcOamLog</span><span class="p">(</span><span class="n">FUNCTION_Pon</span><span class="p">,</span><span class="s">&#34;Don&#39;t support this Month: %d(1~12)!!!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">OnuTime</span><span class="p">.</span><span class="n">Month</span><span class="p">);</span>
        <span class="n">retcode</span> <span class="o">=</span> <span class="n">S_ERROR</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>以下示出更简洁的实现方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#define MONTH_OF_YEAR 12    </span><span class="cm">/* 一年中的月份数 */</span><span class="cp">
</span><span class="cp"></span>
<span class="cm">/* 闰年：能被4整除且不能被100整除，或能被400整除 */</span>
<span class="cp">#define IS_LEAP_YEAR(year) ((((year) % 4 == 0) &amp;&amp; ((year) % 100 != 0)) || ((year) % 400 == 0))
</span><span class="cp"></span>
<span class="cm">/* 平年中的各月天数，下标对应月份 */</span>
<span class="n">INT8U</span> <span class="n">aDayOfCommonMonth</span><span class="p">[</span><span class="n">MONTH_OF_YEAR</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">31</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">};</span>

<span class="n">INT8U</span> <span class="n">ucMaxDay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">if</span><span class="p">((</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Month</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">IS_LEAP_YEAR</span><span class="p">(</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Year</span><span class="p">)))</span>
    <span class="n">ucMaxDay</span> <span class="o">=</span> <span class="n">aDayOfCommonMonth</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">else</span>
    <span class="n">ucMaxDay</span> <span class="o">=</span> <span class="n">aDayOfCommonMonth</span><span class="p">[</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Month</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>

<span class="k">if</span><span class="p">((</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span> <span class="o">&gt;</span> <span class="n">ucMaxDay</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">CtcOamLog</span><span class="p">(</span><span class="n">FUNCTION_Pon</span><span class="p">,</span><span class="s">&#34;Month %d doesn&#39;t have this Day: %d(1~%d)!!!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span>
              <span class="n">OnuTime</span><span class="p">.</span><span class="n">Month</span><span class="p">,</span> <span class="n">OnuTime</span><span class="p">.</span><span class="n">Day</span><span class="p">,</span> <span class="n">ucMaxDay</span><span class="p">);</span>
    <span class="n">retcode</span> <span class="o">=</span> <span class="n">S_ERROR</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="名称构造">名称构造</h4>
<p>问题：根据WAN接口承载的业务类型(Bitmap)构造业务类型名称字符串。普通解法主体代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">Sub_SetServerType</span><span class="p">(</span><span class="n">INT8U</span> <span class="o">*</span><span class="n">ServerType</span><span class="p">,</span> <span class="n">INT16U</span> <span class="n">wan_servertype</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">wan_servertype</span> <span class="o">&amp;</span> <span class="mh">0x0001</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x0001</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">strcat</span><span class="p">(</span><span class="n">ServerType</span><span class="p">,</span> <span class="s">&#34;_INTERNET&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">wan_servertype</span> <span class="o">&amp;</span> <span class="mh">0x0002</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x0002</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">strcat</span><span class="p">(</span><span class="n">ServerType</span><span class="p">,</span> <span class="s">&#34;_TR069&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">wan_servertype</span> <span class="o">&amp;</span> <span class="mh">0x0004</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x0004</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">strcat</span><span class="p">(</span><span class="n">ServerType</span><span class="p">,</span> <span class="s">&#34;_VOIP&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">wan_servertype</span> <span class="o">&amp;</span> <span class="mh">0x0008</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x0008</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">strcat</span><span class="p">(</span><span class="n">ServerType</span><span class="p">,</span> <span class="s">&#34;_OTHER&#34;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>以下示出C语言中更简洁的实现方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#define  GET_BIT(var, bit)   (((var) &gt;&gt; (bit)) &amp; 0x1)    </span><span class="cm">/* 获取var变量第bit位，编号从右至左 */</span><span class="cp">
</span><span class="cp"></span><span class="k">const</span> <span class="n">CHAR</span><span class="o">*</span> <span class="n">paSvrNames</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#34;_INTERNET&#34;</span><span class="p">,</span> <span class="s">&#34;_TR069&#34;</span><span class="p">,</span> <span class="s">&#34;_VOIP&#34;</span><span class="p">,</span> <span class="s">&#34;_OTHER&#34;</span><span class="p">};</span>
<span class="k">const</span> <span class="n">INT8U</span> <span class="n">ucSvrNameNum</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">paSvrNames</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">paSvrNames</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="n">VOID</span> <span class="nf">SetServerType</span><span class="p">(</span><span class="n">CHAR</span> <span class="o">*</span><span class="n">pszSvrType</span><span class="p">,</span> <span class="n">INT16U</span> <span class="n">wSvrType</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">INT8U</span> <span class="n">ucIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(;</span> <span class="n">ucIdx</span> <span class="o">&lt;</span> <span class="n">ucSvrNameNum</span><span class="p">;</span> <span class="n">ucIdx</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">GET_BIT</span><span class="p">(</span><span class="n">wSvrType</span><span class="p">,</span> <span class="n">ucIdx</span><span class="p">))</span>
            <span class="n">strcat</span><span class="p">(</span><span class="n">pszSvrType</span><span class="p">,</span> <span class="n">paSvrNames</span><span class="p">[</span><span class="n">ucIdx</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>新的实现将数据和逻辑分离，维护起来非常方便。只要逻辑(规则)不变，则唯一可能的改动就是数据(paSvrNames)。</p>
<h4 id="值名解析">值名解析</h4>
<p>问题：根据枚举变量取值输出其对应的字符串，如PORT_FE(1)输出“Fe”。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//值名映射表结构体定义，用于数值解析器
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
   <span class="n">INT32U</span> <span class="n">dwElem</span><span class="p">;</span>    <span class="c1">//待解析数值，通常为枚举变量
</span><span class="c1"></span>   <span class="n">CHAR</span><span class="o">*</span>  <span class="n">pszName</span><span class="p">;</span>   <span class="c1">//指向数值所对应解析名字符串的指针
</span><span class="c1"></span><span class="p">}</span><span class="n">T_NAME_PARSER</span><span class="p">;</span>

<span class="cm">/******************************************************************************
</span><span class="cm">* 函数名称:  NameParser
</span><span class="cm">* 功能说明:  数值解析器，将给定数值转换为对应的具名字符串
</span><span class="cm">* 输入参数:  VOID *pvMap       :值名映射表数组，含T_NAME_PARSER结构体类型元素
</span><span class="cm">                               VOID指针允许用户在保持成员数目和类型不变的前提下，
</span><span class="cm">                               定制更有意义的结构体名和/或成员名。
</span><span class="cm">            INT32U dwEntryNum :值名映射表数组条目数
</span><span class="cm">            INT32U dwElem     :待解析数值，通常为枚举变量
</span><span class="cm">            INT8U* pszDefName :缺省具名字符串指针，可为空
</span><span class="cm">* 输出参数:  NA
</span><span class="cm">* 返回值  :  INT8U *: 数值所对应的具名字符串
</span><span class="cm">            当无法解析给定数值时，若pszDefName为空，则返回数值对应的16进制格式
</span><span class="cm">            字符串；否则返回pszDefName。
</span><span class="cm">******************************************************************************/</span>
<span class="n">INT8U</span> <span class="o">*</span><span class="nf">NameParser</span><span class="p">(</span><span class="n">VOID</span> <span class="o">*</span><span class="n">pvMap</span><span class="p">,</span> <span class="n">INT32U</span> <span class="n">dwEntryNum</span><span class="p">,</span> <span class="n">INT32U</span> <span class="n">dwElem</span><span class="p">,</span> <span class="n">INT8U</span><span class="o">*</span> <span class="n">pszDefName</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">CHECK_SINGLE_POINTER</span><span class="p">(</span><span class="n">pvMap</span><span class="p">,</span> <span class="s">&#34;NullPoniter&#34;</span><span class="p">);</span>

   <span class="n">INT32U</span> <span class="n">dwEntryIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="k">for</span><span class="p">(</span><span class="n">dwEntryIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dwEntryIdx</span> <span class="o">&lt;</span> <span class="n">dwEntryNum</span><span class="p">;</span> <span class="n">dwEntryIdx</span><span class="o">++</span><span class="p">)</span>
   <span class="p">{</span>
       <span class="n">T_NAME_PARSER</span> <span class="o">*</span><span class="n">ptNameParser</span> <span class="o">=</span> <span class="p">(</span><span class="n">T_NAME_PARSER</span> <span class="o">*</span><span class="p">)</span><span class="n">pvMap</span><span class="p">;</span>
       <span class="k">if</span><span class="p">(</span><span class="n">dwElem</span> <span class="o">==</span> <span class="n">ptNameParser</span><span class="o">-&gt;</span><span class="n">dwElem</span><span class="p">)</span>
       <span class="p">{</span>
           <span class="k">return</span> <span class="n">ptNameParser</span><span class="o">-&gt;</span><span class="n">pszName</span><span class="p">;</span>
       <span class="p">}</span>
       <span class="c1">//ANSI标准禁止对void指针进行算法操作；GNU标准则指定void*算法操作与char*一致。
</span><span class="c1"></span>       <span class="c1">//若考虑移植性，可将pvMap类型改为INT8U*，或定义INT8U*局部变量指向pvMap。
</span><span class="c1"></span>       <span class="n">pvMap</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T_NAME_PARSER</span><span class="p">);</span>
   <span class="p">}</span>

   <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">pszDefName</span><span class="p">)</span>
   <span class="p">{</span>
       <span class="k">return</span> <span class="n">pszDefName</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">else</span>
   <span class="p">{</span>
       <span class="k">static</span> <span class="n">INT8U</span> <span class="n">szName</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="c1">//Max:&#34;0xFFFFFFFF&#34;
</span><span class="c1"></span>       <span class="n">sprintf</span><span class="p">(</span><span class="n">szName</span><span class="p">,</span> <span class="s">&#34;0x%X&#34;</span><span class="p">,</span> <span class="n">dwElem</span><span class="p">);</span>
       <span class="k">return</span> <span class="n">szName</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>以下给出NameParser的简单应用示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//UNI端口类型值名映射表结构体定义
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">INT32U</span> <span class="n">dwPortType</span><span class="p">;</span>
    <span class="n">INT8U</span><span class="o">*</span> <span class="n">pszPortName</span><span class="p">;</span>
<span class="p">}</span><span class="n">T_PORT_NAME</span><span class="p">;</span>
<span class="c1">//UNI端口类型解析器
</span><span class="c1"></span><span class="n">T_PORT_NAME</span> <span class="n">gUniNameMap</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="mi">1</span><span class="p">,</span>      <span class="s">&#34;Fe&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">3</span><span class="p">,</span>      <span class="s">&#34;Pots&#34;</span><span class="p">},</span>
    <span class="p">{</span><span class="mi">99</span><span class="p">,</span>     <span class="s">&#34;Vuni&#34;</span><span class="p">}</span>
<span class="p">};</span>
<span class="k">const</span> <span class="n">INT32U</span> <span class="n">UNI_NAM_MAP_NUM</span> <span class="o">=</span> <span class="p">(</span><span class="n">INT32U</span><span class="p">)(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">gUniNameMap</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T_PORT_NAME</span><span class="p">));</span>
<span class="n">VOID</span> <span class="nf">NameParserTest</span><span class="p">(</span><span class="n">VOID</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">INT8U</span> <span class="n">ucTestIndex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;[%s]&lt;Test Case %u&gt; Result: %s!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">,</span> <span class="n">ucTestIndex</span><span class="o">++</span><span class="p">,</span>
           <span class="n">strcmp</span><span class="p">(</span><span class="s">&#34;Unknown&#34;</span><span class="p">,</span> <span class="n">NameParser</span><span class="p">(</span><span class="n">gUniNameMap</span><span class="p">,</span> <span class="n">UNI_NAM_MAP_NUM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;Unknown&#34;</span><span class="p">))</span> <span class="o">?</span> <span class="s">&#34;ERROR&#34;</span> <span class="o">:</span> <span class="s">&#34;OK&#34;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;[%s]&lt;Test Case %u&gt; Result: %s!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">,</span> <span class="n">ucTestIndex</span><span class="o">++</span><span class="p">,</span>
           <span class="n">strcmp</span><span class="p">(</span><span class="s">&#34;DefName&#34;</span><span class="p">,</span> <span class="n">NameParser</span><span class="p">(</span><span class="n">gUniNameMap</span><span class="p">,</span> <span class="n">UNI_NAM_MAP_NUM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&#34;DefName&#34;</span><span class="p">))</span> <span class="o">?</span> <span class="s">&#34;ERROR&#34;</span> <span class="o">:</span> <span class="s">&#34;OK&#34;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;[%s]&lt;Test Case %u&gt; Result: %s!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">,</span> <span class="n">ucTestIndex</span><span class="o">++</span><span class="p">,</span>
           <span class="n">strcmp</span><span class="p">(</span><span class="s">&#34;Fe&#34;</span><span class="p">,</span> <span class="n">NameParser</span><span class="p">(</span><span class="n">gUniNameMap</span><span class="p">,</span> <span class="n">UNI_NAM_MAP_NUM</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#34;Unknown&#34;</span><span class="p">))</span> <span class="o">?</span> <span class="s">&#34;ERROR&#34;</span> <span class="o">:</span> <span class="s">&#34;OK&#34;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;[%s]&lt;Test Case %u&gt; Result: %s!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">,</span> <span class="n">ucTestIndex</span><span class="o">++</span><span class="p">,</span>
           <span class="n">strcmp</span><span class="p">(</span><span class="s">&#34;Pots&#34;</span><span class="p">,</span> <span class="n">NameParser</span><span class="p">(</span><span class="n">gUniNameMap</span><span class="p">,</span> <span class="n">UNI_NAM_MAP_NUM</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&#34;Unknown&#34;</span><span class="p">))</span> <span class="o">?</span> <span class="s">&#34;ERROR&#34;</span> <span class="o">:</span> <span class="s">&#34;OK&#34;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;[%s]&lt;Test Case %u&gt; Result: %s!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">,</span> <span class="n">ucTestIndex</span><span class="o">++</span><span class="p">,</span>
           <span class="n">strcmp</span><span class="p">(</span><span class="s">&#34;Vuni&#34;</span><span class="p">,</span> <span class="n">NameParser</span><span class="p">(</span><span class="n">gUniNameMap</span><span class="p">,</span> <span class="n">UNI_NAM_MAP_NUM</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">?</span> <span class="s">&#34;ERROR&#34;</span> <span class="o">:</span> <span class="s">&#34;OK&#34;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;[%s]&lt;Test Case %u&gt; Result: %s!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">,</span> <span class="n">ucTestIndex</span><span class="o">++</span><span class="p">,</span>
           <span class="n">strcmp</span><span class="p">(</span><span class="s">&#34;Unknown&#34;</span><span class="p">,</span> <span class="n">NameParser</span><span class="p">(</span><span class="n">gUniNameMap</span><span class="p">,</span> <span class="n">UNI_NAM_MAP_NUM</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="s">&#34;Unknown&#34;</span><span class="p">))</span> <span class="o">?</span> <span class="s">&#34;ERROR&#34;</span> <span class="o">:</span> <span class="s">&#34;OK&#34;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;[%s]&lt;Test Case %u&gt; Result: %s!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">,</span> <span class="n">ucTestIndex</span><span class="o">++</span><span class="p">,</span>
           <span class="n">strcmp</span><span class="p">(</span><span class="s">&#34;0xABCD&#34;</span><span class="p">,</span> <span class="n">NameParser</span><span class="p">(</span><span class="n">gUniNameMap</span><span class="p">,</span> <span class="n">UNI_NAM_MAP_NUM</span><span class="p">,</span> <span class="mh">0xABCD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">?</span> <span class="s">&#34;ERROR&#34;</span> <span class="o">:</span> <span class="s">&#34;OK&#34;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;[%s]&lt;Test Case %u&gt; Result: %s!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">__FUNCTION__</span><span class="p">,</span> <span class="n">ucTestIndex</span><span class="o">++</span><span class="p">,</span>
           <span class="n">strcmp</span><span class="p">(</span><span class="s">&#34;NullPoniter&#34;</span><span class="p">,</span> <span class="n">NameParser</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">UNI_NAM_MAP_NUM</span><span class="p">,</span> <span class="mh">0xABCD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="o">?</span> <span class="s">&#34;ERROR&#34;</span> <span class="o">:</span> <span class="s">&#34;OK&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>gUniNameMap</code>在实际项目中有十余个条目，若采用逻辑链实现将非常冗长。</p>
<h4 id="取值映射">取值映射</h4>
<p>问题：不同模块间同一参数枚举值取值可能有所差异，需要适配。此处不再给出普通的switch…case或if…else if…else结构，而直接示出以下表驱动实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">PORTSTATE</span> <span class="n">loopMEState</span><span class="p">;</span>
    <span class="n">PORTSTATE</span> <span class="n">loopMIBState</span><span class="p">;</span>
<span class="p">}</span><span class="n">LOOPMAPSTRUCT</span><span class="p">;</span>

<span class="k">static</span> <span class="n">LOOPMAPSTRUCT</span> <span class="n">s_CesLoop</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="n">NO_LOOP</span><span class="p">,</span>                  <span class="n">e_ds1_looptype_noloop</span><span class="p">},</span>
    <span class="p">{</span><span class="n">PAYLOAD_LOOP</span><span class="p">,</span>             <span class="n">e_ds1_looptype_PayloadLoop</span><span class="p">},</span>
    <span class="p">{</span><span class="n">LINE_LOOP</span><span class="p">,</span>                <span class="n">e_ds1_looptype_LineLoop</span><span class="p">},</span>
    <span class="p">{</span><span class="n">PON_LOOP</span><span class="p">,</span>                 <span class="n">e_ds1_looptype_OtherLoop</span><span class="p">},</span>
    <span class="p">{</span><span class="n">CES_LOOP</span><span class="p">,</span>                 <span class="n">e_ds1_looptype_InwardLoop</span><span class="p">}};</span>

<span class="n">PORTSTATE</span> <span class="nf">ConvertLoopMEStateToMIBState</span><span class="p">(</span><span class="n">PORTSTATE</span> <span class="n">vPortState</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">INT32U</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ii</span><span class="p">;</span>

    <span class="n">num</span> <span class="o">=</span> <span class="n">ARRAY_NUM</span><span class="p">(</span><span class="n">s_CesLoop</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">ii</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">vPortState</span> <span class="o">==</span> <span class="n">s_CesLoop</span><span class="p">[</span><span class="n">ii</span><span class="p">].</span><span class="n">loopMEState</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">s_CesLoop</span><span class="p">[</span><span class="n">ii</span><span class="p">].</span><span class="n">loopMIBState</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">e_ds1_looptype_noloop</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>相应地，从loopMIBState映射到loopMEState需要定义一个ConvertLoopMIBStateToMEState函数。更进一步，所有类似的一对一映射关系都必须如上的映射(转换)函数，相当繁琐。事实上，从抽象层面看，该映射关系非常简单。提取共性后定义带参数宏，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cm">/**********************************************************
</span><span class="cm">* 功能描述：进行二维数组映射表的一对一映射，用于参数适配
</span><span class="cm">* 参数说明：map        -- 二维数组映射表
</span><span class="cm">            elemSrc    -- 映射源，即待映射的元素值
</span><span class="cm">            elemDest   -- 映射源对应的映射结果
</span><span class="cm">            direction  -- 映射方向字节，表示从数组哪列映射至哪列。
</span><span class="cm">                          高4位对应映射源列，低4位对应映射结果列。
</span><span class="cm">            defaultVal -- 映射失败时置映射结果为缺省值
</span><span class="cm">* 示例：    ARRAY_MAPPER(gCesLoopMap, 3, ucLoop, 0x10, NO_LOOP);
</span><span class="cm">            则ucLoop = 2(LINE_LOOP)
</span><span class="cm">**********************************************************/</span>
<span class="cp">#define ARRAY_MAPPER(map, elemSrc, elemDest, direction, defaultVal) do{\
</span><span class="cp">    INT8U ucMapIdx = 0, ucMapNum = 0; \
</span><span class="cp">    ucMapNum = sizeof(map)/sizeof(map[0]); \
</span><span class="cp">    for(ucMapIdx = 0; ucMapIdx &lt; ucMapNum; ucMapIdx++) \
</span><span class="cp">    { \
</span><span class="cp">        if((elemSrc) == map[ucMapIdx][((direction)&amp;0xF0)&gt;&gt;4]) \
</span><span class="cp">        { \
</span><span class="cp">            elemDest = map[ucMapIdx][(direction)&amp;0x0F]; \
</span><span class="cp">            break; \
</span><span class="cp">        } \
</span><span class="cp">    } \
</span><span class="cp">    if(ucMapIdx == ucMapNum) \
</span><span class="cp">    { \
</span><span class="cp">        elemDest = (defaultVal); \
</span><span class="cp">    } \
</span><span class="cp">}while(0)
</span></code></pre></td></tr></table>
</div>
</div><p>参数取值转换时直接调用统一的映射器宏，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">static</span> <span class="n">INT8U</span> <span class="n">gCesLoopMap</span><span class="p">[][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
   <span class="p">{</span><span class="n">NO_LOOP</span><span class="p">,</span>                  <span class="n">e_ds1_looptype_noloop</span><span class="p">},</span>
   <span class="p">{</span><span class="n">PAYLOAD_LOOP</span><span class="p">,</span>             <span class="n">e_ds1_looptype_PayloadLoop</span><span class="p">},</span>
   <span class="p">{</span><span class="n">LINE_LOOP</span><span class="p">,</span>                <span class="n">e_ds1_looptype_LineLoop</span><span class="p">},</span>
   <span class="p">{</span><span class="n">PON_LOOP</span><span class="p">,</span>                 <span class="n">e_ds1_looptype_OtherLoop</span><span class="p">},</span>
   <span class="p">{</span><span class="n">CES_LOOP</span><span class="p">,</span>                 <span class="n">e_ds1_looptype_InwardLoop</span><span class="p">}};</span>

<span class="n">ARRAY_MAPPER</span><span class="p">(</span><span class="n">gCesLoopMap</span><span class="p">,</span> <span class="n">tPara</span><span class="p">.</span><span class="n">dwParaVal</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dwLoopConf</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="n">e_ds1_looptype_noloop</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>另举一例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#define  CES_DEFAULT_JITTERBUF        (INT32U)2000   </span><span class="cm">/* 默认jitterbuf为2000us，而1帧=125us */</span><span class="cp">
</span><span class="cp">#define  CES_JITTERBUF_STEP           (INT32U)125    </span><span class="cm">/* jitterbuf步长为125us，即1帧 */</span><span class="cp">
</span><span class="cp">#define  CES_DEFAULT_QUEUESIZE        (INT32U)5
</span><span class="cp">#define  CES_DEFAULT_MAX_QUEUESIZE    (INT32U)7
</span><span class="cp"></span>
<span class="cp">#define  ARRAY_NUM(array)             (sizeof(array) / sizeof((array)[0]))  </span><span class="cm">/* 数组元素个数 */</span><span class="cp">
</span><span class="cp"></span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
   <span class="n">INT32U</span>  <span class="n">dwJitterBuffer</span><span class="p">;</span>
   <span class="n">INT32U</span>  <span class="n">dwFramePerPkt</span><span class="p">;</span>
   <span class="n">INT32U</span>  <span class="n">dwQueueSize</span><span class="p">;</span>
<span class="p">}</span><span class="n">QUEUE_SIZE_MAP</span><span class="p">;</span>
<span class="cm">/* gCesQueueSizeMap也可以(JitterBuffer / FramePerPkt)值为索引，更加紧凑 */</span>
<span class="k">static</span> <span class="n">QUEUE_SIZE_MAP</span> <span class="n">gCesQueueSizeMap</span><span class="p">[]</span><span class="o">=</span> <span class="p">{</span>
      <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">},</span>  <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">},</span>  <span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">},</span>  <span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span>  <span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">},</span>  <span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span>  <span class="p">{</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span>  <span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span>  <span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span>  <span class="p">{</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span>  <span class="p">{</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span>  <span class="p">{</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span>  <span class="p">{</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span>  <span class="p">{</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span>  <span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">11</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">11</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">12</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">12</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">13</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">13</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">14</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">14</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">15</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">15</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">16</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">17</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">17</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">18</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">18</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">19</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">19</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">20</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">20</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">21</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">21</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">22</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">22</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">23</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">23</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">24</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">24</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">25</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">25</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">26</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">26</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">27</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">27</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">28</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">28</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">29</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">29</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">30</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">30</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span>
      <span class="p">{</span><span class="mi">31</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">31</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">},</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">}};</span>
<span class="cm">/**********************************************************
</span><span class="cm">* 函数名称： CalcQueueSize
</span><span class="cm">* 功能描述： 根据JitterBuffer和FramePerPkt计算QueueSize
</span><span class="cm">* 注意事项： 配置的最大缓存深度
</span><span class="cm">*            = 2 * JitterBuffer / FramePerPkt
</span><span class="cm">*            = 2 * N Packet = 2 ^ QueueSize
</span><span class="cm">*            JitterBuffer为125us帧速率的倍数，
</span><span class="cm">*            FramePerPkt为每个分组的帧数，
</span><span class="cm">*            QueueSize向上取整，最大为7。
</span><span class="cm">**********************************************************/</span>
<span class="n">INT32U</span> <span class="nf">CalcQueueSize</span><span class="p">(</span><span class="n">INT32U</span> <span class="n">dwJitterBuffer</span><span class="p">,</span> <span class="n">INT32U</span> <span class="n">dwFramePerPkt</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">INT8U</span> <span class="n">ucIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ucNum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

   <span class="c1">//本函数暂时仅考虑E1
</span><span class="c1"></span>   <span class="n">ucNum</span> <span class="o">=</span> <span class="n">ARRAY_NUM</span><span class="p">(</span><span class="n">gCesQueueSizeMap</span><span class="p">);</span>
   <span class="k">for</span><span class="p">(</span><span class="n">ucIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ucIdx</span> <span class="o">&lt;</span> <span class="n">ucNum</span><span class="p">;</span> <span class="n">ucIdx</span><span class="o">++</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="k">if</span><span class="p">((</span><span class="n">dwJitterBuffer</span> <span class="o">==</span> <span class="n">gCesQueueSizeMap</span><span class="p">[</span><span class="n">ucIdx</span><span class="p">].</span><span class="n">dwJitterBuffer</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
         <span class="p">(</span><span class="n">dwFramePerPkt</span> <span class="o">==</span> <span class="n">gCesQueueSizeMap</span><span class="p">[</span><span class="n">ucIdx</span><span class="p">].</span><span class="n">dwFramePerPkt</span><span class="p">))</span>
      <span class="p">{</span>
           <span class="k">return</span> <span class="n">gCesQueueSizeMap</span><span class="p">[</span><span class="n">ucIdx</span><span class="p">].</span><span class="n">dwQueueSize</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>

   <span class="k">return</span> <span class="n">CES_DEFAULT_MAX_QUEUESIZE</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="版本控制">版本控制</h4>
<p>问题：控制OLT与ONU之间的版本协商。ONU本地设置三比特控制字，其中bit2(MSB)~bit0(LSB)分别对应0x21、0x30和0xAA版本号；且bitX为0表示上报对应版本号，bitX为1表示不上报对应版本号。其他版本号如0x20、0x13和0x1必须上报，即不受控制。最初的实现采用if…else if…else结构，代码非常冗长，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">ucLength</span> <span class="o">=</span> <span class="mh">0x1f</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">gOamCtrlCode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">,</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x30</span><span class="p">;</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x21</span><span class="p">;</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">8</span><span class="p">]),</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">12</span><span class="p">]),</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x13</span><span class="p">;</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">16</span><span class="p">]),</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">20</span><span class="p">]),</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">23</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xaa</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">gOamCtrlCode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">,</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x30</span><span class="p">;</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x21</span><span class="p">;</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">8</span><span class="p">]),</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">12</span><span class="p">]),</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x13</span><span class="p">;</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">16</span><span class="p">]),</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//此处省略gOamCtrlCode == 2~6的处理代码
</span><span class="c1"></span><span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">gOamCtrlCode</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">),</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x13</span><span class="p">;</span>
    <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">8</span><span class="p">]),</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>以下示出C语言中更简洁的实现方式(基于二维数组)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cm">/**********************************************************************
</span><span class="cm">* 版本控制字数组定义
</span><span class="cm">* gOamCtrlCode:   Bitmap控制字。Bit-X为0时上报对应版本，Bit-X为1时屏蔽对应版本。
</span><span class="cm">* CTRL_VERS_NUM:  可控版本个数。
</span><span class="cm">* CTRL_CODE_NUM:  控制字个数。与CTRL_VERS_NUM有关。
</span><span class="cm">* gOamVerCtrlMap: 版本控制字数组。行对应控制字，列对应可控版本。
</span><span class="cm">                  元素值为0时不上报对应版本，元素值非0时上报该元素值。
</span><span class="cm">* Note: 该数组旨在实现“数据与控制隔离”。后续若要新增可控版本，只需修改
</span><span class="cm">                  -- CTRL_VERS_NUM
</span><span class="cm">                  -- gOamVerCtrlMap新增行(控制字)
</span><span class="cm">                  -- gOamVerCtrlMap新增列(可控版本)
</span><span class="cm">**********************************************************************/</span>
<span class="cp">#define CTRL_VERS_NUM    3
</span><span class="cp">#define CTRL_CODE_NUM    (1&lt;&lt;CTRL_VERS_NUM)
</span><span class="cp"></span><span class="n">u8_t</span> <span class="n">gOamVerCtrlMap</span><span class="p">[</span><span class="n">CTRL_CODE_NUM</span><span class="p">][</span><span class="n">CTRL_VERS_NUM</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
 <span class="cm">/* Ver21         Ver30        VerAA */</span>
    <span class="p">{</span><span class="mh">0x21</span><span class="p">,</span>         <span class="mh">0x30</span><span class="p">,</span>        <span class="mh">0xaa</span><span class="p">},</span>    <span class="cm">/*gOamCtrlCode = 0*/</span>
    <span class="p">{</span><span class="mh">0x21</span><span class="p">,</span>         <span class="mh">0x30</span><span class="p">,</span>          <span class="mi">0</span> <span class="p">},</span>    <span class="cm">/*gOamCtrlCode = 1*/</span>
    <span class="p">{</span><span class="mh">0x21</span><span class="p">,</span>           <span class="mi">0</span><span class="p">,</span>         <span class="mh">0xaa</span><span class="p">},</span>    <span class="cm">/*gOamCtrlCode = 2*/</span>
    <span class="p">{</span><span class="mh">0x21</span><span class="p">,</span>           <span class="mi">0</span><span class="p">,</span>           <span class="mi">0</span> <span class="p">},</span>    <span class="cm">/*gOamCtrlCode = 3*/</span>
    <span class="p">{</span>  <span class="mi">0</span><span class="p">,</span>          <span class="mh">0x30</span><span class="p">,</span>        <span class="mh">0xaa</span><span class="p">},</span>    <span class="cm">/*gOamCtrlCode = 4*/</span>
    <span class="p">{</span>  <span class="mi">0</span><span class="p">,</span>          <span class="mh">0x30</span><span class="p">,</span>          <span class="mi">0</span> <span class="p">},</span>    <span class="cm">/*gOamCtrlCode = 5*/</span>
    <span class="p">{</span>  <span class="mi">0</span><span class="p">,</span>            <span class="mi">0</span><span class="p">,</span>         <span class="mh">0xaa</span><span class="p">},</span>    <span class="cm">/*gOamCtrlCode = 6*/</span>
    <span class="p">{</span>  <span class="mi">0</span><span class="p">,</span>            <span class="mi">0</span><span class="p">,</span>           <span class="mi">0</span> <span class="p">}</span>     <span class="cm">/*gOamCtrlCode = 7*/</span>
<span class="p">};</span>
<span class="cp">#define INFO_TYPE_VERS_LEN    7  </span><span class="cm">/* InfoType + Length + OUI + ExtSupport + Version */</span><span class="cp">
</span><span class="cp"></span>
<span class="n">u8_t</span> <span class="n">verIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">u8_t</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="n">verIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">verIdx</span> <span class="o">&lt;</span> <span class="n">CTRL_VERS_NUM</span><span class="p">;</span> <span class="n">verIdx</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">gOamVerCtrlMap</span><span class="p">[</span><span class="n">gOamCtrlCode</span><span class="p">][</span><span class="n">verIdx</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
        <span class="n">index</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
        <span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">gOamVerCtrlMap</span><span class="p">[</span><span class="n">gOamCtrlCode</span><span class="p">][</span><span class="n">verIdx</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">index</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>
<span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">index</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x13</span><span class="p">;</span>
<span class="n">vosMemCpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">ctc_oui</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">index</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">aucVersionList</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x01</span><span class="p">;</span>

<span class="n">pstSendTlv</span><span class="o">-&gt;</span><span class="n">ucLength</span> <span class="o">=</span> <span class="n">INFO_TYPE_VERS_LEN</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="消息处理">消息处理</h4>
<p>问题：终端输入不同的打印命令，调用相应的打印函数，以控制不同级别的打印。</p>
<p>这是一段消息(事件)驱动程序。本模块接收其他模块(如串口驱动)发送的消息，根据消息中的打印级别字符串和开关模式，调用不同函数进行处理。常见的实现方法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">logall</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">g_log_control</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">noanylog</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">g_log_control</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">logOam</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">g_log_control</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="n">FUNCTION_Oam</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">nologOam</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">g_log_control</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x01</span> <span class="o">&lt;&lt;</span> <span class="n">FUNCTION_Oam</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//... ...
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">logExec</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">INT8U</span> <span class="n">enable</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">CtcOamLog</span><span class="p">(</span><span class="n">FUNCTION_Oam</span><span class="p">,</span><span class="s">&#34;log %s %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">enable</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">enable</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="cm">/*log*/</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="s">&#34;all&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/*字符串比较，不区分大小写*/</span>
            <span class="n">logall</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="s">&#34;oam&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">logOam</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="s">&#34;pon&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">logPon</span><span class="p">();</span>
        <span class="c1">//... ...
</span><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="s">&#34;version&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">logVersion</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">enable</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="cm">/*nolog*/</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="s">&#34;all&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">noanylog</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="s">&#34;oam&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">nologOam</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="s">&#34;pon&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">nologPon</span><span class="p">();</span>
        <span class="c1">//... ...
</span><span class="c1"></span>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="s">&#34;version&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">nologVersion</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;bad log para</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>以下示出C语言中更简洁的实现方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">OAM_LOG_OFF</span> <span class="o">=</span> <span class="p">(</span><span class="n">INT8U</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">OAM_LOG_ON</span>  <span class="o">=</span> <span class="p">(</span><span class="n">INT8U</span><span class="p">)</span><span class="mi">1</span>
<span class="p">}</span><span class="n">E_OAM_LOG_MODE</span><span class="p">;</span>
<span class="k">typedef</span> <span class="nf">FUNC_STATUS</span> <span class="p">(</span><span class="o">*</span><span class="n">OamLogHandler</span><span class="p">)(</span><span class="n">VOID</span><span class="p">);</span>
<span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="n">CHAR</span>           <span class="o">*</span><span class="n">pszLogCls</span><span class="p">;</span>    <span class="cm">/* 打印级别 */</span>
    <span class="n">E_OAM_LOG_MODE</span> <span class="n">eLogMode</span><span class="p">;</span>      <span class="cm">/* 打印模式 */</span>
    <span class="n">OamLogHandler</span>  <span class="n">fnLogHandler</span><span class="p">;</span>  <span class="cm">/* 打印函数 */</span>
<span class="p">}</span><span class="n">T_OAM_LOG_MAP</span><span class="p">;</span>

<span class="n">T_OAM_LOG_MAP</span> <span class="n">gOamLogMap</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">&#34;all&#34;</span><span class="p">,</span>         <span class="n">OAM_LOG_OFF</span><span class="p">,</span>       <span class="n">noanylog</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;oam&#34;</span><span class="p">,</span>         <span class="n">OAM_LOG_OFF</span><span class="p">,</span>       <span class="n">nologOam</span><span class="p">},</span>
    <span class="c1">//... ...
</span><span class="c1"></span>    <span class="p">{</span><span class="s">&#34;version&#34;</span><span class="p">,</span>     <span class="n">OAM_LOG_OFF</span><span class="p">,</span>       <span class="n">nologVersion</span><span class="p">},</span>

    <span class="p">{</span><span class="s">&#34;all&#34;</span><span class="p">,</span>         <span class="n">OAM_LOG_ON</span><span class="p">,</span>        <span class="n">logall</span><span class="p">},</span>
    <span class="p">{</span><span class="s">&#34;oam&#34;</span><span class="p">,</span>         <span class="n">OAM_LOG_ON</span><span class="p">,</span>        <span class="n">logOam</span><span class="p">},</span>
    <span class="c1">//... ...
</span><span class="c1"></span>    <span class="p">{</span><span class="s">&#34;version&#34;</span><span class="p">,</span>     <span class="n">OAM_LOG_ON</span><span class="p">,</span>        <span class="n">logVersion</span><span class="p">}</span>
<span class="p">};</span>
<span class="n">INT32U</span> <span class="n">gOamLogMapNum</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">gOamLogMap</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T_OAM_LOG_MAP</span><span class="p">);</span>

<span class="n">VOID</span> <span class="nf">logExec</span><span class="p">(</span><span class="n">CHAR</span> <span class="o">*</span><span class="n">pszName</span><span class="p">,</span> <span class="n">INT8U</span> <span class="n">ucSwitch</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">INT8U</span> <span class="n">ucIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(;</span> <span class="n">ucIdx</span> <span class="o">&lt;</span> <span class="n">gOamLogMapNum</span><span class="p">;</span> <span class="n">ucIdx</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">((</span><span class="n">ucSwitch</span> <span class="o">==</span> <span class="n">gOamLogMap</span><span class="p">[</span><span class="n">ucIdx</span><span class="p">].</span><span class="n">eLogMode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
           <span class="p">(</span><span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">pszName</span><span class="p">,</span> <span class="n">gOamLogMap</span><span class="p">[</span><span class="n">ucIdx</span><span class="p">].</span><span class="n">pszLogCls</span><span class="p">));</span>
        <span class="p">{</span>
            <span class="n">gOamLogMap</span><span class="p">[</span><span class="n">ucIdx</span><span class="p">].</span><span class="n">fnLogHandler</span><span class="p">();</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ucIdx</span> <span class="o">==</span> <span class="n">gOamLogMapNum</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Unknown LogClass(%s) or LogMode(%d)!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">pszName</span><span class="p">,</span> <span class="n">ucSwitch</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这种表驱动消息处理实现的优点如下：</p>
<ul>
<li>增强可读性，消息如何处理从表中一目了然。</li>
<li>增强可扩展性。更容易修改，要增加新的消息，只要修改数据即可，不需要修改流程。</li>
<li>降低复杂度。通过把程序逻辑的复杂度转移到人类更容易处理的数据中来，从而达到控制复杂度的目标。</li>
<li>主干清晰，代码重用。
若各索引为顺序枚举值，则建立多维数组(每维对应一个索引)，根据下标直接定位到处理函数，效率会更高。</li>
</ul>
<p>注意，考虑到本节实例中logOam/logPon或nologOam/nologPon等函数本质上是基于打印级别的比特操作，因此可进一步简化。以下例举其相似实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cm">/* 日志控制类型定义 */</span>
<span class="k">typedef</span> <span class="k">enum</span>
<span class="p">{</span>
    <span class="n">LOG_NORM</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>        <span class="cm">/* 未分类日志，可用于通用日志 */</span>
    <span class="n">LOG_FRM</span><span class="p">,</span>             <span class="cm">/* Frame，OMCI帧日志 */</span>
    <span class="n">LOG_PON</span><span class="p">,</span>             <span class="cm">/* Pon，光链路相关日志 */</span>
    <span class="n">LOG_ETH</span><span class="p">,</span>             <span class="cm">/* Ethernet，Layer2以太网日志 */</span>
    <span class="n">LOG_NET</span><span class="p">,</span>             <span class="cm">/* Internet，Layer3网络日志 */</span>
    <span class="n">LOG_MULT</span><span class="p">,</span>            <span class="cm">/* Multicast，组播日志 */</span>
    <span class="n">LOG_QOS</span><span class="p">,</span>             <span class="cm">/* QOS，流量日志 */</span>
    <span class="n">LOG_CES</span><span class="p">,</span>             <span class="cm">/* Ces，TDM电路仿真日志 */</span>
    <span class="n">LOG_VOIP</span><span class="p">,</span>            <span class="cm">/* Voip，语音日志 */</span>
    <span class="n">LOG_ALM</span><span class="p">,</span>             <span class="cm">/* Alarm，告警日志 */</span>
    <span class="n">LOG_PERF</span><span class="p">,</span>            <span class="cm">/* Performance，性能统计日志 */</span>
    <span class="n">LOG_VER</span><span class="p">,</span>             <span class="cm">/* Version，软件升级日志 */</span>
    <span class="n">LOG_XDSL</span><span class="p">,</span>            <span class="cm">/* xDsl日志 */</span>
    <span class="n">LOG_DB</span><span class="p">,</span>              <span class="cm">/* 数据库操作日志 */</span>
    <span class="c1">//新日志类型在此处扩展，共支持32种日志类型
</span><span class="c1"></span>    <span class="n">LOG_ALL</span> <span class="o">=</span> <span class="n">UINT_MAX</span>   <span class="cm">/* 所有日志类型 */</span>
<span class="p">}</span><span class="n">E_LOG_TYPE</span><span class="p">;</span>

<span class="cm">/*****************************************************************************
</span><span class="cm"> * 变量名称：gOmciLogCtrl
</span><span class="cm"> * 作用描述：OMCI日志控制字，BitMap格式(比特编号从LSB至MSB依次为Bit0-&gt;BitN)。
</span><span class="cm"> *           Bit0~N分别对应E_LOG_TYPE各枚举值(除LOG_ALL外)。
</span><span class="cm"> *           BitX为0时关闭日志类型对应的日志功能，BitX为1时则予以打开。
</span><span class="cm"> * 变量范围：该变量为四字节整型静态全局变量，即支持32种日志类型。
</span><span class="cm"> * 访问说明：通过GetOmciLogCtrl/SetOmciLogCtrl/OmciLogCtrl函数访问/设置控制字。
</span><span class="cm"> *****************************************************************************/</span>
<span class="k">static</span> <span class="n">INT32U</span> <span class="n">gOmciLogCtrl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">//日志类型字符串数组，下标为各字符串所对应的日志类型枚举值。
</span><span class="c1"></span><span class="k">static</span> <span class="k">const</span> <span class="n">INT8U</span><span class="o">*</span> <span class="n">paLogTypeName</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#34;Norm&#34;</span><span class="p">,</span>        <span class="s">&#34;Frame&#34;</span><span class="p">,</span>   <span class="s">&#34;Pon&#34;</span><span class="p">,</span>  <span class="s">&#34;Ethernet&#34;</span><span class="p">,</span>  <span class="s">&#34;Internet&#34;</span><span class="p">,</span>
    <span class="s">&#34;Multicast&#34;</span><span class="p">,</span>   <span class="s">&#34;Qos&#34;</span><span class="p">,</span>     <span class="s">&#34;Ces&#34;</span><span class="p">,</span>  <span class="s">&#34;Voip&#34;</span><span class="p">,</span>      <span class="s">&#34;Alarm&#34;</span><span class="p">,</span>
    <span class="s">&#34;Performance&#34;</span><span class="p">,</span> <span class="s">&#34;Version&#34;</span><span class="p">,</span> <span class="s">&#34;Xdsl&#34;</span><span class="p">,</span>  <span class="s">&#34;Db&#34;</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">INT8U</span>  <span class="n">ucLogTypeNameNum</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">paLogTypeName</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">paLogTypeName</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="k">static</span> <span class="n">VOID</span> <span class="nf">SetGlobalLogCtrl</span><span class="p">(</span><span class="n">E_LOG_TYPE</span> <span class="n">eLogType</span><span class="p">,</span> <span class="n">INT8U</span> <span class="n">ucLogSwitch</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">LOG_ON</span> <span class="o">==</span> <span class="n">ucLogSwitch</span><span class="p">)</span>
        <span class="n">gOmciLogCtrl</span> <span class="o">=</span> <span class="n">LOG_ALL</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">gOmciLogCtrl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">VOID</span> <span class="nf">SetSpecificLogCtrl</span><span class="p">(</span><span class="n">E_LOG_TYPE</span> <span class="n">eLogType</span><span class="p">,</span> <span class="n">INT8U</span> <span class="n">ucLogSwitch</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">LOG_ON</span> <span class="o">==</span> <span class="n">ucLogSwitch</span><span class="p">)</span>
        <span class="n">SET_BIT</span><span class="p">(</span><span class="n">gOmciLogCtrl</span><span class="p">,</span> <span class="n">eLogType</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">CLR_BIT</span><span class="p">(</span><span class="n">gOmciLogCtrl</span><span class="p">,</span> <span class="n">eLogType</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">VOID</span> <span class="nf">OmciLogCtrl</span><span class="p">(</span><span class="n">CHAR</span> <span class="o">*</span><span class="n">pszLogType</span><span class="p">,</span> <span class="n">INT8U</span> <span class="n">ucLogSwitch</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">strncasecmp</span><span class="p">(</span><span class="n">pszLogType</span><span class="p">,</span> <span class="s">&#34;All&#34;</span><span class="p">,</span> <span class="n">LOG_TYPE_CMP_LEN</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">SetGlobalLogCtrl</span><span class="p">(</span><span class="n">LOG_ALL</span><span class="p">,</span> <span class="n">ucLogSwitch</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">INT8U</span> <span class="n">ucIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">ucIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">ucIdx</span> <span class="o">&lt;</span> <span class="n">ucLogTypeNameNum</span><span class="p">;</span> <span class="n">ucIdx</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">strncasecmp</span><span class="p">(</span><span class="n">pszLogType</span><span class="p">,</span> <span class="n">paLogTypeName</span><span class="p">[</span><span class="n">ucIdx</span><span class="p">],</span> <span class="n">LOG_TYPE_CMP_LEN</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">SetSpecificLogCtrl</span><span class="p">(</span><span class="n">ucIdx</span><span class="p">,</span> <span class="n">ucLogSwitch</span><span class="p">);</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&#34;LogType: %s, LogSwitch: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">paLogTypeName</span><span class="p">[</span><span class="n">ucIdx</span><span class="p">],</span>
                   <span class="p">(</span><span class="mi">1</span><span class="o">==</span><span class="n">ucLogSwitch</span><span class="p">)</span><span class="o">?</span><span class="s">&#34;On&#34;</span><span class="o">:</span><span class="s">&#34;Off&#34;</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">OmciLogHelp</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="掩码表">掩码表</h4>
<p>参见<a href="https://www.cnblogs.com/clover-toeic/p/3732444.html" target="_blank" rel="noopener noreffer">采用掩码方式简化产品国家地区支持能力的表示 - clover_toeic - 博客园</a>一文。该例实现中用到消息、掩码、函数指针等概念。</p>
<h2 id="编程思想">编程思想</h2>
<p>表驱动法属于数据驱动编程的一种，其核心思想在《Unix编程艺术》和《代码大全2》中均有阐述。两者均认为人类阅读复杂数据结构远比复杂的控制流程容易，即<strong>相对于程序逻辑，人类更擅长于处理数据</strong>。本节将由Unix设计原则中的“分离原则”和“表示原则”展开。</p>
<blockquote>
<p><strong>分离原则：策略同机制分离，接口同引擎分离</strong></p>
</blockquote>
<p>机制即提供的功能；策略即如何使用功能。策略的变化要远远快于机制的变化。将两者分离，可以使机制相对保持稳定，而同时支持策略的变化。代码大全中提到“隔离变化”的概念，以及设计模式中提到的将易变化的部分和不易变化的部分分离也是这个思路。</p>
<blockquote>
<p><strong>表示原则：把知识叠入数据以求逻辑质朴而健壮</strong></p>
</blockquote>
<p>即使最简单的程序逻辑让人类来验证也很困难，但就算是很复杂的数据，对人类来说，还是相对容易推导和建模的。数据比编程逻辑更容易驾驭。在复杂数据和复杂代码中选择，宁可选择前者。更进一步，在设计中，应该主动将代码的复杂度转移到数据中去(参考“版本控制”)。</p>
<p>在“消息处理”示例中，每个消息处理的逻辑不变，但消息可能是变化的。将容易变化的消息和不容易变化的查找逻辑分离，即“隔离变化”。此外，该例也体现消息内部的处理逻辑(机制)和不同的消息处理(策略)分离。</p>
<p>数据驱动编程可以应用于：</p>
<ul>
<li>函数级设计，如本文示例。</li>
<li>程序级设计，如用表驱动法实现状态机。</li>
<li>系统级设计，如DSL。</li>
</ul>
<p>注意，数据驱动编程不是全新的编程模型，只是一种设计思路，在Unix/Linux开源社区应用很多。数据驱动编程中，数据不但表示某个对象的状态，实际上还定义程序的流程，这点不同于面向对象设计中的数据“封装”。</p>
<h2 id="附录">附录</h2>
<h3 id="网友观点">网友观点</h3>
<p>(以下观点摘自博客园网友“七心葵”的回帖，非常具有启发性。)</p>
<p>Booch的《面向对象分析与设计》一书中，提到所有的程序设计语言大概有3个源流：结构化编程、面向对象编程、数据驱动编程。我认为数据驱动编程的本质是“参数化抽象”的思想，不同于OO的“规范化抽象”的思想。</p>
<p>数据驱动编程在网络游戏开发过程中很常用，但是少有人专门提到这个词。数据驱动编程有很多名字：元编程，解释器/虚拟机，LOP/微语言/DSL等。包括声明式编程、标记语言、甚至所见即所得的拖放控件，都算是数据驱动编程的一种吧。</p>
<p>数据驱动编程可以帮助处理复杂性，和结构化编程、OO 均可相容。(正交的角度)将变和不变的部分分离，策略和机制分离，由此联想到的还有：(数据和代码的分离，微语言和解释器的分离，被生成代码和代码生成器的分离)；更近一步：(微内核插件式体系结构)。</p>
<p>元编程应该说是更加泛化的数据驱动编程，元编程不是新加入一个间接层，而是退居一步，使得当前的层变成一个间接层。元编程分为静态元编程(编译时)和动态元编程(运行时)，静态元编程本质上是一种代码生成技术或者编译器技术；动态元编程一般通过解释器(或虚拟机)加以实现。</p>
<p>数据驱动编程当然也不应该说是“反抽象的”，但的确与“OO抽象”的思维方式是迥然不同，泾渭分明的，如TAOUP一书中所述：“在Unix的模块化传统和围绕OO语言发展起来的使用模式之间，存在着紧张的对立关系”应该说数据驱动编程的思路与结构化编程和OO是正交的，更类似一种“跳出三界外，不在五行中”的做法。</p>
<h3 id="编程和人的关系">编程和人的关系</h3>
<p>人类心智的限制，一切的背后都有人的因素作为依据：</p>
<ol>
<li>
<p>人同时关注的信息数量：7+-2 (所以要分模块)</p>
</li>
<li>
<p>人接收一组新信息的平均时间5s(所以要简单，系统总的模块数不要太多)</p>
</li>
<li>
<p>人思维的直观性(人的视觉能力和模糊思维能力)，这意味这两点：</p>
<ul>
<li>“直”——更善于思考自己能直接接触把玩的东西；(所以要“浅平透”、使用具象的设计，要尽量代码中只有顺直的流程);</li>
<li>“观”——更善于观图而不是推算逻辑；(所以要表驱动法，数据驱动编程，要UML，要可视化编程——当然MDA是太理想化了)</li>
</ul>
</li>
<li>
<p>人不能持续集中注意力(人在一定的代码行数中产生的bug数量的比例是一定的，所以语言有具有表现力，要体现表达的经济性)，所以要机制与策略分离，要数据和代码分离(数据驱动编程)，要微语言，要DSL，要LOP……</p>
</li>
<li>
<p>人是有创造欲，有现实利益心的(只要偶可能总是不够遵从规范，或想创造规范谋利——只要成本能承受，在硬件领域就不行)</p>
</li>
</ol>
<p>另外，开一个有意思的玩笑，Unix编程艺术艺术的英文缩写为TAOUP，我觉得可以理解为UP之TAO——向上抛出之道——将复杂的易变的逻辑作为数据或更高层代码抛给上层！</p>
<h3 id="函数指针">函数指针</h3>
<p>“消息处理”一节示例中的函数指针有点插件结构的味道。可对这些插件进行方便替换，新增，删除，从而改变程序的行为。而这种改变，对事件处理函数的查找又是隔离的(隔离变化)。</p>
<p>函数指针非常有用，但使用时需注意其缺陷：无法检查参数(parameter)和返回值(return value)的类型。因为函数已经退化成指针，而指针不携带这些类型信息。缺少类型检查，当参数或返回值不一致时，可能会造成严重的错误。</p>
<p>例如，定义三个函数，分别具有两个参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">max</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>  <span class="p">{</span>  <span class="k">return</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="o">?</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">y</span><span class="p">;</span>  <span class="p">}</span>
<span class="kt">int</span> <span class="nf">min</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>  <span class="p">{</span>  <span class="k">return</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">?</span> <span class="nl">x</span><span class="p">:</span> <span class="n">y</span><span class="p">;</span>  <span class="p">}</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>  <span class="p">{</span>  <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>而处理函数却定义为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">process</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)())</span>  <span class="p">{</span>  <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>  <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中，第三个参数是一个没有参数且返回int型变量的函数指针。但后面却用<code>process(a,b,max)</code>的方式进行调用，max带有两个参数。若编译器未检查出错误，而又不小心将<code>return (*f)(x,y);</code>写成<code>return (*f)(x);</code>，那么后果可能很严重。</p>
<p>因此在C语言中使用函数指针时，一定要小心<strong>类型陷阱</strong>。</p>
<hr>
<p>注：夹带一些私货，最近上下班会用耳机后台听tinyfool的一些视频，下面这个是关于学习曲线和规律的，启发比较大。如果要成为一个高手，需要在某个领域有一个合理的学习曲线（视频中所说的乐学者的学习曲线），认真练习和总结，持续学习，总会有所小成。因为这个讲座，最近开始阅读之前买了一直没看的《思考，快与慢》和《异类》这两本书，等读完了写个读书笔记。视频见下方</p>
<div class="bilibili"><iframe src="//player.bilibili.com/player.html?bvid=BV1uU4y147Zi&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe></div>

<hr>
<figure><figcaption>
            <h4>欢迎扫码关注我的公众号</h4>
        </figcaption>
</figure>]]></description>
</item><item>
    <title>请回答2020</title>
    <link>https://bugxch.github.io/%E8%AF%B7%E5%9B%9E%E7%AD%942020/</link>
    <pubDate>Sat, 02 Jan 2021 22:26:25 &#43;0800</pubDate>
    <author>bugxch</author>
    <guid>https://bugxch.github.io/%E8%AF%B7%E5%9B%9E%E7%AD%942020/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.pixabay.com/photo/2020/12/10/09/21/face-mask-5819709_960_720.jpg" referrerpolicy="no-referrer">
            </div><p>每个人的一生由记忆组成，但是记忆会随着时间模糊甚至消逝，幸好我们有相机，回望这一年，在人生的长河里给它打个鲜亮的标签。</p>
<p>看到<a href="https://www.cnfeat.com/2021/01/01/question2020/" target="_blank" rel="noopener noreffer">Question2020 - 笨方法学写作</a>的这篇文章，有感而发，我也写一篇2020的年终总结。文章里面写下的答案都是凭第一感觉，每个人的记忆都会有偏差，但是在2021年初的这个当下它们是我此时脑中真实的反应。</p>
<h3 id="问题清单">问题清单</h3>
<p>在过去的一年里，</p>
<p><div class="details admonition question open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-question-circle fa-fw"></i>问题<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">你的什么观念发生了改变？</div>
        </div>
    </div>
以可信考试为例，有四点感触比较深。</p>
<p>第一，如果想要在某个技能上有所突破，必须以<strong>咬定青山不放松的毅力持续投入有效的时间和精力</strong>，这意味着为了将技能磨练到足够高的水平，必须有足量有效的投入，甚至在<strong>必要的时候放弃休息娱乐的时间</strong>。比如因为公司的可信考试，我投入大量时间刷leetcode题目，从之前不知道c++的stl为何物，到现在也能熟练完成中等题目，甚至有勇气参加周赛挑战自己，靠的是8月份以来连续3个月的持续不断的刷题。下图就是今年的力扣的年度总结，当前leetcode的排名是全球27000名左右，希望今年还能更进一层，进入到5000以内吧。</p>
<p></p>
<p>第二，工作之后的学习与学生时代不同，白天大部分时间用于完成日常的工作，而且没有整块的时间预留给你做持续深入的学习，但是又要面临持续提升工作技能的压力，以我学习C++的经历体会，最有效的方法是“<strong>以考促训，预留不被打扰的两小时</strong>”。如果要想有效精进，每天一定要预留不被打扰的整段时间用于练习，最好是早起后上班前或者下班后睡觉前，腾出时间好好学习和思考。</p>
<p>第三，相信<strong>功不唐捐</strong>。持续的微小的积累达到一定的程度之后，往往会发生质变。技能训练尤为明显，借用《为学》的那一段</p>
<blockquote>
<p>天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。人之为学有难易乎？学之，则难者亦易矣；不学，则易者亦难矣。
不问年龄，不求结果，持续投入，水平必然会有提升。</p>
</blockquote>
<p>第四，做一件事情要达到极致，你做到level B是不够的，下定决心之后一定要做到level A。职场上只有惊艳到给别人留下深刻的印象，晋升的机会才会更青睐于你，平平凡凡虽然也没有错，但是如果真的笃定升职，全力以赴做到顶尖才是效率最高的方法。比如，如果要你想给人技术很厉害的印象，那么可信考试科目一做出来两道题是不够的，必须3道全部完成，只有这样的shock才能让别人在心里留下“编程NB”的印象。</p>
<p><div class="details admonition question open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-question-circle fa-fw"></i>问题<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">你的生活有什么大的变化吗？最大的幸福感来自哪里?</div>
        </div>
    </div>
应该说从2019年开始，有两件事情，<strong>养育小孩</strong>和<strong>拥有属于自己的房子</strong>。</p>
<p>在有小孩之前，老婆觉得生小孩就是完成女性的生育任务，她的人生是金融界大佬、保代人和投行精英，哪成想生下果果的那一刻起就母性大发，现在恨不得辞职在家天天在家带娃，果果带给我们的快乐确实很多，小孩子天真烂漫，成长中的小趣事能解大人的多重烦忧啊。果果带给我很多<strong>惊奇时刻</strong>，现在回想起来有两件事情我印象深刻。今年过年之后他第一次回上海，那时候大概14个月大刚学着走路，不会说话，当时我、丫丫和妈妈都在卧室，妈妈问果果“哪个是妈妈呀？”，我以为他不知道，结果他指着丫丫，然后又问“哪个是爸爸？”，他又指着我，问“谁是奶奶？”，指着妈妈。那一刻我直接被shock了，虽然他不会说话，但是实际上已经可以分清楚爸爸、妈妈和奶奶了。</p>
<figure><figcaption>
            <h4>5月份，14个月大的果果</h4>
        </figcaption>
</figure>

<p>今年6月底回湖北最多只能说两个词，9月份回到上海的时候就已经是成天指着这个问“这个是什么？”的好奇宝宝了，耳朵也异常灵敏，听到洗衣机运转的声音就会问，“什么东西响呀？”。我惊叹于人类小孩大脑发育的速度之快，短短几个月语言功能就发展到惊人的程度，有一次他自己在沙发上玩小汽车，玩弄了半天终于把车门打开了，顺口说出“终于打开了”，“终于”这个词语之前没有人跟他提起过，就算是他无意间听到了，也没人教他什么意思怎么用，他正确无误得把这个词语用得恰到好处，我和丫丫、妈妈觉得又可爱又惊讶。</p>
<figure><figcaption>
            <h4>9月份，在家乐福，三代同框</h4>
        </figcaption>
</figure>

<p>我小时候因为照片很少，不能知道自己小时候的样子，非常遗憾。我现在随手会给果果拍照片或者录视频，他不会有第2个2岁、3岁和5岁，人生就是一把开弓离弦的箭，不断奔向时间的前方，他长大后回看这些曾经的照片视频，应该是很有意思的一件事情。初步计划会在我的公众号给他开一个专栏，就叫<strong>果果成长记</strong>系列，不定期更新他的照片和视频，将来就是给他最好的礼物之一。打个广告，请扫描文末的二维码关注我的公众号。</p>
<p>买房子之后最大的幸福感来自于可以敞开钱包购置自己想买的那些大件商品，比如一个好床垫，一个好书桌，一台好电视。</p>
<p><figure><figcaption>
            <h4>5月份，逛小区</h4>
        </figcaption>
</figure>

我们在3月份签订了购房居间合同，按照正常的流程应该在贷款下来之后就可以交接入住了，但是房东由于坐月子所以延迟两个月交房，中间我会突然兴起去看小区，经常想着入住之后的样子，幸好房东近两年刚装修完，而且装修风格简洁明快，风格不错，有自己的小窝感觉还是很幸福的。交接之后，我们去宜家挑了书桌、床垫和餐桌，购置了新冰箱，双十一换了新燃气热水器，房子虽小，好好收拾了下书房，不过当下住着还是蛮舒服的。
<figure><figcaption>
            <h4>9月份，书房刚收拾好时的样子</h4>
        </figcaption>
</figure>
</p>
<p><div class="details admonition question open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-question-circle fa-fw"></i>问题<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">你有哪些有意思的发现？比如公众号，综艺节目或者一本书？</div>
        </div>
    </div>
在之前我有一个习惯，发现有意思的网站，都会放在我博客的<a href="https://bugxch.github.io/collection/" target="_blank" rel="noopener noreffer">杂记</a>的页面，2018年收集了很多，但是后来博客迁来迁去丢失了，现在又在慢慢攒。当前我时常浏览的博客就是下面几个，</p>
<ul>
<li>
<p><a href="https://pmthinking.com/" target="_blank" rel="noopener noreffer">产品沉思录 · Product Thinking</a>，2020年发现的比较好的&gt; 产品的网站</p>
</li>
<li>
<p><a href="https://hugoloveit.com/zh-cn/" target="_blank" rel="noopener noreffer">LoveIt</a>，当前网站的主题介绍文章，可以参考文章插入图片、视频和音乐</p>
</li>
<li>
<p><a href="http://www.sharetechnote.com/" target="_blank" rel="noopener noreffer">ShareTechnote</a>，一个韩国高级工程师搭建的专业知识共享网站</p>
</li>
<li>
<p><a href="https://coolshell.cn/" target="_blank" rel="noopener noreffer">酷壳 – CoolShell.cn</a>，左耳朵耗子的官方博客，对我影响比较大的技术大佬</p>
</li>
<li>
<p><a href="https://spaces.ac.cn/" target="_blank" rel="noopener noreffer">科学空间|Scientific Spaces</a>，非常不错的后生，天文、数学、AI、竞赛，博文质量极高，在这么小的年龄以十年的尺度更新不辍，非常难得</p>
</li>
<li>
<p><a href="https://www.ruanyifeng.com/blog/" target="_blank" rel="noopener noreffer">阮一峰的网络日志</a>，IT圈子中小有名气的大佬，比较喜欢他每周一推的科技爱好者周刊系列
推荐搞IT的同学关注。
另外，推荐腾讯视频的<a href="https://v.qq.com/x/cover/mzc002006bujgo5/c3217pq213q.html?" target="_blank" rel="noopener noreffer">《十三邀》</a>节目，当前最新一期是去年的五条人乐队，这些访谈采访比较随意，不通过制造噱头可以拉高收视率，率真自然，推荐观看。去年没怎么看书，依然推荐老六的<a href="http://www.duku.cn/" target="_blank" rel="noopener noreffer">《读库》</a>系列，最近好像涨价了，不过品质一直没变。我最近有强烈的感受，现在我已经对之前大学时期的偏文学社科的书目不太感兴趣了，更多的将精力投入到职业技能的提升上，我去年C++的书籍买了一堆，计划今年攻克这些大部头，愚公移山，犹未为晚也。
</p>
</li>
<li>
<p>今年完整看过极力推荐的两部电视剧都改编自紫金陈的小说，<a href="https://movie.douban.com/subject/33404425/?from=subject-page" target="_blank" rel="noopener noreffer">隐秘的角落 (豆瓣)</a>和<a href="https://movie.douban.com/subject/33447642/" target="_blank" rel="noopener noreffer">沉默的真相 (豆瓣)</a>，第二部豆瓣给出了9.2的高分，国产电视剧能到8.0以上就值得花时间看了，第二部我是在国庆的客厅沙发上几乎通宵追完的，为此还买了一个月的爱奇艺会员，确实值得。不过今年有一部好剧烂尾了，改编自孙皓晖的<a href="https://book.douban.com/subject/3079029/" target="_blank" rel="noopener noreffer">《大秦帝国》</a>的终章<a href="https://movie.douban.com/subject/26413293/" target="_blank" rel="noopener noreffer">《大秦赋 》</a>，情节冗长拖沓，剧本被资方改得七零八碎，追了大概20集弃剧了，不建议入坑。</p>
</li>
</ul>
<p><div class="details admonition question open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-question-circle fa-fw"></i>问题<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">你买到了什么好东西，可以推荐给大家吗？</div>
        </div>
    </div>
今年最大支出是房子，这个就不多谈了，我在设备更新上花钱比较多，年中给我的整体升级了我的小黑硬件配置</p>
<ul>
<li>500大洋的<a href="https://item.jd.com/6212482.html" target="_blank" rel="noopener noreffer">三星（SAMSUNG）500GB SSD固态硬盘 SATA3.0接口 860 EVO（MZ-76E500B）</a>把原来的机械硬盘换到固态硬盘</li>
<li>200大洋将当前的内存从4G升级到16G，<a href="https://item.jd.com/26139216296.html" target="_blank" rel="noopener noreffer">三星SAMSUNG内存条4g8g16g32g ddr4 ddr3l</a>
仅仅700大洋，之前的电脑卡死现象改善明显，开始时间由原来的1分钟降到10秒钟，打开大型文档或者多任务并行也不卡了，电脑体验的大幅改善肉眼可见，幸福感爆棚，建议大家也早点升级自己的硬件装备，早买早享受。</li>
<li>老婆将自己原来的T460电脑给了岳父，我转手4000大洋在公司内购了一台华为的2019 MateBook 14，内存小了点（8G），512G的固态硬盘，对于老婆这种重文档处理的情景用起来也足够，打开文档嗖嗖快。</li>
<li>我现在在用公司内测机的Mate 30 Pro，之前一直用iphone SE，今年上半年还曾动过买iphone SE 2的念头，不过现在完全喜欢上手上的这部手机了，华为手机最大优点是续航，但是别的方便做的也不错，很结实耐用，真的是钢铁直男做出来的手机，如果内测机折价卖给我，那肯定就这部了。</li>
<li>1600大洋，8月份手痒买了<a href="https://time.geekbang.org/" target="_blank" rel="noopener noreffer">《极客时间》</a>的算法训练营课程，现在想来稍微有点贵，因为他视频的课程在3个月之后是要失效的，不能永久保存，上这门课最大的收获是养成了正确的算法练习方法，这个可以再单独写一篇感想。</li>
<li>剩下的大件就是购置新家的家具，零零碎碎加上电器购置下来也有1w大洋左右了，主要选宜家，这里推荐<strong>宜家</strong>，质量和售后有保证，9月份买的床垫短了，我在12月份退掉买了个新的，过程有点波折，但是总体感受还可以。
在消费上，在满足自己需求的条件下，我坚持下面两个原则，</li>
</ul>
<ol>
<li><strong>不看贵贱，买价格和价值最匹配的</strong>，有可能这个东西比较贵，但是如果他贵的有道理，那就值得它的价格；</li>
<li><strong>对于长期需要使用的商品，在可承受的范围之内，我宁可买个贵而且好用的，也不会将就买便宜的</strong>，比如床垫，冰箱，键盘。</li>
</ol>
<p><div class="details admonition question open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-question-circle fa-fw"></i>问题<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">你的养成了什么好习惯或者坏习惯？</div>
        </div>
    </div>
最大的好习惯包括坚持刷题，勤耕不辍，题目做不出来茶饭不思。
坏习惯包括，</p>
<ul>
<li>喜欢躺在床上看手机，这个既对颈椎不好而且晚上看久了也影响第二天工作的精力，必须改；</li>
<li>没有坚持健身，今年体检就有脂肪肝了，问题比往年要多一些，今年也要改善，老婆买了划船机也要定期用起来。</li>
<li>之前使用随手记记账的习惯也丢了，去年因为买房所以花销肯定比较大，今年从元旦开始重新记账。</li>
</ul>
<p><div class="details admonition question open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-question-circle fa-fw"></i>问题<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">你最大的变化是什么？来年你期待有什么变化？</div>
        </div>
    </div>
相信努力的效果，在强手如林的我司，尤其是我们团队，相信自己能精进技能而且可以找到自己的定位。来年期待可以花更多精力在育儿上，果果慢慢大了，到了狗都嫌的2岁了，现在性格有些胆小，虽然不知道什么原因，但是我发现只要我陪伴多一点他就快乐胆大些。多读些育儿书籍，多与果果互动。还有一个，加强锻炼，已经到了不投入时间健身疾病就会找上门来的年龄了，以长远计，健康的体魄是迎接挑战享受日后人生的保障那~</p>
<h3 id="年度照片">年度照片</h3>
<p>下面是我的年度照片，每个月挑选1到2张有代表性的意思一下（右键 -&gt; 在新标签页中打开图片可以看到高清大图，博客不知道为什么不能显示最大的清晰度），</p>
<figure><figcaption>
            <h4>1月下旬，因为新冠爆发，我和丫丫只能在上海过年，家乐福购物归来</h4>
        </figcaption>
</figure>

<figure><figcaption>
            <h4>2月份，work at home，自制办公桌，后来不小心把显示器掉下来摔坏右上角</h4>
        </figcaption>
</figure>

<figure><figcaption>
            <h4>2月份，疫情期间在家坚持学习的易老师</h4>
        </figcaption>
</figure>

<figure><figcaption>
            <h4>2月份，第一个上班日，公司严正以待</h4>
        </figcaption>
</figure>

<figure><figcaption>
            <h4>2月份，同上，连按压取水都要用纸巾衬着</h4>
        </figcaption>
</figure>

<figure><figcaption>
            <h4>3月份，与易老师去高行看房，拍照留念小发卡</h4>
        </figcaption>
</figure>

<figure><figcaption>
            <h4>4月份，老树发新芽的博兴路</h4>
        </figcaption>
</figure>

<figure><figcaption>
            <h4>5月份，不记得在哪里拍的了</h4>
        </figcaption>
</figure>

<figure><figcaption>
            <h4>5月份，一家人逛滨江大道</h4>
        </figcaption>
</figure>

<figure><figcaption>
            <h4>5月份，有起床气的某宝宝</h4>
        </figcaption>
</figure>

<figure><figcaption>
            <h4>5月份，有了自己的房子</h4>
        </figcaption>
</figure>

<figure><figcaption>
            <h4>6月份，不肯睡觉喜欢玩妈妈化妆品的某宝宝</h4>
        </figcaption>
</figure>

<figure><figcaption>
            <h4>7月份，疫情期间装修停滞的西西弗书店金桥国际店开了</h4>
        </figcaption>
</figure>

<figure><figcaption>
            <h4>8月份，和易老师骑行黄浦滨江，美哉</h4>
        </figcaption>
</figure>

<figure><figcaption>
            <h4>8月份，易老师骑行黄浦滨江的曼妙身影</h4>
        </figcaption>
</figure>

<figure><figcaption>
            <h4>8月份，搬离最后的出租屋，迁入新家</h4>
        </figcaption>
</figure>

<figure><figcaption>
            <h4>9月份，新家阳台所摄，很喜欢满眼的绿色，远处是上海中心大厦</h4>
        </figcaption>
</figure>

<figure><figcaption>
            <h4>9月份，和易老师到杨浦宜家购置新家具</h4>
        </figcaption>
</figure>

<figure><figcaption>
            <h4>10月份，爸爸第一次来上海，祖孙三代合影</h4>
        </figcaption>
</figure>

<figure><figcaption>
            <h4>12月份，初冬的博兴路</h4>
        </figcaption>
</figure>

<hr>
<figure><figcaption>
            <h4>欢迎扫码关注我的公众号</h4>
        </figcaption>
</figure>]]></description>
</item><item>
    <title>LeetCode区间问题总结</title>
    <link>https://bugxch.github.io/intersection/</link>
    <pubDate>Sun, 16 Aug 2020 22:31:31 &#43;0800</pubDate>
    <author>bugxch</author>
    <guid>https://bugxch.github.io/intersection/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.pixabay.com/photo/2013/07/18/20/26/sea-164989_960_720.jpg" referrerpolicy="no-referrer">
            </div><p>上周五考试没有过，其中专业级第二题是关于区间的问题，在leetcode上找到类似的题目，总结复习下。</p>
<h2 id="引子">引子</h2>
<p>先看这道题，<a href="https://leetcode-cn.com/problems/corporate-flight-bookings/" target="_blank" rel="noopener noreffer">1109. 航班预订统计</a>，题目是这样的</p>
<p>这里有<code>n</code> 个航班，它们分别从 1 到 n 进行编号。</p>
<p>我们这儿有一份航班预订表，表中第 <code>i</code> 条预订记录 <code>bookings[i] = [i, j, k]</code> 意味着我们在从 <code>i</code> 到<code> j</code> 的每个航班上预订了 <code>k</code> 个座位。</p>
<p>请你返回一个长度为 n 的数组 <code>answer</code>，按航班编号顺序返回每个航班上预订的座位数。参考示例如下，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="err">输入：</span><span class="n">bookings</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">20</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">25</span><span class="p">]],</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span>
<span class="err">输出：</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">55</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">25</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="解题思路">解题思路</h3>
<p>将这道题的示例画一张表格表示一下，就是下面的结果</p>
<table>
<thead>
<tr>
<th style="text-align:center">booking</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">10</td>
<td style="text-align:center">10</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">20</td>
<td style="text-align:center">20</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">25</td>
<td style="text-align:center">25</td>
<td style="text-align:center">25</td>
<td style="text-align:center">25</td>
</tr>
<tr>
<td style="text-align:center">total</td>
<td style="text-align:center">10</td>
<td style="text-align:center">55</td>
<td style="text-align:center">45</td>
<td style="text-align:center">25</td>
<td style="text-align:center">25</td>
</tr>
</tbody>
</table>
<p>常规思路就是以航班号为基本坐标，计算每一个航班增加的座位数，然后逐项汇总相加即可。</p>
<ol>
<li>设置初始结果<code>vector&lt;int&gt; res(n, 0)</code>;</li>
<li>遍历<code>bookings</code>，每次取其中的航班的预定数，添加到<code>res</code>对应的数组中，比如第1个booking，那么<code>res[0]+=10; res[1]+=10</code>，依次类推，直到遍历截止。</li>
</ol>
<p>上面的算法比较简单直观，但是可以分析发现，算法的复杂度有点高，两层遍历算法时间复杂度是$O(n^2)$，空间复杂度是$O(n)$不甚理想。</p>
<p>有没有复杂度更简单的思路呢？这里有一个类比<strong>公交站的思路</strong>，可以将航班号码比作公交站牌，比如1号公交站，2号公交站，假定这些公交站是依次按顺序分布在一条直线公路上，<strong>第<code>i</code>个航班的飞机的预定数目就是公交车在第<code>i</code>个公交站发车时候的乘客数目（包括了上车和下车的乘客数</strong>）。</p>
<p>举例说明，第1行表示，第1站交车上人数是10，说明公交车行驶到第1站时上车10人，到第2站时候车上的乘客仍然是10人，说明没有乘客上下车，到第3站时候车上乘客0人，说明此时有10人下车。如果使用长度为<code>N</code>的数组<code>count</code>表示每一站<strong>上下乘客的变化量</strong>(<code>count[i]</code> 表示第<code>i + 1</code>站上下车的乘客变化量），</p>
<blockquote>
<p>对于<code>booking = [i,j,k]</code>，</p>
<ol>
<li>表示在公交站第<code>i</code>站上车<code>k</code>人，<code>count[i - 1] += k</code>；</li>
<li>第<code>i + 1</code>站直到第<code>j</code>站都没有乘客上下车，<code>count[i],...,count[j - 1]</code>无操作；</li>
<li>在第<code>j + 1</code>站下车<code>k</code>人，所以<code>count[j] -= k</code></li>
</ol>
</blockquote>
<p>为了方便起见，<strong>我们缩小问题的规模，以具体的数字代替抽象的代数字母</strong>，假如我们就只有3个公交站，取示例中的前2行，</p>
<ol>
<li>公交车刚开始上的人数是0，<code>vector&lt;int&gt; count(4, 0)</code>；</li>
<li>读取第1行，到达第1站，公交车上10人，说明<strong>上车10人，无人下车，<code>count[0]+= 10</code></strong>，到达第2站公交车上依然是10人，说明也<strong>无人上车和下车</strong>，到达第3站，公交车上0人，说明<strong>10人下车，<code>count[2] -= 10</code></strong>；</li>
<li>读取第2行，公交车到达第2站，公交车上20人，说明<strong>上车20人无人下车，<code>count[1] += 20</code></strong>，第3站车上20人，说明<strong>无人下车</strong>，第4站车上0人，说明<strong>有20人下车, <code>count[3]-=20</code></strong>。</li>
</ol>
<p>遍历结束，得到<code>count = {10, 20, -10，-20}</code>，那么最后每个站点的乘客数就很清楚了，到达第1站前车上乘客0人，到达后上车10人，所以第1站发车前车上10人，第2站到站后上车20人，所以第2站发车前车上乘客10 + 20  = 30人，第3站到站后下车10人，所以发车前车上乘客 30 - 10 = 20人。意思搞清楚之后，代码就很好写了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">corpFlightBookings</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">bookings</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">counter</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">booking</span> <span class="p">:</span> <span class="n">bookings</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">booking</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">booking</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="c1">// 记录每个booking的开始和结尾即可，中间的站点人数无变化
</span><span class="c1"></span>            <span class="n">counter</span><span class="p">[</span><span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">booking</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// start站上车
</span><span class="c1"></span>            <span class="n">counter</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">-=</span> <span class="n">booking</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// end + 1站下车
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>时间复杂度为$O(n)$。</p>
<h2 id="通用框架">通用框架</h2>
<p>「待补充」</p>
<h2 id="典型题目">典型题目</h2>
<p>「待补充」</p>
<h3 id="no-986-区间列表交集">No. 986 区间列表交集</h3>
<p>题目的链接参考<a href="https://leetcode-cn.com/problems/interval-list-intersections/" target="_blank" rel="noopener noreffer">986. 区间列表的交集 - 力扣（LeetCode）</a>，</p>
<h3 id="no-452-引爆气球">No. 452 引爆气球</h3>
<p>题目链接参考<a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener noreffer">452. 用最少数量的箭引爆气球 - 力扣（LeetCode）</a>，这道题目使用<strong>贪心法</strong>，将气球的坐标放在坐标轴上，然后从0开始从左到右逐气球扫描，查看是否有交集，图示如下。</p>
<h2 id="参考资料">参考资料</h2>
<p>「待补充」</p>]]></description>
</item><item>
    <title>「转载」C&#43;&#43;中的sort函数（一）</title>
    <link>https://bugxch.github.io/sort_intro/</link>
    <pubDate>Sat, 15 Aug 2020 21:25:46 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://bugxch.github.io/sort_intro/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://pic.imgdb.cn/item/6002ed073ffa7d37b305c866.jpg" referrerpolicy="no-referrer">
            </div><p>公司认证的leetcode题目中经常会用到sort函数，不是很熟悉，今天系统学习总结下。</p>
<h2 id="总述">总述</h2>
<p>下面是C++的stl中的排序的所有函数，这个系列的博客会逐一介绍，这次的博客先关注最常用的<code>sort</code>函数。</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>sort (first, last)</td>
<td>对容器或普通数组中 [first, last) 范围内的元素进行排序，默认进行升序排序。</td>
</tr>
<tr>
<td>stable_sort (first, last)</td>
<td>和 sort() 函数功能相似，不同之处在于，对于 [first, last) 范围内值相同的元素，该函数不会改变它们的相对位置。</td>
</tr>
<tr>
<td>partial_sort (first, middle, last)</td>
<td>从 [first,last) 范围内，筛选出 muddle-first 个最小的元素并排序存放在 [first，middle) 区间中。</td>
</tr>
<tr>
<td>partial_sort_copy (first, last, result_first, result_last)</td>
<td>从 [first, last) 范围内筛选出 result_last-result_first 个元素排序并存储到 [result_first, result_last) 指定的范围中。</td>
</tr>
<tr>
<td>is_sorted (first, last)</td>
<td>检测 [first, last) 范围内是否已经排好序，默认检测是否按升序排序。</td>
</tr>
<tr>
<td>is_sorted_until (first, last)</td>
<td>和 is_sorted() 函数功能类似，唯一的区别在于，如果 [first, last) 范围的元素没有排好序，则该函数会返回一个指向首个不遵循排序规则的元素的迭代器。</td>
</tr>
<tr>
<td>void nth_element (first, nth, last)</td>
<td>找到 [first, last) 范围内按照排序规则（默认按照升序排序）应该位于第 nth 个位置处的元素，并将其放置到此位置。同时使该位置左侧的所有元素都比其存放的元素小，该位置右侧的所有元素都比其存放的元素大。</td>
</tr>
</tbody>
</table>
<h2 id="sort函数">sort函数</h2>
<h3 id="使用范围">使用范围</h3>
<p>C++ STL 标准库中的 sort() 函数，本质就是一个模板函数。正如表 1 中描述的，该函数专门用来对容器或普通数组中指定范围内的元素进行排序，排序规则默认以元素值的大小做升序排序，除此之外我们也可以选择标准库提供的其它排序规则（比如<code>std::greater&lt;T&gt;</code>降序排序规则），甚至还可以自定义排序规则。</p>
<p>需要注意的是，sort() 函数受到底层实现方式的限制，它仅适用于普通数组和部分类型的容器。换句话说，只有普通数组和具备以下条件的容器，才能使用 sort() 函数：</p>
<ol>
<li>容器支持的迭代器类型必须为随机访问迭代器。这意味着，sort() 只对 array、vector、deque 这 3 个容器提供支持；</li>
<li>如果对容器中指定区域的元素做默认升序排序，则元素类型必须支持<code>&lt;</code>小于运算符；同样，如果选用标准库提供的其它排序规则，元素类型也必须支持该规则底层实现所用的比较运算符；</li>
<li>sort() 函数在实现排序时，需要交换容器中元素的存储位置。这种情况下，如果容器中存储的是自定义的类对象，则该类的内部必须提供移动构造函数和移动赋值运算符。</li>
</ol>
<h3 id="局限">局限</h3>
<p><code>sort</code>函数不保证排序的<a href="https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%A8%B3%E5%AE%9A%E6%80%A7" target="_blank" rel="noopener noreffer">稳定性</a>，即如果被排序的序列中有多个相同值的元素，并不能保证排序之后他们的相对位置保持不变。</p>
<h3 id="使用方法">使用方法</h3>
<p>值得一提的是，sort() 函数位于<code>&lt;algorithm&gt;</code>头文件中，因此在使用该函数前，程序中应包含如下语句：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">#include &lt;algorithm&gt;
</code></pre></td></tr></table>
</div>
</div><p>sort() 函数有 2 种用法，其语法格式分别为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">//对 [first, last) 区域内的元素做默认的升序排序
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">sort</span> <span class="p">(</span><span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">RandomAccessIterator</span> <span class="n">last</span><span class="p">);</span>
<span class="c1">//按照指定的 comp 排序规则，对 [first, last) 区域内的元素进行排序
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">sort</span> <span class="p">(</span><span class="n">RandomAccessIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">RandomAccessIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">Compare</span> <span class="n">comp</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>其中，first 和 last 都为随机访问迭代器，它们的组合 [first, last) 用来指定要排序的目标区域；另外在第 2 种格式中，comp 可以是 C++ STL 标准库提供的排序规则（比如 std::greater<T>），也可以是自定义的排序规则。比如，如果需要做<strong>降序</strong>排序，那么可以使用<code>std::less&lt;T&gt;</code>，也可以自己写一个降序的函数。具体的用法如下所示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;     // std::cout</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;    // std::sort</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;       // std::vector</span><span class="cp">
</span><span class="cp"></span><span class="c1">//以普通函数的方式实现自定义排序规则
</span><span class="c1"></span><span class="kt">bool</span> <span class="nf">mycomp</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//以函数对象的方式实现自定义排序规则
</span><span class="c1"></span><span class="k">class</span> <span class="nc">mycomp2</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myvector</span><span class="p">{</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">71</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">33</span> <span class="p">};</span>
    <span class="c1">//调用第一种语法格式，对 32、71、12、45 进行排序
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">//(12 32 45 71) 26 80 53 33
</span><span class="c1"></span>    <span class="c1">//调用第二种语法格式，利用STL标准库提供的其它比较规则（比如 greater&lt;T&gt;）进行排序
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span> <span class="c1">//(71 45 32 12) 26 80 53 33
</span><span class="c1"></span>
    <span class="c1">//调用第二种语法格式，通过自定义比较规则进行排序
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myvector</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">mycomp2</span><span class="p">());</span> <span class="c1">// 80 71 53 45 33 32 26 12
</span><span class="c1"></span>    <span class="n">sort</span><span class="p">(</span><span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">myvector</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">mycomp</span><span class="p">);</span> <span class="c1">// 80 71 53 45 12 26 32 33
</span><span class="c1"></span>    <span class="c1">//输出 myvector 容器中的元素
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">myvector</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="http://c.biancheng.net/view/7457.html" target="_blank" rel="noopener noreffer">C++ sort()排序函数用法详解</a>，c语言中文网的介绍</li>
<li><a href="https://www.geeksforgeeks.org/sort-c-stl/" target="_blank" rel="noopener noreffer">std::sort() in C++ STL - GeeksforGeeks</a>，国外的网站介绍</li>
</ul>]]></description>
</item><item>
    <title>广度优先搜索详解</title>
    <link>https://bugxch.github.io/dfs_intro/</link>
    <pubDate>Sat, 08 Aug 2020 11:24:24 &#43;0800</pubDate>
    <author>bugxch</author>
    <guid>https://bugxch.github.io/dfs_intro/</guid>
    <description><![CDATA[<p>总结一下广度优先搜索的原理和用法。</p>
<p></p>
<h2 id="引子">引子</h2>
<p>先看这道题<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener noreffer">104. 二叉树的最大深度</a>，题目中给出一个二叉树，求这个二叉树的最大深度。例子中给出下面的二叉树</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">    <span class="m">3</span>
   / <span class="se">\
</span><span class="se"></span>  <span class="m">9</span>  <span class="m">20</span>
    /  <span class="se">\
</span><span class="se"></span>   <span class="m">15</span>   <span class="m">7</span>
</code></pre></td></tr></table>
</div>
</div><p>这个如何解决呢？肉眼可见，最大深度是3。</p>
<h3 id="构建二叉树">构建二叉树</h3>
<p>首先为了便于调试，需要构建一颗二叉树，题目中的给出的是二叉树的层序遍历的结果，我们用<code>INT_MAX</code>代替null，使用如下函数构造二叉树</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">ConstructBinTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">nodes</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">INT_MAX</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">root</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">iq</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">id</span><span class="o">++</span><span class="p">];</span>
    <span class="n">iq</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">iq</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="n">nodes</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">TreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">iq</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">iq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

        <span class="c1">// check vectors for left node
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INT_MAX</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">leftNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">;</span>
            <span class="n">leftNode</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">leftNode</span><span class="p">;</span>
            <span class="n">iq</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">leftNode</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">id</span><span class="o">++</span><span class="p">;</span>
		
        <span class="c1">// add right node
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INT_MAX</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">rightNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">;</span>
            <span class="n">rightNode</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">rightNode</span><span class="p">;</span>
            <span class="n">iq</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">rightNode</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">id</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>下面是中序遍历二叉树</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">ScanBinMiddle</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">tree</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tree</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// handle value
</span><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ScanBinMiddle</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ScanBinMiddle</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="递归解法">递归解法</h3>
<p>二叉树的比较普遍的解法是使用递归，我们需要找出递归的关系式，然后用程序写出来。递归解决问题的思路包括下面两点</p>
<h4 id="描述变量">描述变量</h4>
<p>我们有一个关于目标变量的描述，在这个题目中目标变量是整棵树的最大深度，放弃整体的概念，假设你站在根节点往下看，会看到它有左右两个子树，每棵树又有自己的节点和深度。所以假定推导的变量是</p>
<blockquote>
<p><code>maxdepth[node]</code>表示以<code>node</code>为根节点的树的最大深度</p>
</blockquote>
<h4 id="递归关系式">递归关系式</h4>
<p>查看这个值和左右子树的关系是什么？3这个node的最大深度是9这个node最大深度和20这个node的最大深度的最大值 + 1，重新表述下就是下面的关系式<code>maxD[node] = max(maxD[node-&gt;left], maxD[node-&gt;right]) + 1</code>。</p>
<h4 id="终止条件">终止条件</h4>
<p>终止条件比较简单，在访问到null节点的时候返回0即可，因为以这个节点为根的树是不存在的，所以深度为0。于是有下面的代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> 
<span class="p">{</span>	
    <span class="c1">// 终止条件
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
	<span class="c1">// 关系式
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">),</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="广度优先搜索算法bfs">广度优先搜索算法（BFS）</h3>
<p>不使用递归，还有另一种解法，一层层观察整棵树，第一层1个节点，第二层2个节点，第三层2个节点。每一层的节点之间使用左右子树联系起来，所以根据第1层的节点可以访问第2层的节点，根据第2层的节点可以访问第3层的节点，所以可以这么做。记录整棵树最深的深度是<code>maxdepth = 0</code>，</p>
<ol>
<li>访问第一层的根节点，如果非空则<code>maxdepth++</code>，否则返回；</li>
<li>查看第一层的根节点是否有左右子树，有的话再分别访问左子树和右子树，<code>maxdepth++</code>；</li>
<li>循环步骤2，直到所有的节点都被访问到。</li>
</ol>
<p>这里可以使用<strong>队列</strong>保存需要被访问的节点，如下图所示，分别在头和尾弹出和插入节点，</p>
<p></p>
<p>结合上面的步骤，<code>depth = 1</code>，将root的根节点添加到队列结尾</p>
<ol>
<li>我们一次将一层的节点放入到队列中；</li>
<li>判断当前队列是否为空。
<ul>
<li>如果当前的队列不为空，那么将队列中的每个节点pop出来之后再考察这个节点的左右子树，如果有就将它们插入到队列的尾巴，<code>depth++</code>；</li>
<li>如果当前队列为空，return</li>
</ul>
</li>
</ol>
<p>所以有了下面的代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="c1">// 如果为空，那么返回0
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">qu</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// 添加根节点
</span><span class="c1"></span>    <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">qu</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">qz</span> <span class="o">=</span> <span class="n">qu</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">qz</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 考察队列中的每个节点，是否有左子树和右子树
</span><span class="c1"></span>            <span class="n">TreeNode</span> <span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">qu</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">qu</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="c1">// 如果有左右子节点，那么添加到队列中
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">depth</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">depth</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>下图是资料3中的图示过程，简单明了。</p>
<p></p>
<h2 id="数据结构">数据结构</h2>
<h3 id="队列">队列</h3>
<p>使用<strong>队列</strong>保存每一层的节点，如下图所示，队列是先进先出的数据结构，包括如下的属性和方法</p>
<p></p>
<ul>
<li>队列头（front），表示队列最开始的元素；</li>
<li>队列尾（rear），表示队列最后加入的元素；</li>
<li>队列长度，当前的队列长度，就是rear - front + 1；</li>
<li>出队（pop），队列头弹出，队列长度-1，front++；</li>
<li>入队（push），队列尾添加元素，队列长度+1，rear++</li>
</ul>
<h3 id="stl中的queue">STL中的queue</h3>
<p>C++的stl使用queue表示队列，常用的操作和属性如下表所示</p>
<ul>
<li><code>front()</code>：返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</li>
<li><code>back()</code>：返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</li>
<li><code>push(const T&amp; obj)</code>：在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。</li>
<li><code>push(T&amp;&amp; obj)</code>：以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。</li>
<li><code>pop()</code>：删除 queue 中的第一个元素。</li>
<li><code>size()</code>：返回 queue 中元素的个数。</li>
<li><code>empty()</code>：如果 queue 中没有元素的话，返回 true。</li>
<li><code>emplace()</code>：用传给 emplace() 的参数调用 T 的构造函数，在 queue 的尾部生成对象。</li>
<li><code>swap(queue&lt;T&gt; &amp;other_q)</code>：将当前 queue 中的元素和参数 queue 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。</li>
</ul>
<p>典型的使用方法如下，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// CPP program to illustrate 
</span><span class="c1">// Application of push() and pop() function 
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt; </span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;queue&gt; </span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span> 

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span> 
	<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
	<span class="c1">// Empty Queue 
</span><span class="c1"></span>	<span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myqueue</span><span class="p">;</span> 
	<span class="n">myqueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> 
	<span class="n">myqueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">13</span><span class="p">);</span> 
	<span class="n">myqueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> 
	<span class="n">myqueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span> 
	<span class="n">myqueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> 
	<span class="c1">// queue becomes 5, 13, 0, 9, 4 
</span><span class="c1"></span>
	<span class="c1">// Counting number of elements in queue 
</span><span class="c1"></span>	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">myqueue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span> 
		<span class="n">myqueue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span> 
		<span class="n">c</span><span class="o">++</span><span class="p">;</span> 
	<span class="p">}</span> 
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">;</span> 
<span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><h2 id="典型题目">典型题目</h2>
<h3 id="二叉树的右视图">二叉树的右视图</h3>
<p>题目链接见<a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener noreffer">199. 二叉树的右视图 - 力扣（LeetCode）</a>，如果有了上面题目的框架，这个题目其实很简单，既然每次遍历队列保存的<strong>这一层所有节点</strong>，而且节点的顺序是从左到右保存的，所以可以在每一层遍历的时候将队列的最后一个node加入到这个vector中，代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rightSideView</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rlt</span><span class="p">;</span>
    <span class="c1">// empty rlt for empty tree
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">rlt</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">qu</span><span class="p">;</span>
    <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">qu</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">qz</span> <span class="o">=</span> <span class="n">qu</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="c1">// add the last node in the current queue
</span><span class="c1"></span>        <span class="n">rlt</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">qu</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="c1">// add nodes of next layer into the queue
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">qz</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">TreeNode</span> <span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">qu</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">qu</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">rlt</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="二叉树中所有距离为-k-的结点">二叉树中所有距离为 K 的结点</h3>
<p>题目见<a href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/" target="_blank" rel="noopener noreffer">863. 二叉树中所有距离为 K 的结点 - 力扣（LeetCode）</a>，这道题稍微有点复杂，观察给出的例子（如下图），与5的节点距离为2的节点除了4和7之外还有1，如果仅仅给出4和7是比较简单的，只要以5为根节点，记录depth = 1，套用引子中的程序，将depth = K + 1的所有的节点列出来即可。</p>
<p></p>
<p>但是往上回溯比较难，换一个思路，我们遍历整个二叉树，</p>
<ol>
<li>记录每个节点的<code>father</code>节点，<code>left</code>节点和<code>right</code>节点，将二叉树变成图，表示A与这3个节点的任意一个都是连通的；</li>
<li>初始化目标节点的<code>depth = 1</code>，以该节点为圆心，遍历所有的节点，打印出来所有<code>depth = K + 1</code>的节点</li>
</ol>
<p>第2步实际上是对BFS算法的升维，将二叉树转换为图，代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">distanceK</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">umap</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rlt</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="o">||</span> <span class="n">target</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">rlt</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/************ PART 1 ************/</span>
    <span class="c1">// find the father node of all the nodes in the tree
</span><span class="c1"></span>    <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">qu</span><span class="p">;</span>
    <span class="n">umap</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">qu</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">qz</span> <span class="o">=</span> <span class="n">qu</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">qz</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">qu</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">qu</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="c1">// father node
</span><span class="c1"></span>                <span class="n">umap</span><span class="p">[</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
                <span class="c1">// father node
</span><span class="c1"></span>                <span class="n">umap</span><span class="p">[</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/************ PART 2 ************/</span>
    <span class="c1">// find the node with depth of K
</span><span class="c1"></span>    <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">newQ</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">usedmap</span><span class="p">;</span>
    <span class="n">usedmap</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">newQ</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">newQ</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">depth</span> <span class="o">&lt;=</span> <span class="n">K</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">qz</span> <span class="o">=</span> <span class="n">newQ</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">qz</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">newQ</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">usedmap</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">newQ</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="n">K</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">rlt</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">usedmap</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">newQ</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">usedmap</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">newQ</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">umap</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">usedmap</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">umap</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">newQ</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">umap</span><span class="p">[</span><span class="n">node</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">depth</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//BFS for final rlt
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">rlt</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个程序分为前后两大部分，</p>
<ol>
<li>第一部分遍历二叉树的每一个节点，记录每个节点的父节点，这里我们使用了哈希表来保存每个节点和它的父节点；</li>
<li>第二部分就是核心代码，以target为圆心，将二叉树当作图来遍历，如果这个node有左右节点或者父节点，则表示它跟其他的节点之间联通，则使用BFS算法访问整个图网络。这里尤其要注意，遍<strong>历图需要标记当前图中的节点是否被访问过</strong>，否则会被多次重复遍历而陷入到死循环中，在这个程序里面，使用<code>usedmap</code>来做这件事，其实也可以使用<code>vector&lt;TreeNode *&gt;</code>来记录。</li>
</ol>
<p>为了方便调试，再补一个寻找target node的程序</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">TreeNode</span> <span class="o">*</span><span class="nf">FindTargetNode</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">targetVal</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">qu</span><span class="p">;</span>
    <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">qu</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">qz</span> <span class="o">=</span> <span class="n">qu</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">qz</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">qu</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">qu</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">targetVal</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="颜色交替的最短路径">颜色交替的最短路径</h3>
<p>题目见<a href="https://leetcode-cn.com/problems/shortest-path-with-alternating-colors/" target="_blank" rel="noopener noreffer">1129. 颜色交替的最短路径 - 力扣（LeetCode）</a>，这道题难度要大一点，但是后面的方法仍然是BFS，代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="k">enum</span> <span class="nc">color</span> <span class="p">{</span><span class="n">RED</span><span class="p">,</span> <span class="n">BLUE</span><span class="p">};</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">shortestAlternatingPaths</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">red_edges</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">blue_edges</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// 由于存在自环或者平行边，所以定义哈希表保存每个结点对应的多条边并初始化
</span><span class="c1"></span>        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">redGraph</span><span class="p">;</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">blueGraph</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">red</span> <span class="p">:</span> <span class="n">red_edges</span><span class="p">)</span> <span class="n">redGraph</span><span class="p">[</span><span class="n">red</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="n">push_back</span><span class="p">(</span><span class="n">red</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">blue</span> <span class="p">:</span> <span class="n">blue_edges</span><span class="p">)</span> <span class="n">blueGraph</span><span class="p">[</span><span class="n">blue</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="n">push_back</span><span class="p">(</span><span class="n">blue</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

        <span class="k">const</span> <span class="kt">int</span> <span class="n">colorNum</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">maxNode</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

        <span class="c1">// 由于存在环和平行边，用数组 visit[x][y][color]=true 代表从节点x到节点y的且颜色为color的边被访问过，防止重复访问
</span><span class="c1"></span>        <span class="c1">// 第三维[2]有两维，第0维代表红色是否访问，第1维代表蓝色是否访问
</span><span class="c1"></span>        <span class="c1">// 所有的点初始化为0代表为被访问过
</span><span class="c1"></span>        <span class="kt">bool</span> <span class="n">visited</span><span class="p">[</span><span class="n">maxNode</span><span class="p">][</span><span class="n">maxNode</span><span class="p">][</span><span class="n">colorNum</span><span class="p">];</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">visited</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">visited</span><span class="p">));</span>

        <span class="c1">// step用于记录当前的步长，即从节点0到各节点的步长，从0逐渐+1自增
</span><span class="c1"></span>        <span class="c1">// res代表节点 0 到节点 X 的最短路径的长度，初始化为最大值
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>

        <span class="c1">// 定义队列进行BFS，并进行初始化，pair&lt;int, int&gt;的意思是 &lt;当前节点, 路径上颜色&gt;
</span><span class="c1"></span>        <span class="c1">// 队列初始化先进&lt;0, 1&gt;, 再进&lt;0, 0&gt;，即我们先访问蓝色，再访问红色。
</span><span class="c1"></span>        <span class="n">queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">color</span><span class="o">&gt;&gt;</span> <span class="n">myQue</span><span class="p">;</span> <span class="c1">// &lt;node, color&gt; means start from node and select the edge with color
</span><span class="c1"></span>        <span class="n">myQue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">BLUE</span><span class="p">));</span>
        <span class="n">myQue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">RED</span><span class="p">));</span>

        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">myQue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">myQue</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
            <span class="o">++</span><span class="n">step</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// 队首元素出队列，得到其节点，以及颜色
</span><span class="c1"></span>                <span class="kt">int</span> <span class="n">curNode</span> <span class="o">=</span> <span class="n">myQue</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">first</span><span class="p">;</span>
                <span class="kt">int</span> <span class="n">curColor</span> <span class="o">=</span> <span class="n">myQue</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">second</span><span class="p">;</span>
                <span class="n">myQue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

                <span class="c1">//若当前已访问的为蓝色边，希望下一个节点的边是红色；反之亦然
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">curColor</span> <span class="o">==</span> <span class="n">BLUE</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="c1">// 遍历当前节点每一个相邻的节点，寻找相连的红色边
</span><span class="c1"></span>                    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">nextNode</span> <span class="p">:</span> <span class="n">blueGraph</span><span class="p">[</span><span class="n">curNode</span><span class="p">])</span>
                    <span class="p">{</span>
                        <span class="c1">// 如果 curNode 和 nextNode 相连的红色边未被访问过，访问并加入队列
</span><span class="c1"></span>                        <span class="c1">// 同时需要更新两点之间的最短路径
</span><span class="c1"></span>                        <span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">curNode</span><span class="p">][</span><span class="n">nextNode</span><span class="p">][</span><span class="n">RED</span><span class="p">]</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="n">res</span><span class="p">[</span><span class="n">nextNode</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">nextNode</span><span class="p">],</span> <span class="n">step</span><span class="p">);</span>

                            <span class="c1">// make_pair&lt;nextNode, 0&gt; 的含义是标记当前访问的边为红色，下次应该访问蓝色的
</span><span class="c1"></span>                            <span class="n">myQue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">nextNode</span><span class="p">,</span> <span class="n">RED</span><span class="p">));</span>
                            <span class="n">visited</span><span class="p">[</span><span class="n">curNode</span><span class="p">][</span><span class="n">nextNode</span><span class="p">][</span><span class="n">RED</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">curColor</span> <span class="o">==</span> <span class="n">RED</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="c1">// 遍历当前节点每一个相邻的节点，寻找相连的蓝色边
</span><span class="c1"></span>                    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">nextNode</span> <span class="p">:</span> <span class="n">redGraph</span><span class="p">[</span><span class="n">curNode</span><span class="p">])</span>
                    <span class="p">{</span>
                        <span class="c1">// 如果 curNode 和 nextNode 相连的蓝色边未被访问过，访问并加入队列
</span><span class="c1"></span>                        <span class="c1">// 同时需要更新两点之间的最短路径
</span><span class="c1"></span>                        <span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">curNode</span><span class="p">][</span><span class="n">nextNode</span><span class="p">][</span><span class="n">BLUE</span><span class="p">]</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="n">res</span><span class="p">[</span><span class="n">nextNode</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">nextNode</span><span class="p">],</span> <span class="n">step</span><span class="p">);</span>

                            <span class="c1">// make_pair&lt;nextNode, 1&gt; 的含义是标记当前访问的边为蓝色，下次应该访问红色的
</span><span class="c1"></span>                            <span class="n">myQue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">nextNode</span><span class="p">,</span> <span class="n">BLUE</span><span class="p">));</span>
                            <span class="n">visited</span><span class="p">[</span><span class="n">curNode</span><span class="p">][</span><span class="n">nextNode</span><span class="p">][</span><span class="n">BLUE</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 根据题意，0 到自身的距离为0；在上述操作后，若 0 到其他节点距离仍为INT_MAX，说明不存在符合要求的路径，设置为-1；
</span><span class="c1"></span>        <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">INT_MAX</span><span class="p">)</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>

    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>从代码可以看出，</p>
<ol>
<li>使用<code>blueGraph/redGraph</code>保存图中的节点，数据结构是哈希 +  vector，哈希的键是节点，值是和该节点直接相连的其他节点；</li>
<li>使用<code>visited</code>三维数组标识节点是否被访问过的信息；</li>
<li>使用队列<code>myQueue</code>保存BFS中的node，这个队列中的元素是<code>&lt;node, expectColor&gt;</code>，即从<code>node</code>出发，从<code>node</code>起始的边的颜色，如果存在这样的边，那么将这条边的终点node和它的下一条不同颜色的边push进队列，循环往复直到所有的边都被访问到为止。</li>
</ol>
<h3 id="接雨水-ii">接雨水 II</h3>
<p>题目见<a href="https://leetcode-cn.com/problems/trapping-rain-water-ii/" target="_blank" rel="noopener noreffer">407. 接雨水 II - 力扣（LeetCode）</a>，「待补充」。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.wikiwand.com/zh-hans/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2" target="_blank" rel="noopener noreffer">深度优先搜索 - Wikiwand</a>，维基百科介绍</li>
<li><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/bfs-kuang-jia" target="_blank" rel="noopener noreffer">BFS 算法解题套路框架 - labuladong的算法小抄</a>，非常直观富有启发性的介绍文章</li>
<li><a href="https://www.cnblogs.com/python27/archive/2011/12/09/2282486.html" target="_blank" rel="noopener noreffer">【算法16】递归算法的时间复杂度终结篇 - python27 - 博客园</a>，如何评价递归算法的复杂度</li>
<li><a href="https://developer.aliyun.com/article/756316" target="_blank" rel="noopener noreffer">图文详解 DFS 和 BFS | 算法必看系列知识二十四-阿里云开发者社区</a>，图解DFS和BFS的过程</li>
</ul>]]></description>
</item></channel>
</rss>
