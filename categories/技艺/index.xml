<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>技艺 - 分类 - Dive Into Think</title>
        <link>https://bugxch.github.io/categories/%E6%8A%80%E8%89%BA/</link>
        <description>技艺 - 分类 - Dive Into Think</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>bugxch@126.com (bugxch)</managingEditor>
            <webMaster>bugxch@126.com (bugxch)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 16 Aug 2020 22:31:31 &#43;0800</lastBuildDate><atom:link href="https://bugxch.github.io/categories/%E6%8A%80%E8%89%BA/" rel="self" type="application/rss+xml" /><item>
    <title>LeetCode区间问题总结</title>
    <link>https://bugxch.github.io/intersection/</link>
    <pubDate>Sun, 16 Aug 2020 22:31:31 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://bugxch.github.io/intersection/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://cdn.pixabay.com/photo/2013/07/18/20/26/sea-164989_960_720.jpg" referrerpolicy="no-referrer">
            </div><p>上周五考试没有过，其中专业级第二题是关于区间的问题，在leetcode上找到类似的题目，总结复习下。</p>
<h2 id="引子">引子</h2>
<p>先看这道题，<a href="https://leetcode-cn.com/problems/corporate-flight-bookings/" target="_blank" rel="noopener noreffer">1109. 航班预订统计</a>，题目是这样的</p>
<p>这里有<code>n</code> 个航班，它们分别从 1 到 n 进行编号。</p>
<p>我们这儿有一份航班预订表，表中第 <code>i</code> 条预订记录 <code>bookings[i] = [i, j, k]</code> 意味着我们在从 <code>i</code> 到<code> j</code> 的每个航班上预订了 <code>k</code> 个座位。</p>
<p>请你返回一个长度为 n 的数组 <code>answer</code>，按航班编号顺序返回每个航班上预订的座位数。参考示例如下，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="err">输入：</span><span class="n">bookings</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">20</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">25</span><span class="p">]],</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span>
<span class="err">输出：</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">55</span><span class="p">,</span><span class="mi">45</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">25</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="解题思路">解题思路</h3>
<p>将这道题的示例画一张表格表示一下，就是下面的结果</p>
<table>
<thead>
<tr>
<th style="text-align:center">booking</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">10</td>
<td style="text-align:center">10</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">20</td>
<td style="text-align:center">20</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">25</td>
<td style="text-align:center">25</td>
<td style="text-align:center">25</td>
<td style="text-align:center">25</td>
</tr>
<tr>
<td style="text-align:center">total</td>
<td style="text-align:center">10</td>
<td style="text-align:center">55</td>
<td style="text-align:center">45</td>
<td style="text-align:center">25</td>
<td style="text-align:center">25</td>
</tr>
</tbody>
</table>
<p>常规思路就是以航班号为基本坐标，计算每一个航班增加的座位数，然后逐项汇总相加即可。</p>
<ol>
<li>设置初始结果<code>vector&lt;int&gt; res(n, 0)</code>;</li>
<li>遍历<code>bookings</code>，每次取其中的航班的预定数，添加到<code>res</code>对应的数组中，比如第1个booking，那么<code>res[0]+=10; res[1]+=10</code>，依次类推，直到遍历截止。</li>
</ol>
<p>上面的算法比较简单直观，但是可以分析发现，算法的复杂度有点高，两层遍历算法时间复杂度是$O(n^2)$，空间复杂度是$O(n)$不甚理想。</p>
<p>有没有复杂度更简单的思路呢？这里有一个类比<strong>公交站的思路</strong>，可以将航班号码比作公交站牌，比如1号公交站，2号公交站，假定这些公交站是依次按顺序分布在一条直线公路上，<strong>第<code>i</code>个航班的飞机的预定数目就是公交车在第<code>i</code>个公交站发车时候的乘客数目（包括了上车和下车的乘客数</strong>）。</p>
<p>举例说明，第1行表示，第1站交车上人数是10，说明公交车行驶到第1站时上车10人，到第2站时候车上的乘客仍然是10人，说明没有乘客上下车，到第3站时候车上乘客0人，说明此时有10人下车。如果使用长度为<code>N</code>的数组<code>count</code>表示每一站<strong>上下乘客的变化量</strong>(<code>count[i]</code> 表示第<code>i + 1</code>站上下车的乘客变化量），</p>
<blockquote>
<p>对于<code>booking = [i,j,k]</code>，</p>
<ol>
<li>表示在公交站第<code>i</code>站上车<code>k</code>人，<code>count[i - 1] += k</code>；</li>
<li>第<code>i + 1</code>站直到第<code>j</code>站都没有乘客上下车，<code>count[i],...,count[j - 1]</code>无操作；</li>
<li>在第<code>j + 1</code>站下车<code>k</code>人，所以<code>count[j] -= k</code></li>
</ol>
</blockquote>
<p>为了方便起见，<strong>我们缩小问题的规模，以具体的数字代替抽象的代数字母</strong>，假如我们就只有3个公交站，取示例中的前2行，</p>
<ol>
<li>公交车刚开始上的人数是0，<code>vector&lt;int&gt; count(4, 0)</code>；</li>
<li>读取第1行，到达第1站，公交车上10人，说明<strong>上车10人，无人下车，<code>count[0]+= 10</code></strong>，到达第2站公交车上依然是10人，说明也<strong>无人上车和下车</strong>，到达第3站，公交车上0人，说明<strong>10人下车，<code>count[2] -= 10</code></strong>；</li>
<li>读取第2行，公交车到达第2站，公交车上20人，说明<strong>上车20人无人下车，<code>count[1] += 20</code></strong>，第3站车上20人，说明<strong>无人下车</strong>，第4站车上0人，说明<strong>有20人下车, <code>count[3]-=20</code></strong>。</li>
</ol>
<p>遍历结束，得到<code>count = {10, 20, -10，-20}</code>，那么最后每个站点的乘客数就很清楚了，到达第1站前车上乘客0人，到达后上车10人，所以第1站发车前车上10人，第2站到站后上车20人，所以第2站发车前车上乘客10 + 20  = 30人，第3站到站后下车10人，所以发车前车上乘客 30 - 10 = 20人。意思搞清楚之后，代码就很好写了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">corpFlightBookings</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">bookings</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">counter</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">booking</span> <span class="p">:</span> <span class="n">bookings</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">booking</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">booking</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="c1">// 记录每个booking的开始和结尾即可，中间的站点人数无变化
</span><span class="c1"></span>            <span class="n">counter</span><span class="p">[</span><span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">booking</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// start站上车
</span><span class="c1"></span>            <span class="n">counter</span><span class="p">[</span><span class="n">end</span><span class="p">]</span> <span class="o">-=</span> <span class="n">booking</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// end + 1站下车
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">counter</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">counter</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>时间复杂度为$O(n)$。</p>
<h2 id="通用框架">通用框架</h2>
<p>「待补充」</p>
<h2 id="典型题目">典型题目</h2>
<p>「待补充」</p>
<h3 id="no-986-区间列表交集">No. 986 区间列表交集</h3>
<p>题目的链接参考<a href="https://leetcode-cn.com/problems/interval-list-intersections/" target="_blank" rel="noopener noreffer">986. 区间列表的交集 - 力扣（LeetCode）</a>，</p>
<h3 id="no-452-引爆气球">No. 452 引爆气球</h3>
<p>题目链接参考<a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener noreffer">452. 用最少数量的箭引爆气球 - 力扣（LeetCode）</a>，这道题目使用<strong>贪心法</strong>，将气球的坐标放在坐标轴上，然后从0开始从左到右逐气球扫描，查看是否有交集，图示如下。</p>
<h2 id="参考资料">参考资料</h2>
<p>「待补充」</p>]]></description>
</item><item>
    <title>「转载」C&#43;&#43;中的sort函数（一）</title>
    <link>https://bugxch.github.io/sort_intro/</link>
    <pubDate>Sat, 15 Aug 2020 21:25:46 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://bugxch.github.io/sort_intro/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://pic.imgdb.cn/item/6002ed073ffa7d37b305c866.jpg" referrerpolicy="no-referrer">
            </div><p>公司认证的leetcode题目中经常会用到sort函数，不是很熟悉，今天系统学习总结下。</p>
<h2 id="总述">总述</h2>
<p>下面是C++的stl中的排序的所有函数，这个系列的博客会逐一介绍，这次的博客先关注最常用的<code>sort</code>函数。</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>sort (first, last)</td>
<td>对容器或普通数组中 [first, last) 范围内的元素进行排序，默认进行升序排序。</td>
</tr>
<tr>
<td>stable_sort (first, last)</td>
<td>和 sort() 函数功能相似，不同之处在于，对于 [first, last) 范围内值相同的元素，该函数不会改变它们的相对位置。</td>
</tr>
<tr>
<td>partial_sort (first, middle, last)</td>
<td>从 [first,last) 范围内，筛选出 muddle-first 个最小的元素并排序存放在 [first，middle) 区间中。</td>
</tr>
<tr>
<td>partial_sort_copy (first, last, result_first, result_last)</td>
<td>从 [first, last) 范围内筛选出 result_last-result_first 个元素排序并存储到 [result_first, result_last) 指定的范围中。</td>
</tr>
<tr>
<td>is_sorted (first, last)</td>
<td>检测 [first, last) 范围内是否已经排好序，默认检测是否按升序排序。</td>
</tr>
<tr>
<td>is_sorted_until (first, last)</td>
<td>和 is_sorted() 函数功能类似，唯一的区别在于，如果 [first, last) 范围的元素没有排好序，则该函数会返回一个指向首个不遵循排序规则的元素的迭代器。</td>
</tr>
<tr>
<td>void nth_element (first, nth, last)</td>
<td>找到 [first, last) 范围内按照排序规则（默认按照升序排序）应该位于第 nth 个位置处的元素，并将其放置到此位置。同时使该位置左侧的所有元素都比其存放的元素小，该位置右侧的所有元素都比其存放的元素大。</td>
</tr>
</tbody>
</table>
<h2 id="sort函数">sort函数</h2>
<h3 id="使用范围">使用范围</h3>
<p>C++ STL 标准库中的 sort() 函数，本质就是一个模板函数。正如表 1 中描述的，该函数专门用来对容器或普通数组中指定范围内的元素进行排序，排序规则默认以元素值的大小做升序排序，除此之外我们也可以选择标准库提供的其它排序规则（比如<code>std::greater&lt;T&gt;</code>降序排序规则），甚至还可以自定义排序规则。</p>
<p>需要注意的是，sort() 函数受到底层实现方式的限制，它仅适用于普通数组和部分类型的容器。换句话说，只有普通数组和具备以下条件的容器，才能使用 sort() 函数：</p>
<ol>
<li>容器支持的迭代器类型必须为随机访问迭代器。这意味着，sort() 只对 array、vector、deque 这 3 个容器提供支持；</li>
<li>如果对容器中指定区域的元素做默认升序排序，则元素类型必须支持<code>&lt;</code>小于运算符；同样，如果选用标准库提供的其它排序规则，元素类型也必须支持该规则底层实现所用的比较运算符；</li>
<li>sort() 函数在实现排序时，需要交换容器中元素的存储位置。这种情况下，如果容器中存储的是自定义的类对象，则该类的内部必须提供移动构造函数和移动赋值运算符。</li>
</ol>
<h3 id="局限">局限</h3>
<p><code>sort</code>函数不保证排序的<a href="https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%A8%B3%E5%AE%9A%E6%80%A7" target="_blank" rel="noopener noreffer">稳定性</a>，即如果被排序的序列中有多个相同值的元素，并不能保证排序之后他们的相对位置保持不变。</p>
<h3 id="使用方法">使用方法</h3>
<p>值得一提的是，sort() 函数位于<code>&lt;algorithm&gt;</code>头文件中，因此在使用该函数前，程序中应包含如下语句：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">#include &lt;algorithm&gt;
</code></pre></td></tr></table>
</div>
</div><p>sort() 函数有 2 种用法，其语法格式分别为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">//对 [first, last) 区域内的元素做默认的升序排序
void sort (RandomAccessIterator first, RandomAccessIterator last);
//按照指定的 comp 排序规则，对 [first, last) 区域内的元素进行排序
void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);
</code></pre></td></tr></table>
</div>
</div><p>其中，first 和 last 都为随机访问迭代器，它们的组合 [first, last) 用来指定要排序的目标区域；另外在第 2 种格式中，comp 可以是 C++ STL 标准库提供的排序规则（比如 std::greater<T>），也可以是自定义的排序规则。比如，如果需要做<strong>降序</strong>排序，那么可以使用<code>std::less&lt;T&gt;</code>，也可以自己写一个降序的函数。具体的用法如下所示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;     // std::cout</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;    // std::sort</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;       // std::vector</span><span class="cp">
</span><span class="cp"></span><span class="c1">//以普通函数的方式实现自定义排序规则
</span><span class="c1"></span><span class="kt">bool</span> <span class="nf">mycomp</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//以函数对象的方式实现自定义排序规则
</span><span class="c1"></span><span class="k">class</span> <span class="nc">mycomp2</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myvector</span><span class="p">{</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">71</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">33</span> <span class="p">};</span>
    <span class="c1">//调用第一种语法格式，对 32、71、12、45 进行排序
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">//(12 32 45 71) 26 80 53 33
</span><span class="c1"></span>    <span class="c1">//调用第二种语法格式，利用STL标准库提供的其它比较规则（比如 greater&lt;T&gt;）进行排序
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span> <span class="c1">//(71 45 32 12) 26 80 53 33
</span><span class="c1"></span>
    <span class="c1">//调用第二种语法格式，通过自定义比较规则进行排序
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myvector</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">mycomp2</span><span class="p">());</span><span class="c1">// 80 71 53 45 33 32 26 12
</span><span class="c1"></span>    <span class="n">sort</span><span class="p">(</span><span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">myvector</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">mycomp</span><span class="p">);</span> <span class="c1">// 80 71 53 45 12 26 32 33
</span><span class="c1"></span>    <span class="c1">//输出 myvector 容器中的元素
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">myvector</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">myvector</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="http://c.biancheng.net/view/7457.html" target="_blank" rel="noopener noreffer">C++ sort()排序函数用法详解</a>，c语言中文网的介绍</li>
<li><a href="https://www.geeksforgeeks.org/sort-c-stl/" target="_blank" rel="noopener noreffer">std::sort() in C++ STL - GeeksforGeeks</a>，国外的网站介绍</li>
</ul>]]></description>
</item><item>
    <title>广度优先搜索详解</title>
    <link>https://bugxch.github.io/dfs_intro/</link>
    <pubDate>Sat, 08 Aug 2020 11:24:24 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://bugxch.github.io/dfs_intro/</guid>
    <description><![CDATA[<p>总结一下广度优先搜索的原理和用法。</p>
<p></p>
<h2 id="引子">引子</h2>
<p>先看这道题<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener noreffer">104. 二叉树的最大深度</a>，题目中给出一个二叉树，求这个二叉树的最大深度。例子中给出下面的二叉树</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">    <span class="m">3</span>
   / <span class="se">\
</span><span class="se"></span>  <span class="m">9</span>  <span class="m">20</span>
    /  <span class="se">\
</span><span class="se"></span>   <span class="m">15</span>   <span class="m">7</span>
</code></pre></td></tr></table>
</div>
</div><p>这个如何解决呢？肉眼可见，最大深度是3。</p>
<h3 id="构建二叉树">构建二叉树</h3>
<p>首先为了便于调试，需要构建一颗二叉树，题目中的给出的是二叉树的层序遍历的结果，我们用<code>INT_MAX</code>代替null，使用如下函数构造二叉树</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">ConstructBinTree</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">nodes</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">INT_MAX</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">root</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">iq</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">id</span><span class="o">++</span><span class="p">];</span>
    <span class="n">iq</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">iq</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="n">nodes</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">TreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">iq</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">iq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

        <span class="c1">// check vectors for left node
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INT_MAX</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">leftNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">;</span>
            <span class="n">leftNode</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">leftNode</span><span class="p">;</span>
            <span class="n">iq</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">leftNode</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">id</span><span class="o">++</span><span class="p">;</span>
		
        <span class="c1">// add right node
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INT_MAX</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">rightNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">;</span>
            <span class="n">rightNode</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">rightNode</span><span class="p">;</span>
            <span class="n">iq</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">rightNode</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">id</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>下面是中序遍历二叉树</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">void</span> <span class="nf">ScanBinMiddle</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">tree</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tree</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// handle value
</span><span class="c1"></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ScanBinMiddle</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ScanBinMiddle</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="递归解法">递归解法</h3>
<p>二叉树的比较普遍的解法是使用递归，我们需要找出递归的关系式，然后用程序写出来。递归解决问题的思路包括下面两点</p>
<h4 id="描述变量">描述变量</h4>
<p>我们有一个关于目标变量的描述，在这个题目中目标变量是整棵树的最大深度，放弃整体的概念，假设你站在根节点往下看，会看到它有左右两个子树，每棵树又有自己的节点和深度。所以假定推导的变量是</p>
<blockquote>
<p><code>maxdepth[node]</code>表示以<code>node</code>为根节点的树的最大深度</p>
</blockquote>
<h4 id="递归关系式">递归关系式</h4>
<p>查看这个值和左右子树的关系是什么？3这个node的最大深度是9这个node最大深度和20这个node的最大深度的最大值 + 1，重新表述下就是下面的关系式<code>maxD[node] = max(maxD[node-&gt;left], maxD[node-&gt;right]) + 1</code>。</p>
<h4 id="终止条件">终止条件</h4>
<p>终止条件比较简单，在访问到null节点的时候返回0即可，因为以这个节点为根的树是不存在的，所以深度为0。于是有下面的代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> 
<span class="p">{</span>	
    <span class="c1">// 终止条件
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
	<span class="c1">// 关系式
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">),</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="广度优先搜索算法bfs">广度优先搜索算法（BFS）</h3>
<p>不使用递归，还有另一种解法，一层层观察整棵树，第一层1个节点，第二层2个节点，第三层2个节点。每一层的节点之间使用左右子树联系起来，所以根据第1层的节点可以访问第2层的节点，根据第2层的节点可以访问第3层的节点，所以可以这么做。记录整棵树最深的深度是<code>maxdepth = 0</code>，</p>
<ol>
<li>访问第一层的根节点，如果非空则<code>maxdepth++</code>，否则返回；</li>
<li>查看第一层的根节点是否有左右子树，有的话再分别访问左子树和右子树，<code>maxdepth++</code>；</li>
<li>循环步骤2，直到所有的节点都被访问到。</li>
</ol>
<p>这里可以使用<strong>队列</strong>保存需要被访问的节点，如下图所示，分别在头和尾弹出和插入节点，</p>
<p></p>
<p>结合上面的步骤，<code>depth = 1</code>，将root的根节点添加到队列结尾</p>
<ol>
<li>我们一次将一层的节点放入到队列中；</li>
<li>判断当前队列是否为空。
<ul>
<li>如果当前的队列不为空，那么将队列中的每个节点pop出来之后再考察这个节点的左右子树，如果有就将它们插入到队列的尾巴，<code>depth++</code>；</li>
<li>如果当前队列为空，return</li>
</ul>
</li>
</ol>
<p>所以有了下面的代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="c1">// 如果为空，那么返回0
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">qu</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// 添加根节点
</span><span class="c1"></span>    <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">qu</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">qz</span> <span class="o">=</span> <span class="n">qu</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">qz</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 考察队列中的每个节点，是否有左子树和右子树
</span><span class="c1"></span>            <span class="n">TreeNode</span> <span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">qu</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">qu</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="c1">// 如果有左右子节点，那么添加到队列中
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">depth</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">depth</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>下图是资料3中的图示过程，简单明了。</p>
<p></p>
<h2 id="数据结构">数据结构</h2>
<h3 id="队列">队列</h3>
<p>使用<strong>队列</strong>保存每一层的节点，如下图所示，队列是先进先出的数据结构，包括如下的属性和方法</p>
<p></p>
<ul>
<li>队列头（front），表示队列最开始的元素；</li>
<li>队列尾（rear），表示队列最后加入的元素；</li>
<li>队列长度，当前的队列长度，就是rear - front + 1；</li>
<li>出队（pop），队列头弹出，队列长度-1，front++；</li>
<li>入队（push），队列尾添加元素，队列长度+1，rear++</li>
</ul>
<h3 id="stl中的queue">STL中的queue</h3>
<p>C++的stl使用queue表示队列，常用的操作和属性如下表所示</p>
<ul>
<li><code>front()</code>：返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</li>
<li><code>back()</code>：返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</li>
<li><code>push(const T&amp; obj)</code>：在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。</li>
<li><code>push(T&amp;&amp; obj)</code>：以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。</li>
<li><code>pop()</code>：删除 queue 中的第一个元素。</li>
<li><code>size()</code>：返回 queue 中元素的个数。</li>
<li><code>empty()</code>：如果 queue 中没有元素的话，返回 true。</li>
<li><code>emplace()</code>：用传给 emplace() 的参数调用 T 的构造函数，在 queue 的尾部生成对象。</li>
<li><code>swap(queue&lt;T&gt; &amp;other_q)</code>：将当前 queue 中的元素和参数 queue 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。</li>
</ul>
<p>典型的使用方法如下，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// CPP program to illustrate 
</span><span class="c1">// Application of push() and pop() function 
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt; </span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;queue&gt; </span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span> 

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span> 
	<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
	<span class="c1">// Empty Queue 
</span><span class="c1"></span>	<span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myqueue</span><span class="p">;</span> 
	<span class="n">myqueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> 
	<span class="n">myqueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">13</span><span class="p">);</span> 
	<span class="n">myqueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> 
	<span class="n">myqueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span> 
	<span class="n">myqueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> 
	<span class="c1">// queue becomes 5, 13, 0, 9, 4 
</span><span class="c1"></span>
	<span class="c1">// Counting number of elements in queue 
</span><span class="c1"></span>	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">myqueue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span> 
		<span class="n">myqueue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span> 
		<span class="n">c</span><span class="o">++</span><span class="p">;</span> 
	<span class="p">}</span> 
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">;</span> 
<span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><h2 id="典型题目">典型题目</h2>
<h3 id="二叉树的右视图">二叉树的右视图</h3>
<p>题目链接见<a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener noreffer">199. 二叉树的右视图 - 力扣（LeetCode）</a>，如果有了上面题目的框架，这个题目其实很简单，既然每次遍历队列保存的<strong>这一层所有节点</strong>，而且节点的顺序是从左到右保存的，所以可以在每一层遍历的时候将队列的最后一个node加入到这个vector中，代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rightSideView</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rlt</span><span class="p">;</span>
    <span class="c1">// empty rlt for empty tree
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">rlt</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">qu</span><span class="p">;</span>
    <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">qu</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">qz</span> <span class="o">=</span> <span class="n">qu</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="c1">// add the last node in the current queue
</span><span class="c1"></span>        <span class="n">rlt</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">qu</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="c1">// add nodes of next layer into the queue
</span><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">qz</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">TreeNode</span> <span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">qu</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">qu</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">rlt</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="二叉树中所有距离为-k-的结点">二叉树中所有距离为 K 的结点</h3>
<p>题目见<a href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/" target="_blank" rel="noopener noreffer">863. 二叉树中所有距离为 K 的结点 - 力扣（LeetCode）</a>，这道题稍微有点复杂，观察给出的例子（如下图），与5的节点距离为2的节点除了4和7之外还有1，如果仅仅给出4和7是比较简单的，只要以5为根节点，记录depth = 1，套用引子中的程序，将depth = K + 1的所有的节点列出来即可。</p>
<p></p>
<p>但是往上回溯比较难，换一个思路，我们遍历整个二叉树，</p>
<ol>
<li>记录每个节点的<code>father</code>节点，<code>left</code>节点和<code>right</code>节点，将二叉树变成图，表示A与这3个节点的任意一个都是连通的；</li>
<li>初始化目标节点的<code>depth = 1</code>，以该节点为圆心，遍历所有的节点，打印出来所有<code>depth = K + 1</code>的节点</li>
</ol>
<p>第2步实际上是对BFS算法的升维，将二叉树转换为图，代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">distanceK</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">target</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">umap</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">rlt</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="o">||</span> <span class="n">target</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">rlt</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/************ PART 1 ************/</span>
    <span class="c1">// find the father node of all the nodes in the tree
</span><span class="c1"></span>    <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">qu</span><span class="p">;</span>
    <span class="n">umap</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">qu</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">qz</span> <span class="o">=</span> <span class="n">qu</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">qz</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">qu</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">qu</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
                <span class="c1">// father node
</span><span class="c1"></span>                <span class="n">umap</span><span class="p">[</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
                <span class="c1">// father node
</span><span class="c1"></span>                <span class="n">umap</span><span class="p">[</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cm">/************ PART 2 ************/</span>
    <span class="c1">// find the node with depth of K
</span><span class="c1"></span>    <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">newQ</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">usedmap</span><span class="p">;</span>
    <span class="n">usedmap</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">newQ</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">newQ</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">depth</span> <span class="o">&lt;=</span> <span class="n">K</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">qz</span> <span class="o">=</span> <span class="n">newQ</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">qz</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">newQ</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">usedmap</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">newQ</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">==</span> <span class="n">K</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">rlt</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">usedmap</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">newQ</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">usedmap</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">newQ</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">umap</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">usedmap</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">umap</span><span class="p">[</span><span class="n">node</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">newQ</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">umap</span><span class="p">[</span><span class="n">node</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">depth</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//BFS for final rlt
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">rlt</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个程序分为前后两大部分，</p>
<ol>
<li>第一部分遍历二叉树的每一个节点，记录每个节点的父节点，这里我们使用了哈希表来保存每个节点和它的父节点；</li>
<li>第二部分就是核心代码，以target为圆心，将二叉树当作图来遍历，如果这个node有左右节点或者父节点，则表示它跟其他的节点之间联通，则使用BFS算法访问整个图网络。这里尤其要注意，遍<strong>历图需要标记当前图中的节点是否被访问过</strong>，否则会被多次重复遍历而陷入到死循环中，在这个程序里面，使用<code>usedmap</code>来做这件事，其实也可以使用<code>vector&lt;TreeNode *&gt;</code>来记录。</li>
</ol>
<p>为了方便调试，再补一个寻找target node的程序</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">TreeNode</span> <span class="o">*</span><span class="nf">FindTargetNode</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">targetVal</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span> <span class="o">*&gt;</span> <span class="n">qu</span><span class="p">;</span>
    <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">qu</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">qz</span> <span class="o">=</span> <span class="n">qu</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">qz</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">TreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">qu</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
            <span class="n">qu</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">targetVal</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">qu</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="颜色交替的最短路径">颜色交替的最短路径</h3>
<p>题目见<a href="https://leetcode-cn.com/problems/shortest-path-with-alternating-colors/" target="_blank" rel="noopener noreffer">1129. 颜色交替的最短路径 - 力扣（LeetCode）</a>，这道题难度要大一点，但是后面的方法仍然是BFS，代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="k">enum</span> <span class="nc">color</span> <span class="p">{</span><span class="n">RED</span><span class="p">,</span> <span class="n">BLUE</span><span class="p">};</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">shortestAlternatingPaths</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">red_edges</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">blue_edges</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// 由于存在自环或者平行边，所以定义哈希表保存每个结点对应的多条边并初始化
</span><span class="c1"></span>        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">redGraph</span><span class="p">;</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">blueGraph</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">red</span> <span class="p">:</span> <span class="n">red_edges</span><span class="p">)</span> <span class="n">redGraph</span><span class="p">[</span><span class="n">red</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="n">push_back</span><span class="p">(</span><span class="n">red</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">blue</span> <span class="p">:</span> <span class="n">blue_edges</span><span class="p">)</span> <span class="n">blueGraph</span><span class="p">[</span><span class="n">blue</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="n">push_back</span><span class="p">(</span><span class="n">blue</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

        <span class="k">const</span> <span class="kt">int</span> <span class="n">colorNum</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">maxNode</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

        <span class="c1">// 由于存在环和平行边，用数组 visit[x][y][color]=true 代表从节点x到节点y的且颜色为color的边被访问过，防止重复访问
</span><span class="c1"></span>        <span class="c1">// 第三维[2]有两维，第0维代表红色是否访问，第1维代表蓝色是否访问
</span><span class="c1"></span>        <span class="c1">// 所有的点初始化为0代表为被访问过
</span><span class="c1"></span>        <span class="kt">bool</span> <span class="n">visited</span><span class="p">[</span><span class="n">maxNode</span><span class="p">][</span><span class="n">maxNode</span><span class="p">][</span><span class="n">colorNum</span><span class="p">];</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">visited</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">visited</span><span class="p">));</span>

        <span class="c1">// step用于记录当前的步长，即从节点0到各节点的步长，从0逐渐+1自增
</span><span class="c1"></span>        <span class="c1">// res代表节点 0 到节点 X 的最短路径的长度，初始化为最大值
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">);</span>

        <span class="c1">// 定义队列进行BFS，并进行初始化，pair&lt;int, int&gt;的意思是 &lt;当前节点, 路径上颜色&gt;
</span><span class="c1"></span>        <span class="c1">// 队列初始化先进&lt;0, 1&gt;, 再进&lt;0, 0&gt;，即我们先访问蓝色，再访问红色。
</span><span class="c1"></span>        <span class="n">queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">color</span><span class="o">&gt;&gt;</span> <span class="n">myQue</span><span class="p">;</span> <span class="c1">// &lt;node, color&gt; means start from node and select the edge with color
</span><span class="c1"></span>        <span class="n">myQue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">BLUE</span><span class="p">));</span>
        <span class="n">myQue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">RED</span><span class="p">));</span>

        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">myQue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">myQue</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
            <span class="o">++</span><span class="n">step</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// 队首元素出队列，得到其节点，以及颜色
</span><span class="c1"></span>                <span class="kt">int</span> <span class="n">curNode</span> <span class="o">=</span> <span class="n">myQue</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">first</span><span class="p">;</span>
                <span class="kt">int</span> <span class="n">curColor</span> <span class="o">=</span> <span class="n">myQue</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">second</span><span class="p">;</span>
                <span class="n">myQue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

                <span class="c1">//若当前已访问的为蓝色边，希望下一个节点的边是红色；反之亦然
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">curColor</span> <span class="o">==</span> <span class="n">BLUE</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="c1">// 遍历当前节点每一个相邻的节点，寻找相连的红色边
</span><span class="c1"></span>                    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">nextNode</span> <span class="p">:</span> <span class="n">blueGraph</span><span class="p">[</span><span class="n">curNode</span><span class="p">])</span>
                    <span class="p">{</span>
                        <span class="c1">// 如果 curNode 和 nextNode 相连的红色边未被访问过，访问并加入队列
</span><span class="c1"></span>                        <span class="c1">// 同时需要更新两点之间的最短路径
</span><span class="c1"></span>                        <span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">curNode</span><span class="p">][</span><span class="n">nextNode</span><span class="p">][</span><span class="n">RED</span><span class="p">]</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="n">res</span><span class="p">[</span><span class="n">nextNode</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">nextNode</span><span class="p">],</span> <span class="n">step</span><span class="p">);</span>

                            <span class="c1">// make_pair&lt;nextNode, 0&gt; 的含义是标记当前访问的边为红色，下次应该访问蓝色的
</span><span class="c1"></span>                            <span class="n">myQue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">nextNode</span><span class="p">,</span> <span class="n">RED</span><span class="p">));</span>
                            <span class="n">visited</span><span class="p">[</span><span class="n">curNode</span><span class="p">][</span><span class="n">nextNode</span><span class="p">][</span><span class="n">RED</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">curColor</span> <span class="o">==</span> <span class="n">RED</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="c1">// 遍历当前节点每一个相邻的节点，寻找相连的蓝色边
</span><span class="c1"></span>                    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">nextNode</span> <span class="p">:</span> <span class="n">redGraph</span><span class="p">[</span><span class="n">curNode</span><span class="p">])</span>
                    <span class="p">{</span>
                        <span class="c1">// 如果 curNode 和 nextNode 相连的蓝色边未被访问过，访问并加入队列
</span><span class="c1"></span>                        <span class="c1">// 同时需要更新两点之间的最短路径
</span><span class="c1"></span>                        <span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">curNode</span><span class="p">][</span><span class="n">nextNode</span><span class="p">][</span><span class="n">BLUE</span><span class="p">]</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="n">res</span><span class="p">[</span><span class="n">nextNode</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">nextNode</span><span class="p">],</span> <span class="n">step</span><span class="p">);</span>

                            <span class="c1">// make_pair&lt;nextNode, 1&gt; 的含义是标记当前访问的边为蓝色，下次应该访问红色的
</span><span class="c1"></span>                            <span class="n">myQue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">nextNode</span><span class="p">,</span> <span class="n">BLUE</span><span class="p">));</span>
                            <span class="n">visited</span><span class="p">[</span><span class="n">curNode</span><span class="p">][</span><span class="n">nextNode</span><span class="p">][</span><span class="n">BLUE</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// 根据题意，0 到自身的距离为0；在上述操作后，若 0 到其他节点距离仍为INT_MAX，说明不存在符合要求的路径，设置为-1；
</span><span class="c1"></span>        <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">INT_MAX</span><span class="p">)</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>

    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>从代码可以看出，</p>
<ol>
<li>使用<code>blueGraph/redGraph</code>保存图中的节点，数据结构是哈希 +  vector，哈希的键是节点，值是和该节点直接相连的其他节点；</li>
<li>使用<code>visited</code>三维数组标识节点是否被访问过的信息；</li>
<li>使用队列<code>myQueue</code>保存BFS中的node，这个队列中的元素是<code>&lt;node, expectColor&gt;</code>，即从<code>node</code>出发，从<code>node</code>起始的边的颜色，如果存在这样的边，那么将这条边的终点node和它的下一条不同颜色的边push进队列，循环往复直到所有的边都被访问到为止。</li>
</ol>
<h3 id="接雨水-ii">接雨水 II</h3>
<p>题目见<a href="https://leetcode-cn.com/problems/trapping-rain-water-ii/" target="_blank" rel="noopener noreffer">407. 接雨水 II - 力扣（LeetCode）</a>，「待补充」。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.wikiwand.com/zh-hans/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2" target="_blank" rel="noopener noreffer">深度优先搜索 - Wikiwand</a>，维基百科介绍</li>
<li><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/bfs-kuang-jia" target="_blank" rel="noopener noreffer">BFS 算法解题套路框架 - labuladong的算法小抄</a>，非常直观富有启发性的介绍文章</li>
<li><a href="https://www.cnblogs.com/python27/archive/2011/12/09/2282486.html" target="_blank" rel="noopener noreffer">【算法16】递归算法的时间复杂度终结篇 - python27 - 博客园</a>，如何评价递归算法的复杂度</li>
<li><a href="https://developer.aliyun.com/article/756316" target="_blank" rel="noopener noreffer">图文详解 DFS 和 BFS | 算法必看系列知识二十四-阿里云开发者社区</a>，图解DFS和BFS的过程</li>
</ul>]]></description>
</item><item>
    <title>滑动窗口技巧</title>
    <link>https://bugxch.github.io/slidingwindow/</link>
    <pubDate>Sun, 02 Aug 2020 15:40:45 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://bugxch.github.io/slidingwindow/</guid>
    <description><![CDATA[<p>今天主要刷leetcode的滑动窗口的题目，需要完成如下题目，本文主要记录解题思路和方法，以便加深理解记忆，答案到处都是，只有消化了才是自己的。</p>
<p></p>
<h2 id="引子">引子</h2>
<p>首先来看leetcode中No. 3的<strong>无重复字符的最长子串</strong>这个题目，参考<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener noreffer">题目链接</a>，题目很简单</p>
<blockquote>
<p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">输入: <span class="s2">&#34;abcabcbb&#34;</span>
输出: <span class="m">3</span> 
解释: 因为无重复字符的最长子串是 <span class="s2">&#34;abc&#34;</span>，所以其长度为 3。
</code></pre></td></tr></table>
</div>
</div><p>拿到题目的第一反应就是暴力解法，</p>
<ol>
<li>
<p>先暴力穷举所有的子串$S_i = [S[left], S[right])$；</p>
</li>
<li>
<p>判断这个子串，如果不含重复字符就记录子串长度$l_i$，此处判断是否有重复字串的时间复杂度是$O(n)$；</p>
</li>
<li>
<p>找出所有记录的子串长度的最大值$max_i{l_i}$。
一段伪代码如下，</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="n">maxlen</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">S</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">left</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">S</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">right</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if</span><span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="n">contain</span> <span class="err">重复字符</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
     <span class="k">if</span><span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">maxlen</span><span class="p">)</span> <span class="p">{</span>
         <span class="n">maxlen</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span><span class="n">left</span><span class="p">;</span>
     <span class="p">}</span>
    <span class="p">}</span>
<span class="k">return</span> <span class="n">maxlen</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>很明显，该方法的时间复杂度是$O(n^3)$，非常费时。这个算法的复杂度主要来自于第一步，仔细想想那个子串伪代码中的第3行有点问题，伪代码可以看作我们用一个窗口截取所有子串，left表示窗口的左边界（包含），right表示窗口的右边界（不包含），如果窗口中含有重复子串，那么不应该继续扩展右边界的，所以right不能一直向右<strong>扩展</strong>，此时应该向右移动左边界，<strong>缩小</strong>窗口的长度。以示例中给出的字符串为例，参考下面的示意图</p>
<p></p>
<p>所以我们有一个更通用的实现框架。</p>
<h2 id="通用框架">通用框架</h2>
<p>维护一个<strong>滑动窗口</strong>，</p>
<blockquote>
<ol>
<li>窗口的边界是$[left, right)$，刚开始窗口的长度为0，即left = right = 0；</li>
<li>维护一个哈希表table，用于记录窗口中的字符的统计情况，比如上面的图一中就<code>table['a'] = 2, table['b'] = 1, table['c'] = 1</code>；</li>
<li>窗口可<strong>扩展</strong>可<strong>收缩</strong>，</li>
</ol>
<ul>
<li>如果当前窗口中没有重复字符，则窗口扩展，<code>right++</code>，更新哈希表；</li>
<li>如果当前窗口中有重复字符，那么窗口收缩，<code>left++</code>，更新哈希表；</li>
</ul>
<ol start="4">
<li>直到<code>right</code>超过需要遍历的字符串的边界为止。</li>
</ol>
</blockquote>
<p>需要注意，上面的扩展和收缩的时机，对于当前的这个程序，如何判断当前的窗口中是否有重复字符呢？一般的想法是遍历每个键的值，如果有大于1的值就认为有重复字符，而且是在窗口位置发生变化的时候触发遍历动作。其实，这里有一个小技巧，<strong>键值只有在向右扩展的时候才会增长</strong>，刚开始窗口是没有键的，或者即便有也只能是1，所以在窗口扩展的时候，只要去查看新加入的<code>right</code>位置的字符的键值是否超过1即可。通过以上分析，我们有了下面的新的伪代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C++" data-lang="C++"><span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">maxlen</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="k">while</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// 增大窗口
</span><span class="c1"></span>    <span class="n">window</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">]);</span>
    <span class="n">right</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">window</span> <span class="n">doesnot</span> <span class="n">contain</span> <span class="n">repeat</span> <span class="n">charactor</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">maxlen</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxlen</span><span class="p">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">window</span> <span class="n">needs</span> <span class="n">shrink</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 缩小窗口
</span><span class="c1"></span>        <span class="n">window</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]);</span>
        <span class="n">left</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">return</span> <span class="n">maxlen</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>将上面的伪代码翻译成最后的c++代码，列示如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">lengthOfLongestSubstring</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">maxlen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">window</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">rch</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
        <span class="n">right</span><span class="o">++</span><span class="p">;</span>
        <span class="n">window</span><span class="p">[</span><span class="n">rch</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="n">rch</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">maxlen</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxlen</span><span class="p">,</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="n">rch</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">auto</span> <span class="n">lch</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
                <span class="n">left</span><span class="o">++</span><span class="p">;</span>
                <span class="n">window</span><span class="p">[</span><span class="n">lch</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">maxlen</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="类似题目">类似题目</h2>
<p>下面使用上面的框架解答一下其他的滑动窗口的类似题目</p>
<h3 id="最小覆盖子串---力扣leetcode">最小覆盖子串 - 力扣（LeetCode）</h3>
<p>题目见<a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener noreffer">76. 最小覆盖子串 - 力扣（LeetCode）</a>：给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</p>
<p>示例：</p>
<blockquote>
<p><strong>输入:</strong> S = &ldquo;ADOBECODEBANC&rdquo;, T = &ldquo;ABC&rdquo;
<strong>输出:</strong> &ldquo;BANC&rdquo;</p>
</blockquote>
<p>也是同样的做法，但是需要搞清楚几个问题</p>
<h4 id="何时扩展窗口">何时扩展窗口？</h4>
<p>如果窗口中没有将所有的T中的字符包含，那么向右扩展窗口。</p>
<h4 id="何时更新长度">何时更新长度？</h4>
<p>扩展窗口之后，检查窗口的字符集合。如果当前窗口包含了所有的T中的字符，那么更新子串的起始位置id及长度。</p>
<h4 id="何时缩减窗口">何时缩减窗口？</h4>
<p>更新长度之后，窗口的左端右移，缩减窗口。于是有了下面的代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// No. 76
</span><span class="c1"></span><span class="n">string</span> <span class="nf">minWindow</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">string</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">startId</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">rightId</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">minLen</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span>  <span class="n">matchCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// record the only need characters
</span><span class="c1"></span>    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">window</span><span class="p">;</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">need</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">ch</span> <span class="p">:</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">need</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">rch</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
        <span class="n">right</span><span class="o">++</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">need</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">rch</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// expand window
</span><span class="c1"></span>            <span class="n">window</span><span class="p">[</span><span class="n">rch</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="n">rch</span><span class="p">]</span> <span class="o">==</span> <span class="n">need</span><span class="p">[</span><span class="n">rch</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">matchCount</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>       

        <span class="c1">// shrink the window
</span><span class="c1"></span>        <span class="k">while</span> <span class="p">(</span><span class="n">matchCount</span> <span class="o">==</span> <span class="n">need</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">minLen</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">startId</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
                <span class="n">rightId</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
                <span class="n">minLen</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">auto</span> <span class="n">lch</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">need</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">lch</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">window</span><span class="p">[</span><span class="n">lch</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="n">lch</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">need</span><span class="p">[</span><span class="n">lch</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">matchCount</span><span class="o">--</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>            
            <span class="n">left</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">rightId</span> <span class="o">-</span> <span class="n">startId</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">startId</span><span class="p">,</span> <span class="n">rightId</span> <span class="o">-</span> <span class="n">startId</span><span class="p">)</span> <span class="o">:</span> <span class="s">&#34;&#34;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的写法中，需要注意几个问题</p>
<ol>
<li><code>window</code>仅仅记录了<code>[left, right)</code>的子串中的出现在need窗口中的字符的情况，并没有对窗口中所有的字符都做统计，其实也没有必要做，因为我们并不关心其他的字符；</li>
<li><code>minLen</code>用来记录最短的子串长度，刚开始初始化为字符串的长度+1；</li>
<li>我们用<code>matchCount</code>标记匹配的字符的个数，如果匹配了一个字符就加一，否则减一，匹配的标准是该字符的出现次数在window中<strong>不少于</strong>在need中出现的次数。注意，这个<strong>参数在扩展窗口时增加，在缩减窗口时减少</strong>，增加或减少之后即刻与need比较判断。</li>
</ol>
<h3 id="424-替换后的最长重复字符">424. 替换后的最长重复字符</h3>
<p>题目见<a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/" target="_blank" rel="noopener noreffer">424. 替换后的最长重复字符 - 力扣（LeetCode）</a>，题目也比较简单，维护滑动窗口，每次在扩展窗口时候检查当前的窗口中的最多的字符的个数与替换的数量k的和是否大于等于窗口的长度？</p>
<ol>
<li>如果是，则更新窗口的长度，窗口继续扩展；</li>
<li>如果否，则缩减窗口的长度；</li>
</ol>
<p>循环往复，直到窗口的右边界超过了字符串的长度。代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">characterReplacement</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">window</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">rch</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
            <span class="n">window</span><span class="p">[</span><span class="n">rch</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
            <span class="n">right</span><span class="o">++</span><span class="p">;</span>

            <span class="c1">// find max count char
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">maxCount</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">window</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">window</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">iter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">maxCount</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">maxCount</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">maxCount</span> <span class="o">+</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">maxLen</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">,</span> <span class="n">maxLen</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">lch</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
                <span class="n">window</span><span class="p">[</span><span class="n">lch</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
                <span class="n">left</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">maxLen</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="1004-最大连续1的个数-iii">1004. 最大连续1的个数 III</h3>
<p>题目见<a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/" target="_blank" rel="noopener noreffer">1004. 最大连续1的个数 III - 力扣（LeetCode）</a>，与上一题目类似，直接看代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">longestOnes</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">maxLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">window</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">rnum</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
            <span class="n">window</span><span class="p">[</span><span class="n">rnum</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
            <span class="n">right</span><span class="o">++</span><span class="p">;</span>
                        
            <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">K</span> <span class="o">&gt;=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">maxLen</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">,</span> <span class="n">maxLen</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">lnum</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
                <span class="n">window</span><span class="p">[</span><span class="n">lnum</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
                <span class="n">left</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">maxLen</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看出这个代码与上一题目非常相似，通用框架都是默认扩展窗口，如果不满足某些条件再缩减窗口。</p>
<h3 id="992-k个不同整数的数组">992. K个不同整数的数组</h3>
<p>题目见<a href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/" target="_blank" rel="noopener noreffer">992. K 个不同整数的子数组 - 力扣（LeetCode）</a>，这个比上面的两道题要复杂点，两次使用双指针解决，基本思路是：</p>
<ol>
<li>维护像之前一样的滑动窗口，如果当前的窗口不满足条件，那么向右扩张；</li>
<li>如果窗口满足条件了，停止向右扩张，右边界不变，左边界向右移动（收缩窗口），开始计算满足条件的窗口数目。注意，这里的动作，在满足条件的窗口上再开一个滑动窗口，但是该窗口的右边界不变，不停右移左边界，遍历满足条件的总数；</li>
<li>如此这般往复循环，直到滑动窗口的右边缘到达字符串的右边界为止。</li>
</ol>
<p>我第一次提交的代码如下，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">subarraysWithKDistinct</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">window</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">rnum</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
            <span class="n">window</span><span class="p">[</span><span class="n">rnum</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
            <span class="n">right</span><span class="o">++</span><span class="p">;</span>
            
			<span class="c1">// 如果当前的窗口中超过了K个不同的整数，那么需要缩小左边缘（即窗口左移）
</span><span class="c1"></span>            <span class="k">while</span> <span class="p">(</span><span class="n">window</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">lnum</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
                <span class="n">window</span><span class="p">[</span><span class="n">lnum</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="n">lnum</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">window</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">lnum</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="n">left</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span> 
            
            <span class="c1">// 当前的窗口有K个不同的整数，移动左边缘，遍历所有满足条件的窗口
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>                
                <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">subWindow</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
                <span class="kt">int</span> <span class="n">tmpLeft</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>

                <span class="k">while</span> <span class="p">(</span><span class="n">subWindow</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">count</span><span class="o">++</span><span class="p">;</span>
                    <span class="n">subWindow</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">tmpLeft</span><span class="p">]]</span><span class="o">--</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">subWindow</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">tmpLeft</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">subWindow</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">tmpLeft</span><span class="p">]);</span>
                    <span class="p">}</span>
                    <span class="n">tmpLeft</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>计算结果正确，但是超时了，仔细想想，其实不需要在创建一个subWindow窗口，可以复用原来的窗口，但是遍历完毕需要记得恢复，适当修改代码如下，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">int</span> <span class="nf">subarraysWithKDistinct</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">A</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">window</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">rnum</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">right</span><span class="p">];</span>
            <span class="n">window</span><span class="p">[</span><span class="n">rnum</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
            <span class="n">right</span><span class="o">++</span><span class="p">;</span>

            <span class="k">while</span> <span class="p">(</span><span class="n">window</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">auto</span> <span class="n">lnum</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">left</span><span class="p">];</span>
                <span class="n">window</span><span class="p">[</span><span class="n">lnum</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="n">lnum</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">window</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">lnum</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="n">left</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span> 
            
             
            <span class="kt">int</span> <span class="n">tmpLeft</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">window</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">K</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">count</span><span class="o">++</span><span class="p">;</span>
                <span class="n">window</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">tmpLeft</span><span class="p">]]</span><span class="o">--</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">tmpLeft</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">window</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">tmpLeft</span><span class="p">]);</span>
                <span class="p">}</span>
                <span class="n">tmpLeft</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// recover the window
</span><span class="c1"></span>            <span class="k">while</span> <span class="p">(</span><span class="n">tmpLeft</span> <span class="o">&gt;</span> <span class="n">left</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">window</span><span class="p">[</span><span class="n">A</span><span class="p">[</span><span class="n">tmpLeft</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>
                <span class="n">tmpLeft</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="数据结构">数据结构</h2>
<h3 id="哈希表">哈希表</h3>
<p>上面的示例都用到了哈希表，又称为散列表，具体的定义可以参考<a href="https://www.wikiwand.com/zh/%E5%93%88%E5%B8%8C%E8%A1%A8" target="_blank" rel="noopener noreffer">哈希表</a>。与一般的顺序访问的数组等数据结构不同，哈希表将查询的数据映射到表中的位置来记录，加快了查询的速度（类似于数组的下表和数组的值的映射关系）。一般而言，哈希表的查询，插入和删除的性能是$O(1)$。</p>
<h3 id="c-stl-中的哈希表">C++ STL 中的哈希表</h3>
<p>C++在stl中使用<code>unordered_map</code>的数据结构保存哈希表，基本的用法如下所示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// C++ program to demonstrate functionality of unordered_map 
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt; </span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt;  // </span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span> 

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span> 
	<span class="c1">// Declaring umap to be of &lt;string, int&gt; type 
</span><span class="c1"></span>	<span class="c1">// key will be of string type and mapped value will 
</span><span class="c1"></span>	<span class="c1">// be of double type 
</span><span class="c1"></span>	<span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">umap</span><span class="p">;</span> 

	<span class="c1">// inserting values by using [] operator 
</span><span class="c1"></span>	<span class="n">umap</span><span class="p">[</span><span class="s">&#34;GeeksforGeeks&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> 
	<span class="n">umap</span><span class="p">[</span><span class="s">&#34;Practice&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> 
	<span class="n">umap</span><span class="p">[</span><span class="s">&#34;Contribute&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span> 

	<span class="c1">// Traversing an unordered map 
</span><span class="c1"></span>	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">umap</span><span class="p">)</span> 
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> 

<span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><p>创建一个哈希表格，在哈希表中添加“键-值”对。</p>
<ul>
<li>
<p><code>unordered_map</code>和<code>unordered_set</code>有什么区别？</p>
<p><code>unordered_set</code>中只保存了键，主要用于查看某元素是否在集合中，不能保存每个键出现的次数。</p>
</li>
<li>
<p><code>unordered_map</code>和<code>map</code>有什么区别？</p>
<ol>
<li>
<p><code>map</code>中的键值是按序保存的，但是<code>unorederd_map</code>的键值是无序保存的；</p>
</li>
<li>
<p>二者底层实现的数据结构不同，<code>map</code>使用的是<a href="https://zh.wikipedia.org/zh-my/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="noopener noreffer">红黑树</a>，操作性能分别是$O(logn)$和$O(1)$</p>
</li>
</ol>
</li>
</ul>
<p>常见的操作如下面的代码所示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// C++ program to demonstrate functionality of unordered_map 
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt; </span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unordered_map&gt; </span><span class="cp">
</span><span class="cp"></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span> 

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Declaring umap to be of &lt;string, double&gt; type 
</span><span class="c1"></span>    <span class="c1">// key will be of string type and mapped value will 
</span><span class="c1"></span>    <span class="c1">// be of double type 
</span><span class="c1"></span>    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">umap</span><span class="p">;</span>

    <span class="c1">// 新增键值对
</span><span class="c1"></span>    <span class="n">umap</span><span class="p">[</span><span class="s">&#34;PI&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
    <span class="n">umap</span><span class="p">[</span><span class="s">&#34;root2&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.414</span><span class="p">;</span>
    <span class="n">umap</span><span class="p">[</span><span class="s">&#34;root3&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.732</span><span class="p">;</span>
    <span class="n">umap</span><span class="p">[</span><span class="s">&#34;log10&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.302</span><span class="p">;</span>
    <span class="n">umap</span><span class="p">[</span><span class="s">&#34;loge&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>

    <span class="c1">// 插入键值对，可以使用c++的make_pair函数
</span><span class="c1"></span>    <span class="n">umap</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="s">&#34;e&#34;</span><span class="p">,</span> <span class="mf">2.718</span><span class="p">));</span>

    <span class="n">string</span> <span class="n">key</span> <span class="o">=</span> <span class="s">&#34;PI&#34;</span><span class="p">;</span>

    <span class="c1">// 查询方法一
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">umap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">umap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">key</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; not found</span><span class="se">\n\n</span><span class="s">&#34;</span><span class="p">;</span>

    <span class="c1">// If key found then iterator to that key is returned 
</span><span class="c1"></span>    <span class="k">else</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Found &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">key</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n\n</span><span class="s">&#34;</span><span class="p">;</span>

    <span class="c1">// 查询方法二 
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">umap</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">key</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; not found</span><span class="se">\n\n</span><span class="s">&#34;</span><span class="p">;</span>

    <span class="c1">// If key found then iterator to that key is returned 
</span><span class="c1"></span>    <span class="k">else</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Found &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">key</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n\n</span><span class="s">&#34;</span><span class="p">;</span>

    <span class="c1">// 遍历方法一
</span><span class="c1"></span>    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">itr</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">All Elements : </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">itr</span> <span class="o">=</span> <span class="n">umap</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">itr</span> <span class="o">!=</span> <span class="n">umap</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">itr</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// itr works as a pointer to pair&lt;string, double&gt; 
</span><span class="c1"></span>        <span class="c1">// type itr-&gt;first stores the key part and 
</span><span class="c1"></span>        <span class="c1">// itr-&gt;second stroes the value part 
</span><span class="c1"></span>        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">itr</span><span class="o">-&gt;</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">itr</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 遍历方法二
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">iter</span> <span class="p">:</span> <span class="n">umap</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">iter</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">iter</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>需要格外注意，除了上面的<code>find</code>方法之外，查询某个键是否在哈希表中，还可以通过如下代码查询某个键值<code>key</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">if</span> <span class="p">(</span><span class="n">umap</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">key</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; is found</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Not found</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果哈希表中没有这个键值，<strong>那么它会自动添加进去，并赋给它初值</strong>，所以在查询某个键是否存在时，不要用这样的方法。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hua-dong-chuang-kou-ji-qiao-jin-jie" target="_blank" rel="noopener noreffer">我写了首诗，把滑动窗口算法算法变成了默写题 - labuladong的算法小抄</a>，非常通俗易懂的算法说明，基本上按照这个顺序来刷题的</li>
<li><a href="https://www.geeksforgeeks.org/unordered_map-in-cpp-stl/" target="_blank" rel="noopener noreffer">unordered_map in C++ STL - GeeksforGeeks</a>，C++ stl中的unordered_map</li>
<li><a href="https://www.geeksforgeeks.org/hashing-set-1-introduction/" target="_blank" rel="noopener noreffer">Hashing | Set 1 (Introduction) - GeeksforGeeks</a>，哈希表的介绍</li>
</ul>]]></description>
</item><item>
    <title>使用linux vs code调试C&#43;&#43;程序</title>
    <link>https://bugxch.github.io/manjarovscode/</link>
    <pubDate>Sun, 26 Jul 2020 08:12:22 &#43;0800</pubDate>
    <author>作者</author>
    <guid>https://bugxch.github.io/manjarovscode/</guid>
    <description><![CDATA[<p>最近练习leetcode编程，我希望在manjaro系统的vs code上可以单步调试C++代码，找了很多资料都不能正常运行，所以参考<a href="https://code.visualstudio.com/docs/cpp/cpp-debug" target="_blank" rel="noopener noreffer">官方资料</a>自己整好了，记录一下。</p>
<h2 id="预置条件">预置条件</h2>
<p>首先完成如下工作</p>
<ol>
<li>
<p>安装vs code;</p>
</li>
<li>
<p>安装插件，如下图所示</p>
<p></p>
</li>
<li>
<p>确认linux系统已经正确安装gcc，输入如下命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">gcc -v <span class="c1"># 查看gcc版本</span>
sudo pacman -S build-essential gdb <span class="c1"># 安装必要工具軟件</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<h2 id="创建hello-world工程">创建Hello world工程</h2>
<p>在本地创建目录，我在本地创建了leetcode的目录，所以有如下的步骤</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">mkdir project
<span class="nb">cd</span> project
mkdir 
<span class="nb">cd</span> helloworld
code . <span class="c1"># 在当前目录下打开vs code，当前打开的文件夹就是这个“工作空间”</span>
</code></pre></td></tr></table>
</div>
</div><p>阅读完本博客之后，你会在当前的目录下面创建下面的3个文件</p>
<ul>
<li><code>tasks.json</code> (compiler build settings)</li>
<li><code>launch.json</code> (debugger settings)</li>
</ul>
<h3 id="添加源文件">添加源文件</h3>
<p>如图所示，添加新的源文件<code>helloworld.cpp</code></p>
<p></p>
<p>在该文件中粘贴如下的源代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">msg</span> <span class="p">{</span><span class="s">&#34;Hello&#34;</span><span class="p">,</span> <span class="s">&#34;C++&#34;</span><span class="p">,</span> <span class="s">&#34;World&#34;</span><span class="p">,</span> <span class="s">&#34;from&#34;</span><span class="p">,</span> <span class="s">&#34;VS Code&#34;</span><span class="p">,</span> <span class="s">&#34;and the C++ extension!&#34;</span><span class="p">};</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="nl">word</span> <span class="p">:</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">word</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>然后保存该文件。</p>
<p></p>
<h3 id="构建helloworldcpp">构建helloworld.cpp</h3>
<p>接下来，你将创建一个<code>task.json</code>文件告诉VS code如何构建(编译)当前的程序。这将触发g++编译器按照源代码创建一个可执行程序。在主菜单选择<strong>终端-&gt;配置默认生成任务</strong>，然后在下拉菜单选择g++ build active file，如下图所示</p>
<p></p>
<p>你将在<code>.vscode</code>文件夹下面看到<code>tasks.json</code>文件，我们进一步编辑这个文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
	<span class="nt">&#34;version&#34;</span><span class="p">:</span> <span class="s2">&#34;2.0.0&#34;</span><span class="p">,</span>
	<span class="nt">&#34;tasks&#34;</span><span class="p">:</span> <span class="p">[</span>
		<span class="p">{</span>
			<span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;shell&#34;</span><span class="p">,</span>
			<span class="nt">&#34;label&#34;</span><span class="p">:</span> <span class="s2">&#34;C/C++: g++ build active file&#34;</span><span class="p">,</span>
			<span class="nt">&#34;command&#34;</span><span class="p">:</span> <span class="s2">&#34;/usr/bin/g++&#34;</span><span class="p">,</span>
			<span class="nt">&#34;args&#34;</span><span class="p">:</span> <span class="p">[</span>
				<span class="s2">&#34;-g&#34;</span><span class="p">,</span>
				<span class="s2">&#34;${file}&#34;</span><span class="p">,</span>
				<span class="s2">&#34;-o&#34;</span><span class="p">,</span>
				<span class="s2">&#34;${fileDirname}/${fileBasenameNoExtension}&#34;</span>
			<span class="p">],</span>
			<span class="nt">&#34;options&#34;</span><span class="p">:</span> <span class="p">{</span>
				<span class="nt">&#34;cwd&#34;</span><span class="p">:</span> <span class="s2">&#34;${workspaceFolder}&#34;</span>
			<span class="p">},</span>
			<span class="nt">&#34;problemMatcher&#34;</span><span class="p">:</span> <span class="p">[</span>
				<span class="s2">&#34;$gcc&#34;</span>
			<span class="p">],</span>
			<span class="nt">&#34;group&#34;</span><span class="p">:</span> <span class="p">{</span>
				<span class="nt">&#34;kind&#34;</span><span class="p">:</span> <span class="s2">&#34;build&#34;</span><span class="p">,</span>
				<span class="nt">&#34;isDefault&#34;</span><span class="p">:</span> <span class="kc">true</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>关于json文件中变量的具体含义可以进一步参考<a href="https://code.visualstudio.com/docs/editor/variables-reference" target="_blank" rel="noopener noreffer">Visual Studio Code Variables Reference</a></p>
</blockquote>
<p>文件中的指令指定了程序如何运行，当前文件中的<code>args</code>参数指定了传输给gcc的参数，这些参数必须按照编译器期望的顺序排列。</p>
<p>这个任务告诉g++将源文件<code>${file}</code>编译，在当前文件夹下面创建可执行文件<code>helloword</code>，注意可执行文件的名称和源文件相同，但是去掉了扩展后缀名。<code>label</code>字段表示你能看到的任务列表，你可以写成任何你想写的东西。<code>group</code>中的<code>&quot;isDefault&quot;: true</code>表示你可以使用<code>Ctrl+Shift+B</code>运行该任务，这个仅仅是为了使用上的方便，你依然可以通过菜单中的选项运行该任务。</p>
<h3 id="运行编译程序">运行编译程序</h3>
<p>回到原来的<code>helloworld.cpp</code>程序，按下<code>Ctrl+Shift+B</code>运行该任务，请留意编辑器下方的终端的打印，在任务运行结束之后一般会提示成功或者失败，如果运行顺利，你可以看到如下的提示</p>
<p></p>
<p>如果留意可以看到当前的文件夹中已经生成了可执行程序<code>helloworld</code>文件，打开新的终端，即可运行该程序</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">./helloworld <span class="c1"># 运行可执行程序</span>
</code></pre></td></tr></table>
</div>
</div><p></p>
<h3 id="修改tasksjson">修改tasks.json</h3>
<p>你可以修改这个文件中的参数，比如将<code>${workspaceFolder}/*.cpp</code>替换<code>${file}</code>，或者也可以将<code>${fileDirname}/${fileBasenameNoExtension}</code>替换成一个硬编码的程序名称<code>helloworld.out</code>。</p>
<h3 id="调试源程序">调试源程序</h3>
<p>接下来你将创建<code>launch.json</code>文件，当按下<code>F5</code>的时候VS Code调用GDB的调试器用于调试程序。找到菜单中的<strong>运行 &gt; 添加配置</strong>，然后选择<strong>C++ (GDB/LLDB)</strong>，如下图所示</p>
<p></p>
<p>我们选择<strong>g++ build and debug active file</strong>，你可以看到此处VS Code自动创建了文件<code>launch.json</code>文件，文件的内容如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
    <span class="err">//</span> <span class="err">使用</span> <span class="err">IntelliSense</span> <span class="err">了解相关属性。</span> 
    <span class="err">//</span> <span class="err">悬停以查看现有属性的描述。</span>
    <span class="err">//</span> <span class="err">欲了解更多信息，请访问:</span> <span class="err">https://go.microsoft.com/fwlink/?linkid=830387</span>
    <span class="nt">&#34;version&#34;</span><span class="p">:</span> <span class="s2">&#34;0.2.0&#34;</span><span class="p">,</span>
    <span class="nt">&#34;configurations&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;g++ - 生成和调试活动文件&#34;</span><span class="p">,</span>
            <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;cppdbg&#34;</span><span class="p">,</span>
            <span class="nt">&#34;request&#34;</span><span class="p">:</span> <span class="s2">&#34;launch&#34;</span><span class="p">,</span>
            <span class="nt">&#34;program&#34;</span><span class="p">:</span> <span class="s2">&#34;${fileDirname}/${fileBasenameNoExtension}&#34;</span><span class="p">,</span>
            <span class="nt">&#34;args&#34;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="nt">&#34;stopAtEntry&#34;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
            <span class="nt">&#34;cwd&#34;</span><span class="p">:</span> <span class="s2">&#34;${workspaceFolder}&#34;</span><span class="p">,</span>
            <span class="nt">&#34;environment&#34;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="nt">&#34;externalConsole&#34;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
            <span class="nt">&#34;MIMode&#34;</span><span class="p">:</span> <span class="s2">&#34;gdb&#34;</span><span class="p">,</span>
            <span class="nt">&#34;setupCommands&#34;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;为 gdb 启用整齐打印&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;text&#34;</span><span class="p">:</span> <span class="s2">&#34;-enable-pretty-printing&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;ignoreFailures&#34;</span><span class="p">:</span> <span class="kc">true</span>
                <span class="p">}</span>
            <span class="p">],</span>
            <span class="nt">&#34;preLaunchTask&#34;</span><span class="p">:</span> <span class="s2">&#34;C/C++: g++ build active file&#34;</span><span class="p">,</span>
            <span class="nt">&#34;miDebuggerPath&#34;</span><span class="p">:</span> <span class="s2">&#34;/usr/bin/gdb&#34;</span>
        <span class="p">}</span>
    <span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>很明显在这个文件中<code>program</code>指定了需要debug的程序，和之前的文件一样，此处就是没有后缀名的与源文件一样的程序，这个例子中就是<code>helloworld</code>。默认情况下，C++插件不会在代码中插入任何断点，所以<code>stopAtEntry</code>是<code>false</code>。如果将该项改为<code>true</code>，那么就可以让调试器停在主函数的断点处。</p>
<h3 id="开始调试">开始调试</h3>
<p>回到源文件，按下<code>F5</code>就可以开始调试了，在代码编辑器的上访可以看到调试的控制条，包括了单步调试，跳过调试，重启调试和停止调试的功能。稍微探索一下就可以发现，<code>F9</code>是添加断点，其他的调试方法鼠标悬停在上面都会显示快捷键，你看到的编辑器应该是这样的</p>
<p></p>
<p>调试中可以看到每个变量的值，以及监视窗口。</p>
<blockquote>
<p>需要注意的是，当前的版本（2019年3月份之后）不会在单步调试模式下将cout的结果打印出来，只有程序运行完成之后才会统一打印出来。</p>
</blockquote>]]></description>
</item><item>
    <title>01背包问题详解</title>
    <link>https://bugxch.github.io/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/</link>
    <pubDate>Sat, 22 Feb 2020 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://bugxch.github.io/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/</guid>
    <description><![CDATA[<p>背包问题是非常经典的动态规划问题，但是中文书籍和资料很少有把这个问题说得清晰明了的，问题表述不清，递推公式错误，不一而足，我在彻底想清楚这个问题后，觉得很有必要记录下整个思考过程。</p>
<h2 id="原始问题">原始问题</h2>
<p>当前有$n$件物品，第$i$件物品的重量为$w_i$，价值为$p_i$，当前有一个容量为$C$的背包。此处物品的重量，价值以及背包的容量都是非负整数。从这些物品中精心挑选若干件装入包中，这若干件被挑选的物品<strong>总重量不超过背包容量$C$，总价值尽量大</strong>，那么所有可能的挑选方法得到的</p>
<ol>
<li>最大值为多少？</li>
<li>放进去哪些物件得到这个最大值？</li>
</ol>
<p>问题的表述比较抽象，如果上面的问题有统一的算法，那么即便问题的规模缩小，问题解决的逻辑也不会有变化，所以从规模比较小的情形入手，更容易分析出来。假设背包容量是4kg，我们有3件物品，每件物品的价格以及重量见下表</p>
<table>
<thead>
<tr>
<th>物品</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>重量/kg</td>
<td>1</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>价格/$</td>
<td>8</td>
<td>9</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>我相信大多数人看到这个问题，会使用如下的<strong>贪婪算法</strong>。</p>
<h2 id="贪婪算法">贪婪算法</h2>
<ol>
<li>
<p>第1个想法是将物品按照价格从高到低进行排序，如果背包的空余容量可以容纳该物品，则将它放入背包。按照这个方法处理对于上面的例子，结果应该是仅仅放入第3件物品，价值是10，但是明显是错的，因为放入物品1和2的价值更大（17），所以<strong>这个方法行不通</strong>。</p>
</li>
<li>
<p>与上面的方法类似，可以按照重量从轻到重装入背包，但是对于下面的情形一样行不通</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>序号</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>重量/kg</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>价格/$</td>
<td>8</td>
<td>9</td>
<td>18</td>
</tr>
</tbody>
</table>
<p>放入背包的重量是物品1和2，总重是3，价值是17，正确答案是放入1和3，总价值是26，所以这种方法<strong>明显是错误的</strong>。</p>
<ol start="3">
<li>另一种改进的方法，定义物品的价值密度为</li>
</ol>
<p>$$
\rho_i = p_i/w_i
$$
按照价值密度由高到低排序，依次核验后放入背包，但是按照该算法处理下面的情形依然是失败的</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>重量/kg</td>
<td>1</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>价格/$</td>
<td>8</td>
<td>9</td>
<td>18</td>
</tr>
<tr>
<td>$\rho_i$</td>
<td>8</td>
<td>4.5</td>
<td>9</td>
</tr>
</tbody>
</table>
<p>该方法的结果是放入1和3，但是明显2和3号的价值更大。</p>
<p>所以，无论是按照重量，大小，还是密度排序，这样的方法都是错误的。其实考虑最周全的方法，求$n$件物品的是否放入背包的全部组合，记录所有总重量可以放入背包的组合的价值，然后选一个最大值即可，但是对于$n$件物品，需要考虑的组合有$2^n$组，算法的复杂度很高，当$n$比较大的时候就很不实际。</p>
<p>上面的三种方法使用贪婪算法，下面是《算法的乐趣》中对贪婪算法的描述，</p>
<blockquote>
<p>贪婪算法是寻找最优解的常用方法，该方法将求解的过程分成若干步骤，在每个步骤都应用贪心原则，选取当前状态下最好的或者最优的选择（局部最有利的选择），并以此希望最后堆叠出的结果是最好的或者最优的解。</p>
</blockquote>
<p>之前的算法将物品的选择分解为依次挑选物品，这里的次序可以是价值从高到低，重量从低到高或者密度从大到小，并且希冀于每一步结束之后，整体上的价值是最高的，重量是最轻的或者密度是最大的。这个就是明显的贪婪算法思想，但是<strong>局部最优不等于全部最优</strong>，因此这样的算法是失败的。</p>
<h2 id="动态规划">动态规划</h2>
<h3 id="重新定义问题">重新定义问题</h3>
<p>重新思考这个问题，换一个角度将其理解为<strong>有限空间利用价值最大化</strong>的问题，我们更清晰的描述一下这个问题，有助于我们进一步思考。<strong>从$n$个物品中挑选出其中的$m(m \le n)$个，用于填充大小为$C$的空间，</strong></p>
<blockquote>
<ol>
<li>使得$m$个物件的的总重量不超过$C$，即$ \sum_{k=1}^{m}{w_k} \le C$</li>
<li>在满足条件1的情况下，$m$个物件的总价值在所有可能的挑选组合中<strong>最大</strong>。</li>
</ol>
</blockquote>
<p>我们用$V[i, C]$表示这$m$个物件的总价值，即
$$
V[i,C] = \max_{s.t.}{\sum_{k=1}^{m}{p_k}}，m \le n
$$
重申一下$V[i,C]$的含义，它表示**使用$i$个物件充分填充空间$C$得到的最大价值，**所以，这个问题就需要找到两样答案，</p>
<ol>
<li>$V[i,C]$的值；</li>
<li>得到$V[i,C]$的值对应的$m$个物件的集合$M_i$</li>
</ol>
<p><strong>很多文章根本就没有把$V[i,C]$的含义说清楚！</strong></p>
<p><strong>很多文章根本就没有把$V[i,C]$的含义说清楚！</strong></p>
<p><strong>很多文章根本就没有把$V[i,C]$的含义说清楚！</strong></p>
<p><strong>请注意，这个含义非常重要，在后面的推导和计算过程中会反复使用，请务必深刻理解！</strong></p>
<hr>
<h3 id="递推思路">递推思路</h3>
<p>注意前方高能，<strong>下面是这个算法的关键</strong>, 假定我们已经得到上面两个问题的答案，**如果此时再有第$i + 1$个物品加进来，该怎么处理？**此时，问题转换为求</p>
<blockquote>
<ol>
<li>使用$i + 1$个物件充分填充空间C得到的最大价值$V[i + 1,C]$</li>
<li>以及$V[i + 1,C]$对应的物件的组合$M_{i+1}$</li>
</ol>
</blockquote>
<p>当你手里拿着这个重量为$w_{i+1}$的物品，准备填充容量为$C$的**空包**时候（**注意此处的空包，不要想当然得以为包里面已经有前面的$i - 1$中挑选的物件**了），有下面两种情形，</p>
<ol>
<li>该物件的重量大于背包的容量，即$w_{i+1} \gt C$，那么这个物品无论如何也放不进背包，因此这个物品不会被选中，所以只能**使用前面$i$个物件填充$C$**，得出$V[i + 1,C] = V[i, C]，M_{i + 1} = M_{i}$。</li>
<li>该物件的重量小于等于背包容量，即$w_{i+1} \le C$，这个时候你有两种选择，</li>
</ol>
<ul>
<li>
<p>先将这个物件放入背包，此处背包的可用空间还有$C-w_{i+1}$，那么可以使用之前的$i$件物品去充分填充这个剩余空间。注意，此时背包空间由两部分的物件充分填充，</p>
<p></p>
<ol>
<li>
<p>物件$i+1$充分填充空间$w_{i+1}$，该空间的最大价值为$p_{i+1}$</p>
</li>
<li>
<p>之前的$i$个物件充分填充剩余的空间$C - w_{i+1}$，该空间的最大价值为$V[i-1, C-w_{i+1}]$
所以，当前的情形下**使用$i+1$个物件填充空间$C$**的最大价值是上述二者的和，即$V[i+1, C] = V[i, C-w_{i+1}] + p_{i+1}，M_{i+1} = M_i\bigcup  i+1$。</p>
</li>
</ol>
</li>
<li>
<p>不放入背包，那结果和之前的第一种情形一样，空间$C$由前面的$i$件物品充分填充，那么$V[i + 1,C] = V[i, C]，M_{i + 1} = M_{i}$。
因此，结合上面的分析，对于这种可以放入背包的情形，取二者的最大值，有$V[i+1, C]=\max {V[i, C-w_{i+1}] + p_{i+1}，V[i, C]}$。</p>
</li>
</ul>
<p>综合以上分析，我们得到了一个递推关系式，</p>
<p></p>
<p>**终于水落石出！**将递推关系式中的$i$换成$i-1$，于是得到如下的结果</p>
<p></p>
<hr>
<h3 id="初始条件及推导方法">初始条件及推导方法</h3>
<p>根据上面的推导式，就可以求出最后的结果，最后还有两点需要明确：</p>
<ol>
<li>
<p><strong>$V[i, C]$的最初的值是什么？</strong></p>
<p>回想一下这个值表示的含义，<strong>使用$i$个物件充分填充空间$C$得到的最大价值</strong>，仔细考虑这个含义可以得到</p>
<ul>
<li>$V[0,0] = 0$，使用0个物件填充大小为0的空间的最大价值肯定是0</li>
<li>$V[0,C] = 0$，使用0个物件填充大小为C的空间的最大价值肯定是0，背包空空如也，价值为0</li>
<li>$V[i,0] = 0$，使用$i$个物件填充大小为0的空间的最大价值肯定是0，背包空空如也，价值为0</li>
</ul>
</li>
<li>
<p><strong>如何根据最初的值，一步步推导出最终的结果$V[i, C]$？</strong></p>
<p>再观察上面的递推公式，$i$个物件总的最大价值依赖于前$i-1$个物件总的最大价值以及当前第$i$个物件本身的重量以及价值，换句话说，如果<strong>我知道了前$i-1$个物件总的最大价值以及当前第$i$个物件本身的重量以及价值，那么我也能推导出$i$个物件总的最大价值。</strong></p>
<p>更仔细的观察公式里面的max的公式，我们不仅需要知道$V[i-1, C]$，还需要知道$V[i-1, C-w_i]$，特别地，这里的$w_i$表示第$i$个物件的重量，它可以是任意的非负整数，因此我们需要知道$V[i-1,0]$到$V[i-1,C]$的所有值，于是下面的<strong>二维数组</strong>填充就呼之欲出。</p>
</li>
</ol>
<h3 id="二维数组">二维数组</h3>
<p>我们使用二维数组记录$V[i,C]$，二维数组的行数为物件的总数$i$，二维数组的列数是背包的容量$C+1$（<strong>注意此处多加了一列，因为从上面的推导看出我们需要知道$V[i-1,0]$的值，所以多加一列作为第0列</strong>），我们使用之前的问题，使用4Kg容量的背包挑选下面的物件</p>
<table>
<thead>
<tr>
<th>物品</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>重量/kg</td>
<td>1</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>价格/$</td>
<td>8</td>
<td>9</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>我们一步步看看这个表格怎么填充，</p>
<ol>
<li>
<p>建立空的二维数组，行数是3，列数是5，表格中的所有值都是未知数（<strong>注意此表从第0列开始，我们数第0列，第1列直到第4列</strong>），</p>
<p></p>
</li>
<li>
<p>根据之前的推论$V[i,0] = 0,i = 1,2,3$，所有行的<strong>第0列都是0</strong>，得到如下的表格</p>
<p></p>
</li>
<li>
<p>计算<strong>第1行</strong>的值$V[1,k],k=1,2,3,4$，再回想一下这个含义的意思，<strong>使用1个物件填充空间为$k$的最大价值</strong>，第一个物件的重量是1，价值为8，那么</p>
<ul>
<li>可以填充大小为1的空间，填充后的剩余空间为0，总价值为8，即$V[1,1]= 8$；</li>
<li>可以填充大小为2的空间，填充后的剩余空间为1，<strong>但是此时你手上没有别的物件了，所以填充到此为止</strong>，总价值为8，即$V[1,2]= 8$；</li>
<li>可以填充大小为3的空间，填充后的剩余空间为2，但是此时你手上没有别的物件了，所以填充到此为止，总价值为8，即$V[1,3]= 8$；</li>
<li>可以填充大小为4的空间，填充后的剩余空间为3，但是此时你手上没有别的物件了，所以填充到此为止，总价值为8，即$V[1,4]= 8$；</li>
</ul>
<p>于是，我们得到第一行的值如下表所示</p>
<p></p>
</li>
<li>
<p>有了<strong>第2行</strong>的值，就可以根据之前的递推公式机械式得计算，第2件物品的重量为$w_2=3$，价值为$p_2=9$，</p>
<ul>
<li>第2件物品的$w_2&gt;1$，所以<strong>根据递推公式</strong>计算$V[2,1]=V[1,1]=8$，这件物品不放入包中；</li>
<li>第2件物品的$w_2&gt;2$，所以<strong>根据递推公式</strong>计算$V[2,2]=V[1,2]=8$，这件物品不放入包中；</li>
<li>第2件物品的$w_2=3$，所以<strong>根据递推公式</strong>计算$V[2,3]=\max {V[1, 3-w_2] + p_{2}，V[1, 3]}=\max {V[1,0] + 9，V[1, 3]}=9$，这件物品放入包中；</li>
<li>第2件物品的$w_2&lt;4$，所以<strong>根据递推公式</strong>计算$V[2,4]=\max{V[1, 4-w_2] + p_{2}，V[1, 4]}=\max{V[1, 1] + 9，V[1, 4]}=17$，这件物品放入包中；</li>
</ul>
<p>于是得到第二行的结果如下</p>
<p></p>
</li>
<li>
<p>按照计算第2行值的方法，计算第3行的值，结果如下</p>
<p></p>
<p>所以最终的结果是用3个物件填充空间为4的背包，得到的最大价值为$V[3,4] = 17$。</p>
</li>
</ol>
<h3 id="放入哪些物件">放入哪些物件</h3>
<p>但是且慢，文章的开头还有一个问题，我们放进去哪些物件，得到这个最大值的呢？请注意之前的递推思路那一小节中的物件集合$M_i$的变化，**当且仅当$V[i, C] = V[i-1, C-w{i}] + p_{i}$时，第$i$件物品才会被放进来**。再仔细观察一下递推公式，我们可以看到$V[i,C]$的值要么等于$V[i-1, C-w{i}] + p_{i}$，要么等于$V[i-1,C]$，所以可以确认</p>
<blockquote>
<p>如果$V[i, C] = V[i-1, C]$，那么第$i$件物品没有被放入背包中</p>
</blockquote>
<p>但是仅仅有这个条件判断是不是已经足够了，如果第$i$个物品是被放入背包中的，下一步回溯还是考察$V[i-1,C]$是否与$V[i-2,C]$的值相等吗？回到之前的那幅图</p>
<p></p>
<p>总的问题与子问题有相同的结构，如果第$i+1$个物品已经验证放入背包中了，更小的问题是**使用$i$个物件填充大小为$C-w_{i+1}$空间**，那么我们应该考察$V[i,C-w_{i}]$是否与$V[i-1,C-w_{i}]$的值相等。所以回溯的算法如下：</p>
<ol>
<li>从二维数组的$V[i, C]$开始，检查$V[i, C]$的值是否与$V[i-1, C]$相同；</li>
<li>考察第1步的结果</li>
</ol>
<ul>
<li>
<p>如果相同，那么第$i$件物品没有被放入背包，令$i-1\rightarrow i$，即继续检查$V[i-1, C]$的值是否与$V[i-2, C]$相同；</p>
</li>
<li>
<p>如果不同，那么第$i$件物品被放入背包，令$i-1\rightarrow i, C-w_i\rightarrow C$，即继续检查$V[i-1, C-w_i]$的值是否与$V[i-2, C-w_i]$相同；</p>
</li>
</ul>
<ol start="3">
<li>不停使用步骤2的逻辑，直到考察到$i=0$为止。</li>
</ol>
<p>那么，就可以逐行倒着回溯二维数组，</p>
<ol>
<li>
<p>我们先看第3行，$V[3,4]=V[2,4]$，所以第3件物品没有放入背包；</p>
<p></p>
</li>
<li>
<p>第2行，$V[2,4]\ne V[1,4]$，所以<strong>第2件</strong>物品放入背包，接下来需要检查$V[1,4-w_2]$是否与$V[0,4-w_2]$相同；</p>
<p></p>
</li>
<li>
<p>第1行，$V[1,1]\ne V[0,1]$，所以<strong>第1件</strong>物品放入背包（注意此处$V[0,4] = 0$，二维表格没有第0行，但是我们初始条件中推导过这个值），检查结束。
</p>
</li>
</ol>
<h3 id="编程代码">编程代码</h3>
<p>下面是C++的程序代码，</p>
<p>定义一个背包的类，默认有10物件，每个物件大重量为6，最高价格为35。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// knapsack.h
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;ctime&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">tagObj</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">weight</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">price</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Obj</span><span class="p">;</span>

<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">max</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span> <span class="p">}</span>

<span class="k">class</span> <span class="nc">Knapsack</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Knapsack</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">maxWeight</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">maxPrice</span> <span class="o">=</span> <span class="mi">35</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">SolvePro</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">totalW</span><span class="p">);</span>
    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Knapsack</span><span class="o">&amp;</span> <span class="n">nap</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Obj</span><span class="o">&gt;</span> <span class="n">knapsack_</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">index_</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">totalPrice_</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>方法如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">// knapsack.cpp
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;knapsack.h&#34;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;ctime&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">Knapsack</span><span class="o">::</span><span class="n">Knapsack</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">maxWeight</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">minPrice</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">srand</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)));</span>
    <span class="n">Obj</span> <span class="n">obj</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
         <span class="c1">// 随机生成价值和重量
</span><span class="c1"></span>        <span class="n">obj</span><span class="p">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">maxWeight</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">obj</span><span class="p">.</span><span class="n">price</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">minPrice</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">knapsack_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">totalPrice_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Knapsack</span><span class="o">&amp;</span> <span class="n">nap</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Dispaly knapsack list</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">nap</span><span class="p">.</span><span class="n">knapsack_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; object as below</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nap</span><span class="p">.</span><span class="n">knapsack_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;: weight &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">nap</span><span class="p">.</span><span class="n">knapsack_</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">weight</span> <span class="o">&lt;&lt;</span> \
            <span class="s">&#34;, price &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">nap</span><span class="p">.</span><span class="n">knapsack_</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">price</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Knapsack</span><span class="o">::</span><span class="n">SolvePro</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">totalW</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">knapsack_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">totalW</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">matrix</span><span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">row</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">col</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">knapsack_</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">).</span><span class="n">weight</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> \
                    <span class="n">matrix</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="n">knapsack_</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">).</span><span class="n">weight</span><span class="p">]</span> <span class="o">+</span> \
                    <span class="n">knapsack_</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">).</span><span class="n">price</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">totalPrice_</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">];</span>

    <span class="kt">int</span> <span class="n">startRow</span> <span class="o">=</span> <span class="n">row</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">startCol</span> <span class="o">=</span> <span class="n">col</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">startRow</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">startRow</span><span class="p">][</span><span class="n">startCol</span><span class="p">]</span> <span class="o">==</span> <span class="n">matrix</span><span class="p">[</span><span class="n">startRow</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">startCol</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">startRow</span><span class="o">--</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">index_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">startRow</span><span class="p">);</span>
        <span class="n">startCol</span> <span class="o">-=</span> <span class="n">knapsack_</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">startRow</span> <span class="o">-</span> <span class="mi">1</span><span class="p">).</span><span class="n">weight</span><span class="p">;</span>
        <span class="n">startRow</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">reverse</span><span class="p">(</span><span class="n">index_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">index_</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">Weight capacity is &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">totalW</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, and totalPrice is &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">matrix</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">&lt;&lt;</span> \
        <span class="s">&#34;, selected obj index is: &#34;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">index_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">index_</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &#34;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>使用main函数，调用如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&#34;knapsack.h&#34;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Knapsack</span> <span class="n">nap1</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">// 我们有10个物品，最大重量为6，最大价值为10，价值和重量都是随机生成的
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">nap1</span><span class="p">;</span>
    <span class="n">nap1</span><span class="p">.</span><span class="n">SolvePro</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span> <span class="c1">// 背包容量30
</span><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>结果如下</p>
<p></p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.jianshu.com/p/a66d5ce49df5" target="_blank" rel="noopener noreffer">0-1背包问题 - 简书</a>，描述《算法图解》中对该问题的解法，比较有趣</li>
<li><a href="https://www.cnblogs.com/Christal-R/p/Dynamic_programming.html" target="_blank" rel="noopener noreffer">动态规划解决01背包问题 - Christal_R - 博客园</a>，中文博客写得不错的文章</li>
<li><a href="https://oi-wiki.org/dp/knapsack/" target="_blank" rel="noopener noreffer">背包 DP - OI Wiki</a>，在没有Google下搜索出来的总结比较全面的文章</li>
<li><a href="https://www.kancloud.cn/kancloud/pack" target="_blank" rel="noopener noreffer">背包问题九讲 · 看云</a>，非常系统的背包问题的解释</li>
</ul>]]></description>
</item><item>
    <title>《CPlusPlus Primer Plus》第九章习题及答案</title>
    <link>https://bugxch.github.io/cplusplus-primer-plus%E7%AC%AC%E4%B9%9D%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/</link>
    <pubDate>Mon, 27 Jan 2020 12:49:07 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://bugxch.github.io/cplusplus-primer-plus%E7%AC%AC%E4%B9%9D%E7%AB%A0%E4%B9%A0%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="https://raw.githubusercontent.com/bugxch/blogpics/master/202001/c%2B%2B.jpg" referrerpolicy="no-referrer">
            </div><p>假期做题，记录下。</p>
<p>此处是复习题的答案，编程练习题的答案见<a href="https://github.com/bugxch/Solutions_C-PrimerPlus" target="_blank" rel="noopener noreffer">bugxch/Solutions_C-PrimerPlus</a>。</p>
<h3 id="answer-1">Answer #1</h3>
<p>a) 形参在函数调用时候创建，在函数返回时销毁，自动存储变量，无链接性，所以是自动变量；</p>
<p>b) 文件共享的变量具有外部链接性，所以使用静态存储外部链接性的变量，比如在A文件中定义，在B中使用extern关键字引用；</p>
<p>c) 内部链接性，静态存储变量，可以使用static修饰符，或者使用未命名的命名空间；</p>
<p>d) 无链接性，但是是静态存储变量，在函数内部使用static修饰符定义</p>
<h3 id="answer-2">Answer #2</h3>
<p>有一下几点区别：</p>
<ol>
<li>using声明仅仅导入特定的名称，但是using编译命令将导入一个名称空间的所有名称；</li>
<li>假如名称空间和声明区域定义了相同的名称。using声明中如果该名称与局部名称发生冲突，编译器会发出警告，但是using编译指令导入的而名称会被局部版本隐藏。</li>
</ol>
<h3 id="answer-3">Answer #3</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#inlcude &lt;iostream&gt;
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="kt">double</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Enter valud: &#34;</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Bad input! Please enter a number: &#34;</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Value = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="answer-4">Answer #4</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="cp">#inlcude &lt;iostream&gt;
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">;</span>
    <span class="k">using</span> <span class="kt">double</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Enter valud: &#34;</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Bad input! Please enter a number: &#34;</span><span class="p">;</span>
        <span class="n">cin</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">cin</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">!=</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Value = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="answer-5">Answer #5</h3>
<p>因为两个函数的形参和顺序一样，仅仅是返回值不同，因此无法使用函数重载。如果在不同的文件中使用，这两个函数的作用域不同，有两种方式实现，</p>
<ol>
<li>可以使用static关键字，</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">static</span> <span class="kt">double</span> <span class="n">average</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">intb</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>将函数的声明和定义放在未命名的名称空间中</li>
</ol>
<h3 id="answer-6">Answer #6</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="m">10</span>
<span class="m">4</span>
<span class="m">0</span>
Other: 10, <span class="m">1</span>
another<span class="o">()</span>: 10, -4
</code></pre></td></tr></table>
</div>
</div><h3 id="answer-7">Answer #7</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="m">1</span>
4, 1, <span class="m">2</span>
<span class="m">2</span>
<span class="m">2</span>
4, 1, <span class="m">2</span>
<span class="m">2</span>
</code></pre></td></tr></table>
</div>
</div>]]></description>
</item><item>
    <title>[转载]双线性插值简介</title>
    <link>https://bugxch.github.io/%E8%BD%AC%E8%BD%BD-%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC%E7%AE%80%E4%BB%8B/</link>
    <pubDate>Sun, 26 Jan 2020 22:24:10 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://bugxch.github.io/%E8%BD%AC%E8%BD%BD-%E5%8F%8C%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC%E7%AE%80%E4%BB%8B/</guid>
    <description><![CDATA[<p>该文档转载自<a href="https://blog.csdn.net/xiaqunfeng123/article/details/17362881" target="_blank" rel="noopener noreffer">图像缩放——双线性插值算法</a>，我搜罗一堆中文文章里面讲得比较清楚的一篇了。</p>
<p></p>
<p>在数学上，双线性插值是有两个变量的插值函数的线性插值扩展，其核心思想是在两个方向分别进行一次线性插值。如果选择一个坐标系统使得 f 的四个已知点坐标分别为 (0, 0),(0, 1),(1, 0) 和 (1, 1)，那么插值公式就可以化简为
$$
f(x, y) \approx f(0,0)(1-x)(1-y)+f(1,0) x(1-y)+f(0,1)(1-x) y+f(1,1) x y
$$
用矩阵运算来表示的话就是
</p>
<p>图像的空间变换，也称几何变换或几何运算，包括图像的平移、旋转、镜像变换、转置、缩放等。空间变换可如下表示：设(u,v)为源图像上的点，(x,y)为目标图像上的点，则空间变换就是将源图像上(u,v)处的颜色值与目标图像上(x,y)处的颜色对应起来。
计算机所处理的图像都是指点阵图，也就是用一个像素矩阵来描述一副图像。举个简单的图像：3×3的256级灰度图，也就是高为3个象素，宽也是3个象素的图像，每个象素的取值可以是 0－255，代表该像素的亮度，255代表最亮，也就是白色，0代表最暗，即黑色 。</p>
<p>假如图像的象素矩阵如下所示：(这个矩阵中，图象处理中最常用的坐标系是：x从左到右，从0开始，y从上到下，也是从0开始)</p>
<p></p>
<p>如果想把这副图放大为 4X4大小的图像，那么第一步肯定想到的是先把4X4的矩阵先画出来再说，好了矩阵画出来了，如下所示，当然，矩阵的每个像素都是未知数，等待着我们去填充</p>
<p>
然后要往这个空的矩阵里面填值了，要填的值从哪里来来呢？是从源图中来，好，先填写目标图最左上角的象素，坐标为(0,0)，那么该坐标对应源图中的坐标可以由如下公式得出：
$$
srcX = dstX * (srcWidth / dstWidth) , \<br>
srcY = dstY * (srcHeight / dstHeight)
$$
套用公式，就可以找到对应的原图的坐标了$(0*(3/4),0*(3/4))=&gt;(0*0.75,0*0.75)=&gt;(0,0)$，找到了源图的对应坐标,就可以把源图中坐标为(0,0)处的234象素值填进去目标图的(0,0)这个位置了。所有的数值填充之后的结果如下所示</p>
<p>
这种放大图像的方法叫做<strong>最临近插值算法</strong>，这是一种最基本、最简单的图像缩放算法，效果也是最不好的，放大后的图像有很严重的马赛克，缩小后的图像有很严重的失真；效果不好的根源就是其简单的最临近插值方法引入了严重的图像失真。比如，当由目标图的坐标反推得到的源图的的坐标是一个浮点数的时候，采用了四舍五入的方法，直接采用了和这个浮点数最接近的象素的值，这种方法是很不科学的，当推得坐标值为 0.75的时候，不应该就简单的取为1，既然是0.75，比1要小0.25 ，比0要大0.75 ,那么目标象素值其实应该根据这个源图中虚拟的点四周的四个真实的点来按照一定的规律计算出来的，这样才能达到更好的缩放效果。</p>
<blockquote>
<p>双线型内插值算法就是一种比较好的图像缩放算法，它充分的利用了源图中虚拟点四周的四个真实存在的像素值来共同决定目标图中的一个像素值，因此缩放效果比简单的最邻近插值要好很多，计算量比零阶插值大，但缩放后图像质量高，不会出现像素值不连续的情况。</p>
</blockquote>
<p>双线性内插值算法描述如下:
　　对于一个目的像素，设置坐标通过反向变换得到的浮点坐标为(i+u,j+v) (其中i、j均为浮点坐标的整数部分，u、v为浮点坐标的小数部分，是取值[0,1)区间的浮点数)，则这个像素得值 f(i+u,j+v) 可由原图像中坐标为 (i,j),(i+1,j),(i,j+1),(i+1,j+1)所对应的周围四个像素的值决定，即：　　
$$
f(i+u, j+v)=(1-u)(1-v) f(i, j)+(1-u) v f(i, j+1)+u(1-v) f(i+1, j)+u v f(i+1, j+1)
$$</p>
<p>其中f(i,j)表示源图像(i,j)处的的像素值，以此类推。</p>
<p></p>
<p>假如目标图的象素坐标为(1,1)，那么反推得到的对应于源图的坐标是(0.75,0.75), 这其实只是一个概念上的虚拟象素,实际在源图中并不存在这样一个象素,那么目标图的象素(1,1)的取值不能够由这个虚拟象素来决定，而只能由源图的这四个象素共同决定：(0，0)(0，1)(1，0)(1，1)，而由于(0.75,0.75)离(1,1)要更近一些，那么(1,1)所起的决定作用更大一些，这从公式1中的系数uv=0.75×0.75就可以体现出来，而(0.75,0.75)离(0,0)最远，所以(0，0)所起的决定作用就要小一些，公式中系数为(1-u)(1-v)=0.25×0.25也体现出了这一特点。算法步骤详述：</p>
<p>假设原始图像大小为size=m×n，其中m与n分别是原始图像的行数与列数。若图像的缩放因子是t(t&gt;0)，则目标图像的大小size=t×m×t×n。对于目标图像的某个像素点P(x，y)通过P*1/t可得到对应的原始图像坐标P’( x1，y1),其中x1=x/t，y1=y/t，由于x1，y1都不是整数所以并不存在这样的点，这样可以找出与它相邻的四个点的灰度f1、f2、f3、f4，使用双线性插值算法就可以得到这个像素点P’(x1，y1)的灰度，也就是像素点P(x，y)的灰度。</p>
<p>一个完整的双线性插值算法可描述如下：</p>
<ol>
<li>通过原始图像和比例因子得到新图像的大小，并创建新图像。</li>
<li>由新图像的某个像素(x，y)映射到原始图像(x’,y’)处。</li>
<li>对x’,y’取整得到(xx，yy)并得到(xx，yy)、(xx+1，yy)、(xx，yy+1)和(xx+1，yy+1)的值。</li>
<li>利用双线性插值得到像素点(x,y)的值并写回新图像。</li>
<li>重复步骤2直到新图像的所有像素写完。</li>
</ol>]]></description>
</item><item>
    <title>Tensorboad查看pytorch模型</title>
    <link>https://bugxch.github.io/tensorboad%E6%9F%A5%E7%9C%8Bpytorch%E6%A8%A1%E5%9E%8B/</link>
    <pubDate>Fri, 06 Dec 2019 21:53:20 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://bugxch.github.io/tensorboad%E6%9F%A5%E7%9C%8Bpytorch%E6%A8%A1%E5%9E%8B/</guid>
    <description><![CDATA[<p>与tensorflow模型与caffe模型不同，当前的pytorch没有官方的直观查看网络结构的工具，google了下pytorch的网络解析的方法，发现可以将pytorch的model转换成为events文件使用tensorboard查看，记录之。</p>
<p></p>
<h2 id="安装插件">安装插件</h2>
<ul>
<li>
<p>TensorboardX，TensorboardX支持scalar, image, figure, histogram, audio, text, graph, onnx_graph, embedding, pr_curve and videosummaries等不同的可视化展示方式，具体介绍移步至项目Github 观看详情。使用下面的命令安装</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="n">pip</span> <span class="n">install</span> <span class="n">tensorboardX</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>安装tensorboard，参考命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="n">pip</span> <span class="n">install</span> <span class="n">tensorboard</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="具体过程">具体过程</h2>
<p>参考代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="c1">#-*-coding:utf-8-*-</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torchvision</span>
<span class="kn">from</span> <span class="nn">torch.autograd</span> <span class="kn">import</span> <span class="n">Variable</span>
<span class="kn">from</span> <span class="nn">tensorboardX</span> <span class="kn">import</span> <span class="n">SummaryWriter</span>

<span class="c1"># 模拟输入数据</span>
<span class="n">input_data</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">))</span>

<span class="c1"># 从torchvision中导入已有模型</span>
<span class="n">net</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">resnet18</span><span class="p">()</span>

<span class="c1"># 声明writer对象，保存的文件夹</span>
<span class="n">writer</span> <span class="o">=</span> <span class="n">SummaryWriter</span><span class="p">(</span><span class="n">log_dir</span><span class="o">=</span><span class="s1">&#39;./log&#39;</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s1">&#39;resnet18&#39;</span><span class="p">)</span>
<span class="k">with</span> <span class="n">writer</span><span class="p">:</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">add_graph</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="p">(</span><span class="n">input_data</span><span class="p">,))</span>
</code></pre></td></tr></table>
</div>
</div><p>该代码中14行声明一个writer对象，分别表示events存放的目录，comment表示事件的title，然后使用如下的方式打开tensorboard</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">tensorboard --logpath<span class="o">=</span>D:<span class="se">\l</span>og --port<span class="o">=</span><span class="m">6006</span>
</code></pre></td></tr></table>
</div>
</div><p>然后按照命令行提示打开即可。</p>
<h2 id="参考链接">参考链接</h2>
<ul>
<li><a href="https://www.pytorchtutorial.com/pytorch-tensorboardx/" target="_blank" rel="noopener noreffer">PyTorch 使用 TensorboardX 进行网络可视化-PyTorch 中文网</a></li>
<li><a href="https://www.jianshu.com/p/46eb3004beca" target="_blank" rel="noopener noreffer">Pytorch使用tensorboardX可视化。超详细！！！ - 简书</a></li>
<li><a href="https://pytorch.org/docs/stable/tensorboard.html" target="_blank" rel="noopener noreffer">torch.utils.tensorboard — PyTorch master documentation</a></li>
</ul>]]></description>
</item><item>
    <title>Manjaro添加开机启动脚本</title>
    <link>https://bugxch.github.io/manjaro%E6%B7%BB%E5%8A%A0%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/</link>
    <pubDate>Sun, 24 Feb 2019 20:48:23 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://bugxch.github.io/manjaro%E6%B7%BB%E5%8A%A0%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/</guid>
    <description><![CDATA[<p>如何给manjaro添加开机启动脚本。</p>
<p></p>
<p>前段时间折腾小黑T450安装了Manjaro系统，又安装了sublime text 3，顺便参考<a href="https://packagecontrol.io/installation" target="_blank" rel="noopener noreffer">Installation Package Control指导</a>安装了package control插件，但是很不幸国内的package control页面已经被屏蔽了。因此，需要给package control设置代理，根据<a href="https://segmentfault.com/a/1190000007621085" target="_blank" rel="noopener noreffer">《SublimeText 安装 PackageControl 及 HTTP 代理配置 - Tony的技术笔记 - SegmentFault 思否》</a>我看到一个方法是配置完设置之后，在shell中运行的命令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">polipo <span class="nv">socksParentProxy</span><span class="o">=</span>localhost:1080
</code></pre></td></tr></table>
</div>
</div><p>设置一下sublime text 3中的package control的代理就可以使用它安装插件了。但是每次开机之后都要敲入上面的命令，非常麻烦。</p>
<h2 id="安装过程">安装过程</h2>
<p>参考官方资料，按照如下的步骤设置了自动启动脚本</p>
<ol>
<li>
<p>新增一个autostart的桌面启动项，这一项开机后会随桌面启动</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="nb">cd</span> ~/.config/autostart
touch AutoExec.desktop
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>在创建的<code>AutoExec.desktop</code>中写入如下的内容</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>Desktop Entry<span class="o">]</span>
<span class="nv">Type</span><span class="o">=</span>Application
<span class="nv">Exec</span><span class="o">=</span><span class="s2">&#34;/etc/AutoExec.sh&#34;</span>
<span class="nv">Terminal</span><span class="o">=</span>yes
<span class="nv">Name</span><span class="o">=</span>AutoExec
X-GNOME-Autostart-enabled<span class="o">=</span><span class="nb">true</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>创建开机自启动脚本<code>/etc/AutoExec.sh</code>，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">sudo touch /etc/AutoExec.sh
chmod +x /etc/AutoExec.sh
</code></pre></td></tr></table>
</div>
</div><p>写入如下的内容</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">polipo <span class="nv">socksParentProxy</span><span class="o">=</span>localhost:1080 <span class="p">&amp;</span>
</code></pre></td></tr></table>
</div>
</div><p>即在开机之后的后台自动启动。</p>
</li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://wiki.archlinux.org/index.php/Systemd" target="_blank" rel="noopener noreffer">systemd - ArchWiki</a>，官方资料</li>
<li><a href="https://bbs.archlinux.org/viewtopic.php?id=86815" target="_blank" rel="noopener noreffer">[Solved] Execute script on startup / Newbie Corner / Arch Linux Forums</a>，论坛资料</li>
<li><a href="https://segmentfault.com/a/1190000007621085" target="_blank" rel="noopener noreffer">SublimeText 安装 PackageControl 及 HTTP 代理配置 - Tony的技术笔记 - SegmentFault 思否</a></li>
</ul>]]></description>
</item></channel>
</rss>
